(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var _stockBroadcaster = require('@livelyvideo/stock-broadcaster');

var _stockBroadcaster2 = _interopRequireDefault(_stockBroadcaster);

var _index = require('@livelyvideo/stock-live-player/lib/index.js');

var _index2 = _interopRequireDefault(_index);

var _xhr = require('xhr');

var _xhr2 = _interopRequireDefault(_xhr);

var _textContent = require('text-content');

var _textContent2 = _interopRequireDefault(_textContent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
Set up the flash broadcaster.

Params:
	- html element
	- relative or absolute path to retrieve an access key, defined in server.js
	- driver options [webrtc driver will be coming soon]
			> affiliate: required, this is your company/affiliate name
			> flashWmode: sets the flashWmode attribute
			> gateway: will be used for webrtc to define path, this can be left null if not using webrtc
			> iceServers: will be used for webrtc, this can be left null if not using webrtc
			> preview: defaults to true, false if broadcast w/no preview
			> rtmpUrl: origin server, this can be left null if not using flash
			> tfSwfPath: path to thinflash swf, located in /dist for this demo, this can be left null if not using flash

Events:
	- ready - broadcaster has been set up
	- mute - audio input has been muted
	- unmute - audio input unmuted
	- start - broadcasting has begun
	- stop - broadcast has stopped
	- error - fatal error

I attached the stockBroadcaster to the window so it can be accessed from console.  It has the broadcaster on it, and the controls.

**/
var stockBroadcaster = new _stockBroadcaster2.default(document.querySelector('#broadcaster'), '/access-key', {
	affiliate: 'img2',
	tfSwfPath: '/thinDebug.swf',
	rtmpUrl: 'rtmp://uc-ls-img2.livelyvideo.tv/origin',
	drivers: ['flash']
});
stockBroadcaster.on('error', function () {
	for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		args[_key] = arguments[_key];
	}

	console.error('error', args);
});
stockBroadcaster.setup();
window.stockBroadcaster = stockBroadcaster;

/**
Function to load the stock player, triggered later by a click event on <a> tags generated by the "get listings" button

Params:
	- html element
	- manifest url, returned by the listings endpoint located in server.js
	- player options
		> autoplay: [true] autoplays the stream when it loads
		> bitrate: [undefined] null for adaptive when available, desired kbps otherwise
		> drivers: ["mp4", "nativeHls", "jsHls", "flash", lodef"] driver priority
		> debug: [false] enables debug logging
		> recoverErrorCount: [10] Playback error count to recover the entire driver on
		> forceDrivers:	[false]
		> muted: whether or not the driver is muted
		> pollingInterval: [10000] ms timeout to wait before polling again
		> volume: [0.75] 0-1 volume
	- controls options
		> popout: popout options
		> popout[].url: url for popout
		> popout[].width: width for popout in px
		> popout[].height: height for popout in px

Events:
	- error emitted with all errors
	- exit-fullscreen
	- enter-fullscreen
	- bitrate-switch
	- select-driver
	- manifest
	- play
	- stop
	- pause
	- stall
	- progress
	- timeupdate
	- mute
	- unmute
	- volume
	- online
	- offline
	- estimated-bw
	- user-active
	- user-idle
**/
var stockPlayer = void 0;
var currentManifest = void 0;
var drivers = ['mediaSourceMp4', 'hlsjs', 'hls', 'flashRtmp'];
function loadPlayer(manifest) {
	if (stockPlayer) {
		stockPlayer.destroy();
	}

	currentManifest = manifest;
	window.stockPlayer = stockPlayer = new _index2.default(document.querySelector('#player'), manifest, {
		drivers: drivers,
		hlsjsPath: 'https://cdn.jsdelivr.net/hls.js/latest/hls.min.js',
		tfSwfPath: '/thinDebug.swf'
	});
}

/** Below is demo code **/

// retrieves listings from server.js
function getListings(cb) {
	(0, _xhr2.default)({
		method: 'GET',
		url: '/listings',
		json: true
	}, function (err, response, body) {
		if (err) {
			console.error(err);
			cb(err);
			return;
		}

		if (response.statusCode > 399) {
			console.error('unexpected status code', response.statusCode, body);
			cb(new Error(body));
			return;
		}

		cb(null, body);
	});
}

// create a button to load active listings and a div to contain them
var getListingsButton = document.createElement('button');
var resultsContainer = document.createElement('div');
var result = document.createElement('a');
result.setAttribute('href', '#');
(0, _textContent2.default)(getListingsButton, 'Load Listings');

// on click, empty div, retrieve listings, and render a tags for each listing
getListingsButton.onclick = function () {
	while (resultsContainer.children.length) {
		resultsContainer.children[0].remove();
	}

	getListings(function (err, body) {
		if (err) {
			return;
		}

		for (var i = 0; i < body.results.length; i++) {
			var entry = result.cloneNode();
			(0, _textContent2.default)(entry, body.results[i].broadcasterId);

			// for each listing, add a click listener to load that manifest.
			entry.onclick = function (manifest) {
				return function (e) {
					e.preventDefault();
					loadPlayer(manifest);
				};
			}(body.results[i].manifest);
			resultsContainer.appendChild(entry);
		}
	});
};
getListingsButton.onclick();

document.querySelector('.listings').appendChild(getListingsButton);
document.querySelector('.listings').appendChild(resultsContainer);

// Configure player
document.querySelector('#config-drivers').onsubmit = function (e) {
	e.preventDefault();
	var input = e.target.querySelector('input');
	var tmpDrivers = input.value.split(',');
	var nextDrivers = [];

	for (var i = 0; i < tmpDrivers.length; i++) {
		switch (tmpDrivers[i]) {
			case 'flashRtmp':
				nextDrivers.push('flashRtmp');
				break;
			case 'hlsjs':
				nextDrivers.push('hlsjs');
				break;
			case 'mediaSourceMp4':
				nextDrivers.push('mediaSourceMp4');
				break;
			case 'hls':
				nextDrivers.push('hls');
				break;
		}
	}

	drivers = nextDrivers;
	loadPlayer(currentManifest);
	input.value = drivers.join(', ');
};
document.querySelector('#config-drivers input').value = drivers.join(', ');

},{"@livelyvideo/stock-broadcaster":50,"@livelyvideo/stock-live-player/lib/index.js":51,"text-content":62,"xhr":64}],2:[function(require,module,exports){
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.LivelyLocales=t():e.LivelyLocales=t()}(this,function(){return function(e){function t(o){if(n[o])return n[o].exports;var r=n[o]={exports:{},id:o,loaded:!1};return e[o].call(r.exports,r,r.exports,t),r.loaded=!0,r.exports}var n={};return t.m=e,t.c=n,t.p="",t(0)}([function(e,t,n){"use strict";function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(t){if("object"!==("undefined"==typeof t?"undefined":i(t)))throw new Error("Lively Localization instantiated with something other than a messages object",{messages:t});return new f(e,t)}return e&&c[e]?c[e]:l}Object.defineProperty(t,"__esModule",{value:!0});var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}();"function"!=typeof Object.assign&&(Object.assign=function(e,t){if(null==e)throw new TypeError("Cannot convert undefined or null to object");for(var n=Object(e),o=1;o<arguments.length;o++){var r=arguments[o];if(null!=r)for(var i in r)Object.prototype.hasOwnProperty.call(r,i)&&(n[i]=r[i])}return n});var s={},c={},f=function(){function e(t,n){return o(this,e),t&&s[t]||n?(this.name=t,this.data=s[t]||{},void(n&&Object.assign(this.data,n))):void(this.localize=function(e){return e})}return a(e,[{key:"localize",value:function(e){var t=void 0;return(t=this.data[e])?t:(this.name?console.warn("'"+e+"' has no translation in the provided '"+this.name+"' locale files or localization messages"):console.warn("'"+e+"' has no translation in the provided localization messages."),e)}}]),e}(),u=n(1);u.keys().forEach(function(e){var t=e.split("/");3===t.length&&(s[t[1]]||(s[t[1]]={}),s[t[1]]=Object.assign(s[t[1]],u(e)))});var l=new f;Object.keys(s).forEach(function(e){c[e]=new f(e)}),t.default=r,e.exports=t.default},function(e,t){function n(e){throw new Error("Cannot find module '"+e+"'.")}n.keys=function(){return[]},n.resolve=n,e.exports=n,n.id=1}])});
},{}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = createElement;
function createElement(tagName, classes) {
	var x = document.createElement(tagName);
	x.classList.add.apply(x.classList, classes);
	return x;
}
},{}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _createElement = require('../create-element');

var _createElement2 = _interopRequireDefault(_createElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Fullscreen = function (_EventEmitter) {
	_inherits(Fullscreen, _EventEmitter);

	function Fullscreen(controls) {
		_classCallCheck(this, Fullscreen);

		var _this = _possibleConstructorReturn(this, (Fullscreen.__proto__ || Object.getPrototypeOf(Fullscreen)).call(this));

		_this.controls = controls;
		_this.livelyPlayer = controls.livelyPlayer;
		_this.bar = controls.bar;
		_this.el = (0, _createElement2.default)('div', ['lvcontrols__fullscreen']);
		_this.el.setAttribute('title', _this.controls.localize('Full Screen'));
		_this.bar.appendChild(_this.el);
		_this.el.addEventListener('click', _this.toggleFullScreen.bind(_this));
		return _this;
	}

	/**
  * destroys the full screen button
  * @return {void}
  */


	_createClass(Fullscreen, [{
		key: 'destroy',
		value: function destroy() {
			this.el.remove();
		}

		/**
   * sets the fullscreen icon
   * @return {void}
   */

	}, {
		key: 'setIcon',
		value: function setIcon() {
			if (this.isFullscreen()) {
				this.el.classList.remove('lvcontrols__fullscreen--exit');
			} else {
				this.el.classList.add('lvcontrols__fullscreen--exit');
			}
		}

		/**
   * true if fullscreeen, false otherwise - from moz docs
   * @return {Boolean}
   */

	}, {
		key: 'isFullscreen',
		value: function isFullscreen() {
			return !!(document.fullScreen || document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement || document.fullscreenElement);
		}

		/**
   * goes full screen
   * @return {void}
   */

	}, {
		key: 'toggleFullScreen',
		value: function toggleFullScreen() {
			if (this.isFullscreen()) {
				if (document.exitFullscreen) {
					document.exitFullscreen();
				} else if (document.mozCancelFullScreen) {
					document.mozCancelFullScreen();
				} else if (document.webkitCancelFullScreen) {
					document.webkitCancelFullScreen();
				} else if (document.msExitFullscreen) {
					document.msExitFullscreen();
				}
				this.setIcon();
				return;
			}

			var parent = this.livelyPlayer.el.parentNode;
			if (parent.requestFullscreen) {
				parent.requestFullscreen();
			} else if (parent.mozRequestFullScreen) {
				parent.mozRequestFullScreen();
			} else if (parent.webkitRequestFullScreen) {
				parent.webkitRequestFullScreen();
			} else if (parent.msRequestFullscreen) {
				parent.msRequestFullscreen();
			} else if (this.livelyPlayer.el.webkitEnterFullscreen) {
				this.livelyPlayer.el.webkitEnterFullscreen();
			}
			this.setIcon();
		}
	}]);

	return Fullscreen;
}(_events2.default);

exports.default = Fullscreen;
},{"../create-element":3,"events":54}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = getElPosition;
/**
 * helper function to get an elements position
 * @param  {object} el
 * @return {object} position
 */
function getElPosition(el) {
	var rect = void 0;

	if (el.getBoundingClientRect && el.parentNode) {
		rect = el.getBoundingClientRect();
	}

	if (!rect) {
		return {
			top: 0,
			left: 0,
			right: 0
		};
	}

	var doc = document.documentElement;
	var body = document.body;

	var clientTop = doc.clientTop || body.clientTop || 0;
	var clientLeft = doc.clientLeft || body.clientLeft || 0;
	var scrollTop = window.pageYOffset || body.scrollTop;
	var scrollLeft = window.pageXOffset || body.scrollLeft;

	var left = Math.floor(rect.left + scrollLeft - clientLeft);
	return {
		top: Math.floor(rect.top + scrollTop - clientTop),
		left: left,
		right: left + rect.right
	};
}
},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = getPointerPosition;
/**
 * gets a pointers position
 * @param  {object} event
 * @return {object} position
 */
function getPointerPosition(event) {
	var pageY = event.pageY;
	var pageX = event.pageX;

	if (event.changedTouches) {
		pageY = event.changedTouches[0].pageY;
		pageX = event.changedTouches[0].pageX;
	}

	return {
		y: pageY,
		x: pageX
	};
}
},{}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polyfills = require('./polyfills');

var _polyfills2 = _interopRequireDefault(_polyfills);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _detect = require('@livelyvideo/player-core/lib/detect');

var _detect2 = _interopRequireDefault(_detect);

var _getDefaultOptions = require('@livelyvideo/player-core/lib/get-default-options');

var _getDefaultOptions2 = _interopRequireDefault(_getDefaultOptions);

var _logger = require('@livelyvideo/player-core/lib/logger');

var _logger2 = _interopRequireDefault(_logger);

var _localization = require('@livelyvideo/localization');

var _localization2 = _interopRequireDefault(_localization);

var _fullscreen = require('./fullscreen');

var _fullscreen2 = _interopRequireDefault(_fullscreen);

var _overlay = require('./overlay');

var _overlay2 = _interopRequireDefault(_overlay);

var _popout = require('./popout');

var _popout2 = _interopRequireDefault(_popout);

var _playpause = require('./playpause');

var _playpause2 = _interopRequireDefault(_playpause);

var _progress = require('./progress');

var _progress2 = _interopRequireDefault(_progress);

var _keyboard = require('./keyboard');

var _keyboard2 = _interopRequireDefault(_keyboard);

var _qualitySelector = require('./quality-selector');

var _qualitySelector2 = _interopRequireDefault(_qualitySelector);

var _screenInteraction = require('./screen-interaction');

var _screenInteraction2 = _interopRequireDefault(_screenInteraction);

var _volume = require('./volume');

var _volume2 = _interopRequireDefault(_volume);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DefaultOptions = {
	controls: ['overlay', 'playpause', 'fullscreen', 'popout', 'progress', 'quality-selector', 'volume', 'keyboard'],
	popout: {
		url: '',
		width: 480,
		height: 280
	}
};

/**
 * @class Stock lively player controls
 */

var Controls = function (_EventEmitter) {
	_inherits(Controls, _EventEmitter);

	/**
  * @param {object} [options] controls options
  * @param {object} [options[].controls] controls to attach, defaults to: ['overlay', 'playpause', 'fullscreen', 'popout', 'progress', 'quality-selector', 'volume']
  * @param {object} [options[].popout] popout options
  * @param {string} [options[].popout[].url] url for popout
  * @param {number} [options[].popout[].width] width for popout in px
  * @param {number} [options[].popout[].height] height for popout in px
  * @return {void}
  */
	function Controls(el, options) {
		_classCallCheck(this, Controls);

		var _this = _possibleConstructorReturn(this, (Controls.__proto__ || Object.getPrototypeOf(Controls)).call(this));

		_this.el = el;
		_this.bar = document.createElement('div');
		_this.controls = [];

		_this.mobileControls = _detect2.default.any();
		if (_this.mobileControls) {
			_this.el.classList.add('mobile');
		}
		_this.el.classList.add('lvcontrols');
		_this.bar.classList.add('lvcontrols__bar');
		_this.el.appendChild(_this.bar);

		_this.options = (0, _getDefaultOptions2.default)(options, DefaultOptions);
		var livelyLocalization = new _localization2.default(null, _this.options.messages);
		_this.localize = livelyLocalization.localize.bind(livelyLocalization);

		if (_this.options.livelyPlayer) {
			_this.attach(_this.options.livelyPlayer);
		}
		return _this;
	}

	/**
  * destroys all active controls
  * @return {void}
  */


	_createClass(Controls, [{
		key: 'destroyControls',
		value: function destroyControls() {
			for (var i = 0; i < this.controls.length; i++) {
				this.controls[i].destroy();
			}
		}

		/**
   * destroys controls and control bar
   * @return {void}
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			this.destroyControls();
			this.bar.remove();
			if (this.screenInteraction) {
				this.screenInteraction.destroy();
			}
		}

		/**
   * Attaches a lively player to the controls
   * @param {object} livelyPlayer
   */

	}, {
		key: 'attach',
		value: function attach(livelyPlayer) {
			var _this2 = this;

			this.livelyPlayer = livelyPlayer;
			var attachControl = function attachControl(control) {
				switch (control) {
					case 'fullscreen':
						_this2.controls.push(new _fullscreen2.default(_this2));
						break;
					case 'overlay':
						_this2.controls.push(new _overlay2.default(_this2));
						break;
					case 'playpause':
						_this2.controls.push(new _playpause2.default(_this2));
						break;
					case 'popout':
						_this2.controls.push(new _popout2.default(_this2));
						break;
					case 'progress':
						_this2.controls.push(new _progress2.default(_this2));
						break;
					case 'quality-selector':
						_this2.controls.push(new _qualitySelector2.default(_this2));
						break;
					case 'keyboard':
						_this2.controls.push(new _keyboard2.default(_this2));
						break;
					case 'volume':
						_this2.controls.push(new _volume2.default(_this2));
						break;
					default:
						_logger2.default.error('unrecognized control', control);
						break;
				}
			};

			for (var i = 0; i < this.options.controls.length; i++) {
				attachControl(this.options.controls[i]);
			}

			this.screenInteraction = new _screenInteraction2.default(this.el);
			this.screenInteraction.on('user-active', function () {
				_this2.bar.classList.add('lvcontrols__bar--interacting');
			});
			this.screenInteraction.on('user-idle', function () {
				_this2.bar.classList.remove('lvcontrols__bar--interacting');
			});
		}
	}]);

	return Controls;
}(_events2.default);

exports.default = Controls;
},{"./fullscreen":4,"./keyboard":8,"./overlay":9,"./playpause":10,"./polyfills":11,"./popout":12,"./progress":13,"./quality-selector":14,"./screen-interaction":15,"./volume":16,"@livelyvideo/localization":2,"@livelyvideo/player-core/lib/detect":18,"@livelyvideo/player-core/lib/get-default-options":22,"@livelyvideo/player-core/lib/logger":23,"events":54}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// import createElement from '../create-element';

var Keyboard = function (_EventEmitter) {
	_inherits(Keyboard, _EventEmitter);

	function Keyboard(controls) {
		_classCallCheck(this, Keyboard);

		var _this = _possibleConstructorReturn(this, (Keyboard.__proto__ || Object.getPrototypeOf(Keyboard)).call(this));

		_this.livelyPlayer = controls.livelyPlayer;
		_this.livelyPlayer.el.addEventListener('keypress', _this.handleKeyPress.bind(_this));
		return _this;
	}

	_createClass(Keyboard, [{
		key: 'handleKeyPress',
		value: function handleKeyPress() {
			//
		}
	}, {
		key: 'destroy',
		value: function destroy() {
			this.livelyPlayer.el.removeEventListener('keypress', this.handleKeyPress);
		}
	}]);

	return Keyboard;
}(_events2.default);

exports.default = Keyboard;
},{"events":54}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _textContent = require('text-content');

var _textContent2 = _interopRequireDefault(_textContent);

var _createElement = require('../create-element');

var _createElement2 = _interopRequireDefault(_createElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RESTART_TIMEOUT = 5000;

var Overlay = function (_EventEmitter) {
	_inherits(Overlay, _EventEmitter);

	function Overlay(controls) {
		_classCallCheck(this, Overlay);

		var _this = _possibleConstructorReturn(this, (Overlay.__proto__ || Object.getPrototypeOf(Overlay)).call(this));

		_this.controls = controls;
		_this.livelyPlayer = controls.livelyPlayer;
		_this.bar = controls.bar;
		_this.el = (0, _createElement2.default)('div', ['lvcontrols__big-button']);
		_this.el.setAttribute('title', _this.controls.localize('Play'));
		_this.controls.el.appendChild(_this.el);
		_this.el.addEventListener('click', _this.togglePlaying.bind(_this));
		_this.showRestarter = 0;

		_this.livelyPlayer.on('play', function () {
			_this.setIcon();
			_this.resetRestarter();
		});
		_this.livelyPlayer.on('pause', function () {
			_this.setIcon();
			_this.stopRestarter();
		});
		_this.livelyPlayer.on('stop', function () {
			_this.setIcon();
			_this.stopRestarter();
		});
		_this.livelyPlayer.on('ended', _this.setIcon.bind(_this));
		_this.livelyPlayer.on('offline', _this.setIcon.bind(_this));
		_this.livelyPlayer.on('timeupdate', function () {
			_this.setIcon();
			_this.showRestarter = 0;
			_this.resetRestarter();
		});
		_this.livelyPlayer.once('manifest', _this.setIcon.bind(_this));
		return _this;
	}

	_createClass(Overlay, [{
		key: 'resetRestarter',
		value: function resetRestarter() {
			var _this2 = this;

			if (this.livelyPlayer.vod) {
				return;
			}
			this.stopRestarter();
			this.restarter = setTimeout(function () {
				_this2.showRestarter = 1;
			}, RESTART_TIMEOUT);
		}
	}, {
		key: 'stopRestarter',
		value: function stopRestarter() {
			clearTimeout(this.restarter);
			this.showRestarter = 0;
		}
	}, {
		key: 'destroy',
		value: function destroy() {
			this.el.remove();
		}
	}, {
		key: 'setIcon',
		value: function setIcon() {
			if (this.livelyPlayer.getState() === 'offline') {
				this.el.classList.remove('lvcontrols__big-button--stopped');
				this.el.classList.remove('lvcontrols__big-button--playing');
				this.el.classList.add('lvcontrols__big-button--offline');
				(0, _textContent2.default)(this.el, this.controls.localize('Stream is currently offline'));
			} else if (this.livelyPlayer.tryingToPlay) {
				if (this.showRestarter) {
					this.el.classList.remove('lvcontrols__big-button--playing');
					this.el.classList.remove('lvcontrols__big-button--offline');
					this.el.classList.add('lvcontrols__big-button--stopped');
					(0, _textContent2.default)(this.el, '');
				} else {
					this.el.classList.remove('lvcontrols__big-button--stopped');
					this.el.classList.remove('lvcontrols__big-button--offline');
					this.el.classList.add('lvcontrols__big-button--playing');
					(0, _textContent2.default)(this.el, '');
				}
			} else {
				this.el.classList.remove('lvcontrols__big-button--playing');
				this.el.classList.remove('lvcontrols__big-button--offline');
				this.el.classList.add('lvcontrols__big-button--stopped');
				(0, _textContent2.default)(this.el, '');
			}
		}
	}, {
		key: 'togglePlaying',
		value: function togglePlaying() {
			if (this.showRestarter) {
				this.livelyPlayer.restart();
			} else if (this.livelyPlayer.tryingToPlay) {
				this.el.setAttribute('title', this.controls.localize('Pause'));
				this.livelyPlayer.stop();
			} else {
				this.el.setAttribute('title', this.controls.localize('Play'));
				this.livelyPlayer.play();
			}
		}
	}]);

	return Overlay;
}(_events2.default);

exports.default = Overlay;
},{"../create-element":3,"events":54,"text-content":62}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _createElement = require('../create-element');

var _createElement2 = _interopRequireDefault(_createElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PlayPause = function (_EventEmitter) {
	_inherits(PlayPause, _EventEmitter);

	function PlayPause(controls) {
		_classCallCheck(this, PlayPause);

		var _this = _possibleConstructorReturn(this, (PlayPause.__proto__ || Object.getPrototypeOf(PlayPause)).call(this));

		_this.controls = controls;
		_this.livelyPlayer = controls.livelyPlayer;
		_this.bar = controls.bar;
		_this.el = (0, _createElement2.default)('div', ['lvcontrols__play-button']);
		_this.el.setAttribute('title', _this.controls.localize('Toggle play/pause'));
		_this.bar.appendChild(_this.el);
		_this.el.addEventListener('click', _this.togglePlaying.bind(_this));

		_this.livelyPlayer.on('play', _this.setIcon.bind(_this));
		_this.livelyPlayer.on('pause', _this.setIcon.bind(_this));
		_this.livelyPlayer.on('stop', _this.setIcon.bind(_this));
		_this.livelyPlayer.on('ended', _this.setIcon.bind(_this));
		_this.setIcon();
		return _this;
	}

	_createClass(PlayPause, [{
		key: 'destroy',
		value: function destroy() {
			this.el.remove();
		}
	}, {
		key: 'setIcon',
		value: function setIcon() {
			if (this.livelyPlayer.tryingToPlay) {
				this.el.classList.remove('lvcontrols__play-button--stopped');
				this.el.classList.add('lvcontrols__play-button--playing');
				this.el.setAttribute('title', this.controls.localize('Pause'));
			} else {
				this.el.classList.remove('lvcontrols__play-button--playing');
				this.el.classList.add('lvcontrols__play-button--stopped');
				this.el.setAttribute('title', this.controls.localize('Play'));
			}
		}
	}, {
		key: 'togglePlaying',
		value: function togglePlaying() {
			if (this.livelyPlayer.tryingToPlay) {
				if (this.livelyPlayer.vod) {
					this.livelyPlayer.pause();
				} else {
					this.livelyPlayer.stop();
				}
			} else {
				this.livelyPlayer.play();
			}
		}
	}]);

	return PlayPause;
}(_events2.default);

exports.default = PlayPause;
},{"../create-element":3,"events":54}],11:[function(require,module,exports){
'use strict';

if (typeof Object.assign != 'function') {
  Object.assign = function (target, varArgs) {
    // .length of function is 2
    'use strict';

    if (target == null) {
      // TypeError if undefined or null
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var to = Object(target);

    for (var index = 1; index < arguments.length; index++) {
      var nextSource = arguments[index];

      if (nextSource != null) {
        // Skip over if undefined or null
        for (var nextKey in nextSource) {
          // Avoid bugs when hasOwnProperty is shadowed
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
    return to;
  };
}
},{}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _logger = require('@livelyvideo/player-core/lib/logger');

var _logger2 = _interopRequireDefault(_logger);

var _parseUrl = require('@livelyvideo/player-core/lib/parse-url');

var _parseUrl2 = _interopRequireDefault(_parseUrl);

var _createElement = require('../create-element');

var _createElement2 = _interopRequireDefault(_createElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Popout = function (_EventEmitter) {
	_inherits(Popout, _EventEmitter);

	function Popout(controls) {
		_classCallCheck(this, Popout);

		var _this = _possibleConstructorReturn(this, (Popout.__proto__ || Object.getPrototypeOf(Popout)).call(this));

		if (!controls.options.popout || !controls.options.popout.url) {
			return _possibleConstructorReturn(_this);
		}

		_this.popoutUrl = (0, _parseUrl2.default)(controls.options.popout.url);
		if (!_this.popoutUrl) {
			_logger2.default.error('popout url is invalid');
			return _possibleConstructorReturn(_this);
		}

		_this.controls = controls;
		_this.livelyPlayer = controls.livelyPlayer;
		_this.bar = controls.bar;

		_this.popoutOptions = 'width=' + controls.options.popout.width + ', height=' + controls.options.popout.height + ', resizable=yes, scrollbars=no, titlebar=no';
		_this.poppedoutPlayer = null;

		_this.el = (0, _createElement2.default)('div', ['lvcontrols__popout-button']);
		_this.el.setAttribute('target', '_blank');
		_this.el.setAttribute('title', _this.controls.localize('Popout'));
		_this.el.addEventListener('click', _this.openPopout.bind(_this));
		_this.bar.appendChild(_this.el);

		_this.el.addEventListener('click', _this.openPopout.bind(_this));
		return _this;
	}

	_createClass(Popout, [{
		key: 'destroy',
		value: function destroy() {
			if (this.el) {
				this.el.remove();
			}
		}
	}, {
		key: 'popoverStartPlaying',
		value: function popoverStartPlaying(startDetails) {
			var _this2 = this;

			if (!this.livelyPlayer) {
				_logger2.default.error('could not start playing on pop in, no player instance');
				return;
			}

			this.livelyPlayer.play();
			if (startDetails) {
				this.livelyPlayer.currentTime = startDetails.currentTime;
				this.livelyPlayer.volume(startDetails.volume);
			}

			this.livelyPlayer.play(function () {
				if (startDetails && startDetails.muted) {
					_this2.livelyPlayer.mute();
				} else if (startDetails && !startDetails.muted) {
					_this2.livelyPlayer.unmute();
				}
			});
		}
	}, {
		key: 'openPopout',
		value: function openPopout(e) {
			var _this3 = this;

			if (!this.livelyPlayer) {
				_logger2.default.error('could not attach popout, no player instance');
				return;
			}

			if (this.poppedoutPlayer) {
				this.poppedoutPlayer.focus();
				return;
			}

			e.preventDefault();

			if (this.poppedoutPlayer) {
				this.poppedoutPlayer.onbeforeunload = null;
				this.poppedoutPlayer.onunload = null;
			}

			if (this.livelyPlayer.vod) {
				var delimiter = this.popoutUrl.search ? '&' : '?';

				if (this.popoutUrl) {
					this.popoutUrl.href += delimiter + 'start' + this.livelyPlayer.currentTime;
				}
			}

			this.poppedoutPlayer = window.open(this.popoutUrl.href, '_blank', this.popoutOptions);
			this.livelyPlayer.pause();

			var startDetails = void 0;
			var handleUnload = function handleUnload() {
				if (_this3.poppedoutPlayer.closed) {
					return;
				}

				delete _this3.poppedoutPlayer;
				setTimeout(function () {
					_this3.popoverStartPlaying(startDetails);
				}, 20);
			};

			this.poppedoutPlayer.onmessage = function onpopoutMessage(message) {
				startDetails = message.data;
			};

			setTimeout(function () {
				_this3.poppedoutPlayer.addEventListener('beforeunload', handleUnload);
			}, 250);
		}
	}]);

	return Popout;
}(_events2.default);

exports.default = Popout;
},{"../create-element":3,"@livelyvideo/player-core/lib/logger":23,"@livelyvideo/player-core/lib/parse-url":26,"events":54}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _logger = require('@livelyvideo/player-core/lib/logger');

var _logger2 = _interopRequireDefault(_logger);

var _getElPosition = require('../get-el-position');

var _getElPosition2 = _interopRequireDefault(_getElPosition);

var _getPointerPosition = require('../get-pointer-position');

var _getPointerPosition2 = _interopRequireDefault(_getPointerPosition);

var _textContent = require('text-content');

var _textContent2 = _interopRequireDefault(_textContent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Progress = function (_EventEmitter) {
	_inherits(Progress, _EventEmitter);

	function Progress(controls) {
		_classCallCheck(this, Progress);

		var _this = _possibleConstructorReturn(this, (Progress.__proto__ || Object.getPrototypeOf(Progress)).call(this));

		_this.controls = controls;
		_this.livelyPlayer = controls.livelyPlayer;
		_this.bar = controls.bar;
		_this.rendered = false;

		_this.livelyPlayer.on('manifest', _this.renderIfNotRendered.bind(_this));
		_this.render();
		return _this;
	}

	_createClass(Progress, [{
		key: 'renderIfNotRendered',
		value: function renderIfNotRendered() {
			if (this.rendered) {
				return;
			}
			this.render();
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			if (!this.livelyPlayer.vod) {
				return;
			}
			this.rendered = true;
			this.livelyPlayer.removeListener('manifest', this.renderIfNotRendered);
			this.el = document.createElement('div');

			var cn = this.controls.screenInteraction.userInteraction ? 'lvcontrols__progress lvcontrols__progress--interacting' : 'lvcontrols__progress';
			this.el.setAttribute('class', cn);
			this.progressBarEl = document.createElement('div');
			this.progressBarEl.setAttribute('class', 'lvcontrols__progress-bar');
			this.sliderBufferEl = document.createElement('div');
			this.sliderBufferEl.setAttribute('class', 'lvcontrols__progress-slider-buffer');
			this.sliderValueEl = document.createElement('div');
			this.sliderValueEl.setAttribute('class', 'lvcontrols__progress-slider-value');
			this.durationEl = document.createElement('div');
			this.durationEl.setAttribute('class', 'lvcontrols__duration');
			this.currentTimeEl = document.createElement('div');
			this.currentTimeEl.setAttribute('class', 'lvcontrols__current-time');

			this.controls.screenInteraction.on('user-active', function () {
				_this2.el.classList.add('lvcontrols__progress--interacting');
			});
			this.controls.screenInteraction.on('user-idle', function () {
				_this2.el.classList.remove('lvcontrols__progress--interacting');
			});

			this.nextTime = 0;
			this.el.addEventListener('mousedown', function (e) {
				_this2.startDrag(e);
			});
			document.addEventListener('mouseup', function (e) {
				_this2.stopDrag(e);
			});
			document.addEventListener('mousemove', function (e) {
				_this2.moveSlider(e);
			});

			this.el.appendChild(this.progressBarEl);
			this.el.appendChild(this.sliderBufferEl);
			this.el.appendChild(this.sliderValueEl);
			this.el.appendChild(this.durationEl);
			this.el.appendChild(this.currentTimeEl);
			this.controls.el.appendChild(this.el);

			this.livelyPlayer.on('timeupdate', function (e) {
				_this2.updateSliderValue(e);
			});

			this.livelyPlayer.on('progress', function (e) {
				_this2.updateSliderValue(e);
			});
		}
	}, {
		key: 'calculateSeek',
		value: function calculateSeek(e) {
			if (!this.dragging) {
				return;
			}

			var v = ((0, _getPointerPosition2.default)(e).x - (0, _getElPosition2.default)(this.el).left) / this.el.getBoundingClientRect().width;
			v = Math.max(v, 0);
			v = Math.min(v, 1);
			this.nextTime = v * this.livelyPlayer.duration;
		}
	}, {
		key: 'updateSliderValue',
		value: function updateSliderValue() {
			if (this.dragging) {
				return;
			}
			var a = this.livelyPlayer;
			var currentTime = a.currentTime;
			var currentPosition = currentTime / a.duration;
			var bufferTimes = this.livelyPlayer.bufferTimes;

			var relevantBuffer = void 0;

			for (var i = 0; i < bufferTimes.length; i++) {
				if (currentTime >= bufferTimes[i][0] && currentTime <= bufferTimes[i][1]) {
					relevantBuffer = bufferTimes[i];
					break;
				}
			}

			if (relevantBuffer) {
				var startBuffer = Math.max(Number((relevantBuffer[0] / a.duration).toFixed(2)), 0);
				var endBuffer = Math.max(Number((relevantBuffer[1] / a.duration).toFixed(2)), 0);
				this.sliderBufferEl.style.left = startBuffer * 100 + '%';
				this.sliderBufferEl.style.width = (endBuffer - startBuffer) * 100 + '%';
			} else {
				this.sliderBufferEl.style.width = 0;
			}
			this.sliderValueEl.style.width = currentPosition * 100 + '%';

			(0, _textContent2.default)(this.durationEl, '' + this.formatHHMMSS(a.duration));
			(0, _textContent2.default)(this.currentTimeEl, '' + this.formatHHMMSS(a.currentTime));
		}
	}, {
		key: 'formatHHMMSS',
		value: function formatHHMMSS(s) {
			var secNum = parseInt(s, 10); // don't forget the second param
			var hours = Math.floor(secNum / 3600);
			var minutes = Math.floor((secNum - hours * 3600) / 60);
			var seconds = secNum - hours * 3600 - minutes * 60;

			function appendTime(times, t) {
				if (isNaN(t)) {
					return;
				}

				if (t < 10) {
					times.push('0' + t);
				} else {
					times.push(t);
				}
			}

			var times = [];
			appendTime(times, hours);
			appendTime(times, minutes);
			appendTime(times, seconds);

			return times.join(':');
		}
	}, {
		key: 'moveSlider',
		value: function moveSlider(e) {
			if (!this.dragging) {
				return;
			}

			var val = (0, _getPointerPosition2.default)(e).x - (0, _getElPosition2.default)(this.el).left;

			if (val < 0) {
				val = 0;
			} else if (val > this.el.clientWidth) {
				val = this.el.clientWidth;
			}

			this.sliderValueEl.style.width = val + 'px';
		}

		/**
   * starts the drag event listeners
   * @return {void}
   */

	}, {
		key: 'startDrag',
		value: function startDrag() {
			this.dragging = true;
		}

		/**
   * stop the drag event listeenrs
   * @return {void}
   */

	}, {
		key: 'stopDrag',
		value: function stopDrag(e) {
			if (!this.dragging) {
				return;
			}
			this.dragging = false;
			var v = ((0, _getPointerPosition2.default)(e).x - (0, _getElPosition2.default)(this.el).left) / this.el.getBoundingClientRect().width;
			v = Math.max(v, 0);
			v = Math.min(v, 1);

			var nextTime = v * this.livelyPlayer.duration;
			if (isNaN(nextTime)) {
				_logger2.default.error('attempted to set current time to NaN', nextTime);
				return;
			}
			this.livelyPlayer.currentTime = nextTime;
		}
	}, {
		key: 'destroy',
		value: function destroy() {
			this.livelyPlayer.removeListener('manifest', this.renderIfNotRendered);
			this.livelyPlayer.removeListener('timeupdate', this.updateSliderValue);
			this.livelyPlayer.removeListener('progress', this.updateSliderValue);
			if (!this.rendered) {
				return;
			}
			this.rendered = false;
			this.el.remove();
			this.progressBarEl.remove();
			this.sliderBufferEl.remove();
			this.sliderValueEl.remove();
			document.removeEventListener('mouseup', this.stopDrag.bind(this));
		}
	}]);

	return Progress;
}(_events2.default);

exports.default = Progress;
},{"../get-el-position":5,"../get-pointer-position":6,"@livelyvideo/player-core/lib/logger":23,"events":54,"text-content":62}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _textContent = require('text-content');

var _textContent2 = _interopRequireDefault(_textContent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var QualitySelector = function (_EventEmitter) {
	_inherits(QualitySelector, _EventEmitter);

	function QualitySelector(controls) {
		_classCallCheck(this, QualitySelector);

		var _this = _possibleConstructorReturn(this, (QualitySelector.__proto__ || Object.getPrototypeOf(QualitySelector)).call(this));

		_this.controls = controls;
		_this.livelyPlayer = controls.livelyPlayer;
		_this.bar = controls.bar;

		_this.mediaData = null;
		_this.encodings = [];

		_this.el = document.createElement('div');
		_this.el.setAttribute('title', _this.controls.localize('Quality Selector'));
		_this.qualitiesEl = document.createElement('div');
		_this.qualitiesEl.setAttribute('class', 'lvcontrols__qualities lvcontrols__qualities--hidden');
		_this.el.addEventListener('click', _this.openQualitySelector.bind(_this));

		_this.livelyPlayer.on('progress', function () {
			_this.reclass();
		});
		_this.livelyPlayer.on('play', function () {
			// check to see if needs to render
			_this.render();
		});

		_this.controls.bar.appendChild(_this.qualitiesEl);
		_this.controls.bar.appendChild(_this.el);
		return _this;
	}

	/**
  * @return {void}
  */


	_createClass(QualitySelector, [{
		key: 'openQualitySelector',
		value: function openQualitySelector(e) {
			if (this.qualitiesEl.getAttribute('class') === 'lvcontrols__qualities') {
				return;
			}
			this.controls.screenInteraction.lockOpen();
			this.qualitiesEl.setAttribute('class', 'lvcontrols__qualities');
			e.stopPropagation();
			document.addEventListener('click', this.closeQualitySelector.bind(this));
		}

		/**
   * @return {void}
   */

	}, {
		key: 'closeQualitySelector',
		value: function closeQualitySelector() {
			this.controls.screenInteraction.releaseLockOpen();
			document.removeEventListener('click', this.closeQualitySelector.bind(this));
			this.qualitiesEl.setAttribute('class', 'lvcontrols__qualities lvcontrols__qualities--hidden');
		}

		/**
   * Destroy the quality selector
   * @return {void}
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			document.removeEventListener('click', this.closeQualitySelector.bind(this));
			this.qualitiesEl.remove();
			this.el.remove();
		}
	}, {
		key: 'reclass',
		value: function reclass() {
			var currentEncoding = this.livelyPlayer.currentEncoding();
			var currentLevel = void 0;
			var nextLevel = void 0;

			if (!currentEncoding) {
				// - 2 for auto and 0index
				currentLevel = this.currentLevel;
				nextLevel = this.nextLevel;
			}

			var encoding = void 0;
			for (var i = 0; i < this.qualitiesEl.children.length; i++) {
				encoding = this.qualitiesEl.children[i];

				if (i === currentLevel || currentEncoding && this.qualitiesEl.children[i].getAttribute('data-location') === currentEncoding.location) {
					encoding.classList.add('lvcontrols__quality--current-level');
				} else {
					encoding.classList.remove('lvcontrols__quality--current-level');
				}
				if (i === nextLevel) {
					encoding.classList.add('lvcontrols__quality--next-level');
				} else {
					encoding.classList.remove('lvcontrols__quality--next-level');
				}
			}
		}

		/**
   * renders the quality selector
   * @return {void}
   */

	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			this.encodings.forEach(function (e) {
				e.remove();
			});
			this.encodings = [];

			this.mediaData = this.livelyPlayer.mediaData;
			if (this.mediaData && this.mediaData.encodings && this.mediaData.encodings.length) {
				this.el.setAttribute('class', 'lvcontrols__quality-selector');
			} else {
				this.el.setAttribute('class', 'lvcontrols__quality-selector lvcontrols__quality-selector--hidden');
				return;
			}

			var currentEncoding = this.livelyPlayer.currentEncoding();
			var currentLevel = this.currentLevel;
			var chosenLevel = this.chosenLevel;
			var nextLevel = this.nextLevel;

			var appendEncoding = function appendEncoding(e, k) {
				var encoding = document.createElement('div');
				var cn = 'lvcontrols__quality';
				var bitrate = void 0;

				if (!e.videoKbps) {
					return;
				}

				if (!e.videoHeight) {
					currentLevel--;
					chosenLevel--;
					nextLevel--;
					(0, _textContent2.default)(encoding, _this2.controls.localize('Auto'));
					bitrate = null;
					if (currentEncoding === null) {
						cn += ' lvcontrols__quality--selected';
					}
				} else {
					var kbps = document.createElement('span');
					kbps.setAttribute('class', 'lvcontrols__kbps');
					(0, _textContent2.default)(encoding, e.videoHeight + 'p');
					(0, _textContent2.default)(kbps, e.videoKbps + e.audioKbps + 'Kbps');
					encoding.insertBefore(kbps, encoding.firstChild);
					bitrate = e.videoKbps + e.audioKbps;

					if (chosenLevel !== null && typeof k !== 'undefined' && k === chosenLevel) {
						cn += ' lvcontrols__quality--selected';
					}
					if (currentLevel !== null && typeof k !== 'undefined' && k === currentLevel) {
						cn += ' lvcontrols__quality--current-level';
					}
					if (nextLevel !== null && typeof k !== 'undefined' && k === nextLevel) {
						cn += ' lvcontrols__quality--next-level';
					}
				}

				encoding.setAttribute('class', cn);
				encoding.setAttribute('data-location', e.location);
				encoding.addEventListener('click', function () {
					_this2.livelyPlayer.bitrate = bitrate;
					_this2.render();
				});

				_this2.qualitiesEl.appendChild(encoding);
				_this2.encodings.push(encoding);
			};

			while (this.qualitiesEl.firstChild) {
				this.qualitiesEl.removeChild(this.qualitiesEl);
			}
			if (this.mediaData.auto) {
				appendEncoding({
					location: this.mediaData.manifest,
					videoKbps: true
				});
			}

			this.mediaData.encodings.reverse().forEach(appendEncoding);
		}
	}, {
		key: 'chosenLevel',
		get: function get() {
			if (!this.mediaData || !this.mediaData.encodings) {
				return null;
			}

			if (!this.livelyPlayer.chosenLevel) {
				return this.livelyPlayer.chosenLevel;
			}

			return this.mediaData.encodings.length - this.livelyPlayer.chosenLevel;
		}
	}, {
		key: 'currentLevel',
		get: function get() {
			if (!this.mediaData || !this.mediaData.encodings) {
				return null;
			}

			if (!this.livelyPlayer.currentLevel) {
				return this.livelyPlayer.currentLevel;
			}

			return this.mediaData.encodings.length - this.livelyPlayer.currentLevel;
		}
	}, {
		key: 'nextLevel',
		get: function get() {
			if (!this.mediaData || !this.mediaData.encodings) {
				return null;
			}
			if (!this.livelyPlayer.nextLevel) {
				return this.livelyPlayer.nextLevel;
			}
			return this.mediaData.encodings.length - this.livelyPlayer.nextLevel;
		}
	}]);

	return QualitySelector;
}(_events2.default);

exports.default = QualitySelector;
},{"events":54,"text-content":62}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _detect = require('@livelyvideo/player-core/lib/detect');

var _detect2 = _interopRequireDefault(_detect);

var _events3 = require('@livelyvideo/player-core/lib/events');

var _events4 = _interopRequireDefault(_events3);

var _lodash = require('lodash.throttle');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ScreenInteraction = function (_EventEmitter) {
	_inherits(ScreenInteraction, _EventEmitter);

	function ScreenInteraction(targetEl, limit) {
		_classCallCheck(this, ScreenInteraction);

		var _this = _possibleConstructorReturn(this, (ScreenInteraction.__proto__ || Object.getPrototypeOf(ScreenInteraction)).call(this));

		_this.targetEl = targetEl;
		_this.limit = limit || 500;
		_this.mobileControls = _detect2.default.any();

		_this.userInteraction = null;
		_this.userInteractionTimeout = null;
		_this.disableReset = null;

		_this.throttledSetUserInteraction = (0, _lodash2.default)(_this.setUserInteraction.bind(_this), _this.limit, { leading: true, trailing: false });
		_this.handleEvents();
		return _this;
	}

	/**
  * Binds touch and mouse events.
  * @return {void}
  */


	_createClass(ScreenInteraction, [{
		key: 'handleEvents',
		value: function handleEvents() {
			var _this2 = this;

			if (this.mobileControls) {
				// Show controls onload
				this.setUserInteraction();
				this.targetEl.addEventListener('touchstart', function () {
					_this2.forceInteraction();
				});
				this.targetEl.addEventListener('touchend', function () {
					_this2.forceInteractionEnd();
				});
				this.targetEl.addEventListener('touchcancel', function () {
					_this2.forceInteractionEnd();
				});
				return;
			}

			this.targetEl.addEventListener('mouseover', function (e) {
				_this2.resetUserInteraction();
				_this2.throttledSetUserInteraction(e);
			});
			this.targetEl.addEventListener('mousedown', function () {
				_this2.forceInteraction();
			});
			this.targetEl.addEventListener('mouseup', function () {
				_this2.forceInteractionEnd();
			});
			this.targetEl.addEventListener('mouseout', function () {
				_this2.forceInteractionEnd();
			});
		}
	}, {
		key: 'forceInteraction',
		value: function forceInteraction() {
			this.disableReset = true;
			clearTimeout(this.userInteractionTimeout);
			this.setUserInteraction();
		}
	}, {
		key: 'lockOpen',
		value: function lockOpen() {
			this.lockedOpen = true;
			clearTimeout(this.userInteractionTimeout);
		}
	}, {
		key: 'releaseLockOpen',
		value: function releaseLockOpen() {
			this.lockedOpen = false;
			this.resetUserInteraction();
		}
	}, {
		key: 'forceInteractionEnd',
		value: function forceInteractionEnd() {
			this.disableReset = false;
			this.setUserInteraction();
		}
	}, {
		key: 'setUserInteraction',
		value: function setUserInteraction() {
			if (!this.userInteraction) {
				this.userInteraction = true;
				this.emit(_events4.default.USER_ACTIVE);
			}

			if (!this.disableReset) {
				this.resetUserInteraction();
			}
		}
	}, {
		key: 'resetUserInteraction',
		value: function resetUserInteraction() {
			var _this3 = this;

			clearTimeout(this.userInteractionTimeout);
			this.userInteractionTimeout = setTimeout(function () {
				if (_this3.lockedOpen) {
					return;
				}
				_this3.userInteraction = false;
				_this3.emit(_events4.default.USER_IDLE);
			}, 2000);
		}
	}, {
		key: 'destroy',
		value: function destroy() {
			if (this.mobileControls) {
				this.targetEl.removeEventListener('touchstart', this.forceInteraction.bind(this));
				this.targetEl.removeEventListener('touchend', this.forceInteractionEnd.bind(this));
				this.targetEl.removeEventListener('touchcancel', this.forceInteractionEnd.bind(this));
				return;
			}

			this.targetEl.removeEventListener('mouseover', this.throttledSetUserInteraction.bind(this));
			this.targetEl.removeEventListener('mousedown', this.forceInteraction.bind(this));
			this.targetEl.removeEventListener('mouseup', this.forceInteractionEnd.bind(this));
			this.targetEl.removeEventListener('mouseout', this.forceInteractionEnd.bind(this));
		}
	}]);

	return ScreenInteraction;
}(_events2.default);

exports.default = ScreenInteraction;
},{"@livelyvideo/player-core/lib/detect":18,"@livelyvideo/player-core/lib/events":20,"events":54,"lodash.throttle":59}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _getElPosition = require('../get-el-position');

var _getElPosition2 = _interopRequireDefault(_getElPosition);

var _getPointerPosition = require('../get-pointer-position');

var _getPointerPosition2 = _interopRequireDefault(_getPointerPosition);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Volume = function (_EventEmitter) {
	_inherits(Volume, _EventEmitter);

	function Volume(controls) {
		_classCallCheck(this, Volume);

		var _this = _possibleConstructorReturn(this, (Volume.__proto__ || Object.getPrototypeOf(Volume)).call(this));

		_this.controls = controls;
		_this.livelyPlayer = controls.livelyPlayer;
		_this.bar = controls.bar;

		_this.el = document.createElement('div');
		_this.indicatorEl = document.createElement('div');
		_this.indicatorEl.setAttribute('title', _this.controls.localize('Mute'));
		_this.sliderEl = document.createElement('div');
		_this.sliderValueEl = document.createElement('div');
		_this.showingSlider = false;
		_this.hideSlider();
		_this.indicatorEl.setAttribute('class', 'lvcontrols__volume-indicator');
		_this.sliderValueEl.setAttribute('class', 'lvcontrols__volume-slider-value');
		_this.sliderEl.appendChild(_this.sliderValueEl);

		_this.setMutedClass();
		_this.indicatorEl.addEventListener('click', function (e) {
			_this.toggleMuted(e);
		});
		_this.indicatorEl.addEventListener('touch', function (e) {
			_this.toggleMuted(e);
		});

		_this.el.addEventListener('mouseover', function () {
			_this.showingSlider = true;
			_this.showSlider();
		});

		_this.el.addEventListener('mouseout', function () {
			_this.showingSlider = false;
			_this.hideSlider();
		});

		_this.sliderEl.addEventListener('click', function (e) {
			_this.clickVolume(e);
		});
		_this.sliderEl.addEventListener('mousedown', function (e) {
			_this.startDrag(e);
		});

		_this.el.appendChild(_this.indicatorEl);
		_this.el.appendChild(_this.sliderEl);
		_this.el.setAttribute('class', 'lvcontrols__volume-bar');
		_this.bar.appendChild(_this.el);

		_this.livelyPlayer.on('mute', function (e) {
			_this.setMutedClass(e);
		});
		_this.livelyPlayer.on('unmute', function (e) {
			_this.setMutedClass(e);
		});
		_this.livelyPlayer.on('volume', function (e) {
			_this.updateVolume(e);
		});
		_this.livelyPlayer.on('play', function (e) {
			_this.setMutedClass(e);
		});
		_this.updateVolume();
		return _this;
	}

	/**
  * update the volume
  * @return {void}
  */


	_createClass(Volume, [{
		key: 'updateVolume',
		value: function updateVolume() {
			this.setMutedClass();
			this.setVolume();
		}

		/**
   * sets the proper muted class based on state
   * @return {void}
   */

	}, {
		key: 'setMutedClass',
		value: function setMutedClass() {
			var k = this.livelyPlayer.muted ? 'lvcontrols__volume-indicator--muted' : 'lvcontrols__volume-indicator--unmuted';
			var v = this.livelyPlayer.volume * 100;
			var m = '';

			// Class modifier for volume
			if (!this.livelyPlayer.muted) {
				if (v === 0) {
					m = 'lvcontrols__volume-indicator--off';
				} else {
					m = this.livelyPlayer.volume * 100 > 50 ? 'lvcontrols__volume-indicator--high' : 'lvcontrols__volume-indicator--low';
				}
			}

			this.indicatorEl.setAttribute('class', 'lvcontrols__volume-indicator ' + k + ' ' + m);

			var title = this.livelyPlayer.muted ? this.controls.localize('Unmute') : this.controls.localize('Mute');
			this.indicatorEl.setAttribute('title', title);
		}

		/**
   * starts the drag event listeners
   * @return {void}
   */

	}, {
		key: 'startDrag',
		value: function startDrag() {
			this.dragging = true;
			document.addEventListener('mousemove', this.calculateVolume.bind(this));
			document.addEventListener('mouseup', this.stopDrag.bind(this));
			document.addEventListener('mouseleave', this.stopDrag.bind(this));
		}

		/**
   * stop the drag event listeenrs
   * @return {void}
   */

	}, {
		key: 'stopDrag',
		value: function stopDrag() {
			this.dragging = false;
			this.hideSlider();
			document.removeEventListener('mouseup', this.stopDrag.bind(this));
			document.removeEventListener('mouseleave', this.stopDrag.bind(this));
			document.removeEventListener('mousemove', this.calculateVolume.bind(this));
		}

		/**
   * calculates volume based on cursors position relative to sliders position
   * @param  {object} e event
   * @return {void}
   */

	}, {
		key: 'calculateVolume',
		value: function calculateVolume(e) {
			if (!this.dragging) {
				return;
			}

			var v = Math.floor((0, _getPointerPosition2.default)(e).x - (0, _getElPosition2.default)(this.sliderEl).left) / 100;
			v = Math.max(v, 0);
			v = Math.min(v, 1);
			this.livelyPlayer.volume = v;
		}

		/**
   * sets the volume at cursor position
   * @param  {object} e event
   * @return {void}
   */

	}, {
		key: 'clickVolume',
		value: function clickVolume(e) {
			this.dragging = true;
			this.calculateVolume(e);
			this.dragging = false;
		}

		/**
   * sets the volume
   * @return {void}
   */

	}, {
		key: 'setVolume',
		value: function setVolume() {
			this.sliderValueEl.style.width = Math.floor(this.livelyPlayer.volume * 100) + '%';
		}

		/**
   * toggles muted state
   * @return {void}
   */

	}, {
		key: 'toggleMuted',
		value: function toggleMuted() {
			if (this.livelyPlayer.muted) {
				this.livelyPlayer.unmute();
			} else {
				this.livelyPlayer.mute();
			}
		}

		/**
   * displays the slider bar
   * @return {void}
   */

	}, {
		key: 'showSlider',
		value: function showSlider() {
			this.sliderEl.setAttribute('class', 'lvcontrols__volume-slider lvcontrols__volume-slider--interacting');
		}

		/**
   * hides the slider bar
   * @return {void}
   */

	}, {
		key: 'hideSlider',
		value: function hideSlider() {
			if (this.dragging || this.showingSlider) {
				return;
			}
			this.sliderEl.setAttribute('class', 'lvcontrols__volume-slider ');
		}

		/**
   * destroys the volume button
   * @return {void}
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			this.el.remove();
			this.indicatorEl.remove();
			this.sliderEl.remove();
			this.sliderValueEl.remove();
			this.livelyPlayer.removeListener('mute', this.setMutedClass.bind(this));
			this.livelyPlayer.removeListener('unmute', this.setMutedClass.bind(this));
			this.livelyPlayer.removeListener('volume', this.updateVolume.bind(this));
			this.livelyPlayer.removeListener('play', this.setMutedClass.bind(this));
		}
	}]);

	return Volume;
}(_events2.default);

exports.default = Volume;
},{"../get-el-position":5,"../get-pointer-position":6,"events":54}],17:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _detect = require('./detect');

var _detect2 = _interopRequireDefault(_detect);

var _errors = require('./errors');

var _errors2 = _interopRequireDefault(_errors);

var _events3 = require('./events');

var _events4 = _interopRequireDefault(_events3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BACK_OFF = [0, 1000, 2000, 5000, 25000];

/**
 * @class Base driver for all classes
 */

var BaseDriver = function (_EventEmitter) {
	_inherits(BaseDriver, _EventEmitter);

	/**
  * @param {object} livelyPlayer				Lively video object
  * @param {object} mediaLoader				media loader object
  * @param {object[]} [options]
  * @param {number} [options[].bitrate]	attempts to find and use the bitrate nearest to this value
  * @param {bool} [options[].adaptive]		defaults to true if bitrate is null, false if bitrate is supplied.	if true, switches bitrate based on bandwidth
  * @param {number} [options[].volume]		[0.75] 0-1 volume
  * @param {number} [options[].maxBufferLength]	[30s]
  * @param {number} [options[]. maxBufferSize]	[60mb]
  * @param {bool} [options[].muted] 			whether or not the driver is muted
  * @param {bool} [options[].debug]			[false] enables debug logging
  * @return {void}
  */
	function BaseDriver(livelyPlayer, mediaLoader, options) {
		_classCallCheck(this, BaseDriver);

		var _this = _possibleConstructorReturn(this, (BaseDriver.__proto__ || Object.getPrototypeOf(BaseDriver)).call(this));

		_this.resetCounts();
		_this.errors = {};
		_this.livelyPlayer = livelyPlayer;
		_this.mediaLoader = mediaLoader;
		_this.options = options;
		_this.onceHandlerLock = false;
		return _this;
	}

	_createClass(BaseDriver, [{
		key: 'resetCounts',
		value: function resetCounts() {
			this.fragCounts = 0;
			this.fragSize = 0;
			this.fragDuration = 0;
			this.fragDownloadTime = 0;
			this.fragMaxTime = 0;
			this.fragMinTime = 0;
			this.bufferOverflowCount = 0;
			this.bufferUnderflowCount = 0;
			this.upshift = 0;
			this.downshift = 0;
			this.lastProgress = 0;
			this.currentErrorCount = 0;
			this.recentErrorCount = 0;
			this.restartCount = 0;
		}

		/**
   * Gets default options
   * @return {Object}
   */

	}, {
		key: 'pickEncoding',


		/**
   * @param {number} [bitrate] bitrate, defaults to options.bitrate || options.estimatedKbps
   * @return {object} encoding object
   */
		value: function pickEncoding(bitrate) {
			if (bitrate) {
				this.options.bitrate = bitrate;
			}

			if (!this.options.bitrate) {
				return null;
			}

			var encodings = this.data.encodings;

			if (!encodings.length) {
				return undefined;
			}

			return encodings[this.chosenLevel];
		}

		/** returns the media loader data
   * @param {String} [format]
   * @return {string}
   */

	}, {
		key: 'reloadAndRestart',
		value: function reloadAndRestart() {
			var _this2 = this;

			if (this.lockReload) {
				return;
			}
			this.lockReload = true;
			this.mediaLoader.load(function () {
				if (_this2.mediaLoader.currentState === _events4.default.ONLINE) {
					_this2.restart(function () {
						_this2.lockReload = false;
					});
				} else {
					_this2.lockReload = false;
					_this2.stop();
				}
			});
		}

		/**
   * Returns the chosen bitrate level.  Sometimes this is the same as the current bitrate level.  null if auto, undefined if unknown
   * @return {number}
   */

	}, {
		key: 'whenReady',


		/**
   * Does something whenReady, respects once lock.
   * TODO: if necessary refactor to pass in a lock or a sig or something
   * @param {function} [cb] called after play
   * @return {void}
   */
		value: function whenReady(cb) {
			var _this3 = this;

			if (this.onceHandlerLock) {
				return;
			}

			var m = this.manifest;
			if (!m) {
				if (this.mediaLoader.currentState === _events4.default.ONLINE) {
					this.emit(_events4.default.ERROR, _errors2.default.DRIVER_NOT_SUPPORTED);
					return;
				}

				this.onceHandlerLock = true;
				this.mediaLoader.once(_events4.default.MANIFEST, function () {
					_this3.onceHandlerLock = false;
					_this3.whenReady(cb);
				});
				return;
			}

			if (cb) {
				cb();
			}
		}

		/**
   * sets an option after construction
   */

	}, {
		key: 'setOption',
		value: function setOption(k, v) {
			this.options[k] = v;
			switch (k) {
				case 'posterURI':
					if (this.el) {
						this.el.setAttribute('poster', v);
					}
					break;
				default:
					break;
			}
		}
	}, {
		key: 'elementPlay',
		value: function elementPlay() {
			if (!this.el || !this.el.play) {
				return;
			}

			var p = this.el.play();
			if (typeof Promise !== 'undefined' && p instanceof Promise) {
				p.catch(function () {
					// ignore
				});
			}
		}

		// attaches progress and timeupdate listeners

	}, {
		key: 'attachListeners',
		value: function attachListeners() {
			var _this4 = this;

			this.el.onprogress = function () {
				_this4.emitProgress();
			};
			this.el.ontimeupdate = function () {
				_this4.fragCounts++;
				_this4.emitTimeupdate();
			};
		}

		/**
   * Play the video
   * @param {function} [cb] called after play
   * @return {void}
   */

	}, {
		key: 'play',
		value: function play(inputCb) {
			var _this5 = this;

			var cb = inputCb || function noop() {};

			if (this.mediaLoader.vod && this.manifest && this.manifest === this.el.getAttribute('src')) {
				this.elementPlay();
				cb(!this.el.paused);
				return;
			}

			if (_detect2.default.any()) {
				this.elementPlay();
			}

			this.whenReady(function () {
				var m = _this5.manifest;

				_logger2.default.setPlayer(_this5.mediaLoader.host, _this5.mediaLoader.publicId, _this5.format, m, _this5);

				var attachHandlers = function attachHandlers() {
					_this5.el.onprogress = function () {
						_this5.emitProgress();
					};
					_this5.el.ontimeupdate = function () {
						_this5.fragCounts++;
						_this5.emitTimeupdate();
					};
				};

				var setSrc = function setSrc() {
					if (!_detect2.default.iOS() || _this5.el.getAttribute('src') !== m) {
						_this5.el.setAttribute('src', m);
					}
				};

				setSrc();
				var p = _this5.el.play();
				if (!p || !p.then) {
					attachHandlers();
					process.nextTick(function () {
						if (cb) {
							cb(!_this5.el.paused);
						}
					});
					return;
				}

				p.then(function () {
					attachHandlers();
					if (cb) {
						cb(true);
					}
				}).catch(function (e) {
					_logger2.default.debug('video element play error caught', e.message);
					_this5.emit('video-el-error', { err: e });
					if (cb) {
						cb(false);
					}
				});
			});
		}

		/**
   * stops playback
   * @return {void}
   */

	}, {
		key: 'stop',
		value: function stop() {
			this.el.setAttribute('src', '');
		}

		/**
   * destroys the player
   * @return {void}
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			this.destroyed = true;
			this.el.remove();
			this.stop();
		}

		/**
   * Pause through the video tag
   * @return {void}
   */

	}, {
		key: 'pause',
		value: function pause() {
			this.el.pause();
		}

		/**
   * Unmute through the video tag
   * @return {void}
   */

	}, {
		key: 'unmute',
		value: function unmute() {
			this.el.muted = false;
			return this.el.muted;
		}

		/**
   * Mute through the video tag
   * @return {void}
   */

	}, {
		key: 'mute',
		value: function mute() {
			this.el.muted = true;
			return this.el.muted;
		}

		/**
   * @return {boolean} true if supports fullscreen
   */

	}, {
		key: 'supportsFullscreen',
		value: function supportsFullscreen() {
			var v = document.createElement('video');
			return !!(document.fullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled || document.webkitSupportsFullscreen || document.webkitFullscreenEnabled || v.webkitRequestFullScreen || v.webkitEnterFullScreen);
		}
	}, {
		key: 'restartTimeout',
		value: function restartTimeout(cb) {
			var _this6 = this;

			setTimeout(function () {
				if (_this6.destroyed) {
					return;
				}
				_this6.stop();
				_this6.play(function () {
					for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
						args[_key] = arguments[_key];
					}

					_this6.lockRestart = false;
					if (cb) {
						cb.apply(cb, args);
					}
				});
			}, BACK_OFF[Math.min(this.restartCount, BACK_OFF.length - 1)]);
		}

		/**
   * restarts the driver
   * @return {void}
   */

	}, {
		key: 'restart',
		value: function restart(cb) {
			var _this7 = this;

			if (this.lockRestart) {
				return;
			}
			this.lockRestart = true;
			this.currentErrorCount = 0;
			this.recentErrorCount = 0;
			this.restartCount++;

			clearTimeout(this.clearRestartCount);
			this.clearRestartCount = setTimeout(function () {
				_this7.restartCount = 0;
			}, BACK_OFF[BACK_OFF.length - 1] * 2);

			this.emit(_events4.default.RESTART_DRIVER, {
				timeout: BACK_OFF[Math.min(this.restartCount, BACK_OFF.length - 1)]
			});

			this.restartTimeout(cb);
		}

		/**
   * @param {object} [data]
   * @return {void}
   */

	}, {
		key: 'checkRestart',
		value: function checkRestart(inputData) {
			var _this8 = this;

			// In cases where a machine went to sleep and came back online,
			// the player is in a state where it constantly emits the buffer-stalled
			// error.	The only way I know how to reinstantiate the player is to
			// watch for errors within a timeframe
			var data = inputData;
			this.recentErrorCount++;
			setTimeout(function () {
				_this8.recentErrorCount--;
				_this8.recentErrorCount = Math.max(_this8.recentErrorCount, 0);
			}, 10000);
			if (this.recentErrorCount >= this.options.recoverErrorCount) {
				data.fatal = true;
			}

			if (this.currentErrorCount >= this.options.recoverErrorCount) {
				data.fatal = true;
			}

			if (data.fatal && !this.mediaLoader.vod) {
				this.restart();
			}
		}

		// helper function to handle errors

	}, {
		key: 'handleError',
		value: function handleError(key, type, data) {
			var k = type + ':' + data.details;

			if (!this.errors[k]) {
				this.errors[k] = 0;
			}

			this.errors[k]++;

			for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
				args[_key2 - 3] = arguments[_key2];
			}

			this.emit.apply(this, [key, type, data].concat(args));
		}
	}, {
		key: 'playOrigin',
		value: function playOrigin(cb) {
			this.options.origin = true;
			this.restart(cb);
		}

		/**
   * emit playback progress
   */

	}, {
		key: 'emitProgress',
		value: function emitProgress() {
			this.lastProgress = window.performance.now();
			this.emit(_events4.default.MEDIA_PROGRESS);
		}
	}, {
		key: 'emitTimeupdate',
		value: function emitTimeupdate() {
			this.emit(_events4.default.MEDIA_TIMEUPDATE);
		}
	}, {
		key: 'format',
		get: function get() {
			return this.constructor.format;
		}
	}, {
		key: 'driver',
		get: function get() {
			return this.constructor.driver;
		}
	}, {
		key: 'duration',
		get: function get() {
			return this.el && this.el.duration ? this.el.duration : Infinity;
		}

		/**
   * returns a list of buffer times
   * @return {array}
   */

	}, {
		key: 'bufferTimes',
		get: function get() {
			var times = [];
			var range = this.el.buffered.length;
			for (var i = 0; i < range; i++) {
				times.push([this.el.buffered.start(i), this.el.buffered.end(i)]);
			}
			return times;
		}

		/**
   * returns current volume
   * @return {number} volume
   */

	}, {
		key: 'volume',
		get: function get() {
			return this.el.volume;
		}

		/**
   * Set the volume through the video tag
   * @param {number} [volume]
   * @return {number} volume
   */
		,
		set: function set(n) {
			if (typeof n !== 'undefined') {
				this.el.volume = n;
			}

			if (this.el.muted && n && n > 0) {
				this.unmute();
			}

			return this.el.volume;
		}

		/**
   * Supports desktop autoplay
   * @return {boolean}
   */

	}, {
		key: 'supportsAutoplay',
		get: function get() {
			return !_detect2.default.any();
		}

		/**
   * Supports mobile autoplay
   * @return {boolean}
   */

	}, {
		key: 'supportsMobileAutoplay',
		get: function get() {
			return false;
		}

		/**
   * Supports volume controller
   * @return {boolean}
   */

	}, {
		key: 'supportsVolume',
		get: function get() {
			return true;
		}
	}, {
		key: 'origin',
		get: function get() {
			var origin = this.data.origin;

			if (!origin) {
				if (!this.data || !this.data.encodings.length) {
					return null;
				}

				var d = this.data;
				return d.encodings[d.encodings.length - 1];
			}

			return origin;
		}

		/**
   * gets the origin location
   * @return {string}
   */

	}, {
		key: 'originLocation',
		get: function get() {
			var o = this.origin;

			if (!o) {
				return null;
			}

			return o.location;
		}
	}, {
		key: 'data',
		get: function get() {
			var d = this.mediaLoader.get(this.format);
			d.auto = true;
			return d;
		}
	}, {
		key: 'chosenLevel',
		get: function get() {
			if (!this.options.bitrate) {
				return null;
			}

			var encodings = this.data.encodings;
			if (!encodings.length) {
				return undefined;
			}

			// Pick the encoding based on estimated encodings
			var i = void 0;
			for (i = 0; i < encodings.length; i++) {
				if (!encodings[i].videoWidth) {
					continue;
				}
				if (encodings[i].videoKbps + encodings[i].audioKbps > this.options.bitrate) {
					break;
				}
			}
			i = Math.max(i - 1, 0);
			return i;
		}

		/**
   * Returns the current bitrate level.  null if unknown
   * @return {number}
   */

	}, {
		key: 'currentLevel',
		get: function get() {
			return this.chosenLevel;
		}

		/**
   * Returns the next bitrate level.  null if unknown
   * @return {number}
   */

	}, {
		key: 'nextLevel',
		get: function get() {
			return null;
		}

		/** returns the manifest string
   * @return {string}
   */

	}, {
		key: 'manifest',
		get: function get() {
			if (this.options.origin) {
				var l = this.originLocation;
				if (!l) {
					this.options.origin = false;
					return this.manifest();
				}
				return l;
			}

			var d = this.data;

			if (!d.encodings.length) {
				var o = this.originLocation;
				if (o) {
					this.options.origin = true;
				}
				return o;
			}

			var e = this.pickEncoding();
			var uri = void 0;

			if (e) {
				uri = e.location;
			} else {
				uri = d.manifest;
			}

			if (!uri) {
				return null;
			}

			var separator = uri.indexOf('?') === -1 ? '?' : '&';
			if (this.options.preset === null) {
				// nothing, simpler logic
			} else if (this.options.preset) {
				uri += separator + 'preset=' + this.options.preset;
			} else if (!_detect2.default.any()) {
				uri += separator + 'preset=desktop';
			}

			return uri;
		}

		/**
   * gets video current time
   * @return {number} seconds
   */

	}, {
		key: 'currentTime',
		get: function get() {
			return this.el.currentTime;
		}

		/**
   * seeks to the current time
   * @param {number} seconds
   */
		,
		set: function set(offset) {
			this.el.currentTime = offset;
		}

		/**
   * Returns t/f if is stopped
   * @return {boolean}
   */

	}, {
		key: 'stopped',
		get: function get() {
			return !!this.el.getAttribute('src', '');
		}

		/**
   * @param {number} bitrate
   * @return {void}
   */

	}, {
		key: 'bitrate',
		set: function set(bitrate) {
			var _this9 = this;

			var ct = this.el.currentTime;
			this.stop();
			this.options.bitrate = bitrate;

			if (this.mediaLoader.vod) {
				this.el.onloadedmetadata = function () {
					_this9.el.onloadedmetadata = null;
					_this9.el.currentTime = ct;
				};
				this.el.oncanplay = function () {
					_this9.el.oncanplay = null;
					if (_this9.el.currentTime >= ct) {
						return;
					}
					_this9.el.currentTime = ct;
				};
			}
			this.play(function () {
				_this9.emit(_events4.default.BITRATE_SWITCH);
			});
		}

		/**
   * t/f if the video is muted
   * @returns {boolean}
   */

	}, {
		key: 'muted',
		get: function get() {
			return !!this.el.muted;
		}

		/**
   * Returns if paused or not
   * @return {boolean}
   */

	}, {
		key: 'paused',
		get: function get() {
			return this.el.paused;
		}

		/**
   * gets the details
   * @return {object} Details contract
   */

	}, {
		key: 'details',
		get: function get() {
			return {
				bufferOverflowCount: this.bufferOverflowCount || 0,
				bufferUnderflowCount: this.bufferUnderflowCount || 0,
				downshift: this.downshift || 0,
				errors: this.errors || {},
				muted: this.el && this.el.muted,
				segments: this.fragCounts || 0,
				segmentsSize: this.fragSize || 0,
				segmentsDuration: this.fragDuration || 0,
				segmentTotalDownloadTime: this.fragDownloadTime || 0,
				segMaxTime: this.fragMaxTime || 0,
				segMinTime: this.fragMinTime || 0,
				upshift: this.upshift || 0,
				volume: this.el && this.el.volume ? this.el.volume : 0
			};
		}
	}], [{
		key: 'isSupported',


		/**
   * [Abstract]
   * @return {boolean}
   */
		value: function isSupported() {
			_logger2.default.error('an abstract method has been called');
		}
	}, {
		key: 'defaultOptions',
		get: function get() {
			return {
				adaptive: null,
				bitrate: null,
				muted: false,
				volume: 0.75
			};
		}
	}]);

	return BaseDriver;
}(_events2.default);

exports.default = BaseDriver;
}).call(this,require('_process'))
},{"./detect":18,"./errors":19,"./events":20,"./logger":23,"_process":53,"events":54}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * Inferior detection method for small size
 * Consider using https://github.com/hgoebl/mobile-detect.js
 */
var cache = {};

function wrap(key, uaTest) {
	return function () {
		if (typeof cache[key] === 'undefined') {
			cache[key] = uaTest();
		}
		return cache[key];
	};
}

function getChromeVersion() {
	var raw = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
	return raw ? parseInt(raw[2], 10) : false;
}

function getIOSversion() {
	if (/iP(hone|od|ad)/.test(navigator.platform)) {
		var v = navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
		return [parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)];
	}
	return undefined;
}

var detect = {
	chromeGreater50: wrap('chromeGreater50', function () {
		if (!detect.chrome()) {
			return false;
		}

		return getChromeVersion() > 49;
	}),
	modernChrome: wrap('modernChrome', function () {
		if (!detect.chrome()) {
			return false;
		}

		return getChromeVersion() > 52;
	}),
	winChrome51: wrap('winChrome51', function () {
		if (!detect.windowsDesktop()) {
			return false;
		}

		if (!detect.chrome()) {
			return false;
		}

		return getChromeVersion() > 51;
	}),

	iPhone10: wrap('iPhone10', function () {
		if (!detect.iPhone()) {
			return false;
		}

		var uaParts = navigator.userAgent.split(/\s*[;)(]\s*/);
		var versionPart = void 0;
		var chromePart = void 0;

		for (var i = 0; i < uaParts.length; i++) {
			if (uaParts[i].slice(0, 7) === 'Version') {
				versionPart = uaParts[i];
				break;
			}
			if (uaParts.length > 0 && uaParts[i] === 'OS' && uaParts[i - 1] === 'iPhone') {
				chromePart = uaParts[i + 1];
				break;
			}
		}

		if (!versionPart && !chromePart) {
			return false;
		}

		var versionParts = chromePart ? chromePart.split('_') : versionPart.split('/');
		if (parseFloat(versionParts[1]) < 11) {
			return true;
		}
		return false;
	}),

	iPhone9: wrap('iPhone9', function () {
		if (!detect.iPhone()) {
			return false;
		}

		var version = getIOSversion();
		return version && version[0] < 10;
	}),

	modernMobile: wrap('modernMobile', function () {
		if (!detect.any()) {
			return false;
		}

		if (detect.android() && detect.modernChrome()) {
			return true;
		}

		if (detect.iPhone10()) {
			return true;
		}

		return false;
	}),

	windowsDesktop: wrap('windowsDesktop', function () {
		return (/Windows/i.test(navigator.userAgent)
		);
	}),
	chrome: wrap('chrome', function () {
		return (/Chrome/i.test(navigator.userAgent)
		);
	}),
	firefox: wrap('firefox', function () {
		return (/Firefox/i.test(navigator.userAgent)
		);
	}),
	ie: wrap('ie', function () {
		return (/Trident/i.test(navigator.userAgent)
		);
	}),
	edge: wrap('edge', function () {
		return (/Edge\/\d+/.test(navigator.userAgent)
		);
	}),
	safari: wrap('safari', function () {
		return (/Safari/i.test(navigator.userAgent)
		);
	}),
	windows: wrap('windows', function () {
		return (/IEMobile/i.test(navigator.userAgent)
		);
	}),
	android: wrap('android', function () {
		return (/Android/i.test(navigator.userAgent)
		);
	}),
	blackBerry: wrap('blackBerry', function () {
		return (/BlackBerry/i.test(navigator.userAgent)
		);
	}),
	iOS: wrap('iOS', function () {
		return (/iPhone|iPad|iPod/i.test(navigator.userAgent)
		);
	}),
	iPhone: wrap('iPhone', function () {
		return (/iPhone/i.test(navigator.userAgent)
		);
	}),
	any: wrap('any', function () {
		return detect.android() || detect.blackBerry() || detect.iOS() || detect.windows();
	})
};

exports.default = detect;
},{}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
var ERRORS = {
	BAD_INPUT: 'bad-input',
	DRIVER_NOT_SUPPORTED: 'driver-not-supported',
	ELEMENT_REQUIRED: 'element-required',
	EMBED_SWF_FAILED: 'embedding-flash-swf-failed',
	GET_USER_MEDIA_FAILED: 'get-user-media-failed',
	HTTP_SERVER_UNEXPECTED_RESPONSE: 'http-server-unexpected-response',
	HTTP_SERVER_UNAUTHORIZED: 'http-server-unauthorized',
	HTTP_SERVER_FORBIDDEN: 'http-server-forbidden',
	HTTP_SERVER_INTERNAL_ERROR: 'http-server-internal-error',
	HTTP_SERVER_NOT_FOUND: 'http-server-not-found',
	MANIFEST: 'http-response',
	INVALID_CONTROLS: 'invalid-controls-parent',
	INVALID_MEDIA_URL: 'invalid-media-url',
	INVALID_POPOUT_URL: 'invalid-popout-url',
	INVALID_EL: 'invalid-element',
	WS_NETWORK_ERROR: 'websocket-network-error',
	NETWORK_ERROR: 'network-error',
	NO_DRIVERS: 'no-valid-drivers',
	PLAYBACK_ERROR: 'playback-error',
	UNKNOWN_DRIVER: 'unknown-driver',
	UNKNOWN_ERROR: 'unknown-error',
	UNRECOGNIZED_DRIVER: 'unrecognized-driver',
	USER_REQUIRED: 'user-required'
};

exports.default = ERRORS;
},{}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
var EVENTS = {
	EXIT_FULLSCREEN: 'exit-fullscreen',
	ENTER_FULLSCREEN: 'enter-fullscreen',
	ERROR: 'error',
	BITRATE_SWITCH: 'bitrate-switch',
	SELECT_DRIVER: 'select-driver',
	RESTART_DRIVER: 'restart-driver',
	MANIFEST: 'manifest',
	MEDIA_ENDED: 'ended',
	MEDIA_PLAY: 'play',
	MEDIA_STOP: 'stop',
	MEDIA_PAUSE: 'pause',
	MEDIA_STALL: 'stall',
	MEDIA_PROGRESS: 'progress',
	MEDIA_TIMEUPDATE: 'timeupdate',
	MEDIA_MUTE: 'mute',
	MEDIA_UNMUTE: 'unmute',
	MEDIA_VOLUME: 'volume',
	ONLINE: 'online',
	OFFLINE: 'offline',
	ESTIMATED_BW: 'estimated-bw',
	USER_ACTIVE: 'user-active',
	USER_IDLE: 'user-idle'
};

exports.default = EVENTS;
},{}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
function gcd(a, b) {
	return b === 0 ? a : gcd(b, a % b);
}

exports.default = gcd;
},{}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (options, defaultOptions) {
	var cloneOptions = options ? Object.create(options) : {};

	if (!defaultOptions) {
		return cloneOptions;
	}

	for (var p in defaultOptions) {
		if (typeof cloneOptions[p] === 'undefined') {
			cloneOptions[p] = defaultOptions[p];
		}
	}

	return cloneOptions;
};
},{}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Logging Interface
 * Supported log levels include [error, info, warn, timing]
 * Logs are sent in batch to {host}/player-log/{publicKey}/{sessionId}
 * Debugging and log throttle is controlled by {host}/player-log/debug
 *
 * @example <caption>Example logging</caption>
import logger from './logger';
logger.error('playback-error', {
  reason: 'driver-not-supported'
});
logger.info('something-happeend');
logger.warn('something-else-happeend');

<caption>Example timing</caption>
logger.timing('first-playback', {ms: 1000});
 * @type {Logger}
 */
var logger = new _logger2.default();

exports.default = logger;
},{"./logger":24}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // import xhr from 'xhr';


var _uuidv = require('../uuidv4');

var _uuidv2 = _interopRequireDefault(_uuidv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SupportedLevels = ['debug', 'error', 'info', 'warn', 'timing', 'deprecated'];

/**
 * @class handles both console and xhr logging
 */

var Logger = function () {
	/**
  * @return {void}
  */
	function Logger() {
		_classCallCheck(this, Logger);

		this.sessionKey = (0, _uuidv2.default)();
		this.sessionQueryString = 'sessionId=' + this.sessionKey;
		this.host = null;

		this.setLevels();

		this.publicKey = null;
		this.format = null;
		this.encoding = null;

		this.disable();
		this.enable();
		this.logEntries = [];
	}

	_createClass(Logger, [{
		key: 'setLevels',
		value: function setLevels(inputLevels) {
			var levels = inputLevels || {};
			this.levels = {
				debug: levels.debug || false,
				error: levels.error || 1,
				warn: levels.warn || 1,
				info: levels.info || 1,
				timing: levels.timing || 0
			};
		}

		/**
   * Sets the player data
   * @param {string} host
   * @param {string} publicKey
   * @param {string} format
   * @param {string} encoding
   * @param {function} driver
   * @return {void}
   */

	}, {
		key: 'setPlayer',
		value: function setPlayer(host, publicKey, format, encoding, driver) {
			this.host = host;
			this.publicKey = publicKey;
			this.format = format;
			this.encoding = encoding;
			this.driver = driver;
		}

		/**
   * @return {boolean}
   */

	}, {
		key: 'checkSet',
		value: function checkSet() {
			return !this.host || !this.publicKey || !this.format;
		}

		/**
   * determines whether the level is support
   * @param  {string} level log level
   * @return {bool} true if level is supported
   */

	}, {
		key: 'levelIsSupported',
		value: function levelIsSupported(level) {
			return SupportedLevels.indexOf(level) !== -1;
		}

		/**
   * generic log function
   * @param  {string} level info/warn/error
   * @return {void}
   */

	}, {
		key: 'log',
		value: function log(level) {
			var _writer;

			if (!this.levelIsSupported(level)) {
				this.log('error', 'unsupported log level', {
					level: level
				});
				return;
			}

			if (!this.levels[level]) {
				return;
			}

			if (!this.writer[level] || !this.writer[level].apply) {
				return;
			}

			for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				args[_key - 1] = arguments[_key];
			}

			(_writer = this.writer)[level].apply(_writer, args);

			if (this.apiLogging && this.host && this.publicKey) {
				this.pushBatch(args);
			}
		}

		/**
   * disables logs by overwriting the writer the noops
   * @return {void}
   */

	}, {
		key: 'disable',
		value: function disable() {
			this.writer = {};
			for (var i = 0; i < SupportedLevels.length; i++) {
				this.writer[SupportedLevels[i]] = function () {};
			}
		}

		/**
   * enables logs by overwriting the writer with console.logs unless impossible
   * @return {void}
   */

	}, {
		key: 'enable',
		value: function enable() {
			if (window.console) {
				this.writer = window.console;
				this.writer.timing = this.writer.info;
				this.writer.deprecated = this.writer.info;
			}
		}

		/**
   * helper function to join arguments together
   * @param  {string} level
   * @param  {object} args
   * @return {array
   */

	}, {
		key: 'argJoin',
		value: function argJoin(level, args) {
			var r = [level];
			for (var i = 0; i < args.length; i++) {
				r.push(args[i]);
			}
			return r;
		}

		/**
   * Public interface for debug logging.  Logs any arguments
   * @return {void}
   */

	}, {
		key: 'debug',
		value: function debug() {
			for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				args[_key2] = arguments[_key2];
			}

			this.log.apply(this, ['debug'].concat(args));
		}

		/**
   * Public interface for error logging.  Logs any arguments
   * @return {void}
   */

	}, {
		key: 'error',
		value: function error() {
			for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
				args[_key3] = arguments[_key3];
			}

			this.log.apply(this, ['error'].concat(args));
		}

		/**
   * Public interface for timing logging.  Logs any arguments
   * @return {void}
   */

	}, {
		key: 'timing',
		value: function timing() {
			for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
				args[_key4] = arguments[_key4];
			}

			this.log.apply(this, ['timing'].concat(args));
		}

		/**
   * Public interface for info logging.  Logs any arguments
   * @return {void}
   */

	}, {
		key: 'info',
		value: function info() {
			for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
				args[_key5] = arguments[_key5];
			}

			this.log.apply(this, ['info'].concat(args));
		}

		/**
   * Public interface for warn logging.  Logs any arguments
   * @return {void}
   */

	}, {
		key: 'warn',
		value: function warn() {
			for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
				args[_key6] = arguments[_key6];
			}

			this.log.apply(this, ['warn'].concat(args));
		}

		/**
   * Public interface for deprecated logging.  Logs any arguments
   * @return {void}
   */

	}, {
		key: 'deprecated',
		value: function deprecated() {
			for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
				args[_key7] = arguments[_key7];
			}

			this.log.apply(this, ['deprecated'].concat(args));
		}
	}]);

	return Logger;
}();

exports.default = Logger;
},{"../uuidv4":38}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _xhr = require('xhr');

var _xhr2 = _interopRequireDefault(_xhr);

var _errors = require('./errors');

var _errors2 = _interopRequireDefault(_errors);

var _events3 = require('./events');

var _events4 = _interopRequireDefault(_events3);

var _parseUrl = require('./parse-url');

var _parseUrl2 = _interopRequireDefault(_parseUrl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable no-param-reassign,arrow-body-style */


var HLS_SUPPORTED_AUDIO_CODECS = ['aac', 'mp3'];
var MEOW_SUPPORTED_AUDIO_CODECS = ['aac'];

/**
 * @class interacts with the api to fetch video data
 */

var MediaLoader = function (_EventEmitter) {
	_inherits(MediaLoader, _EventEmitter);

	/**
 * @param	{string} publicId Public id of the live element
 * @param	{object} options
 * @param	{number} [options[].pollingInterval] If null, will not pull
 * @param	{string} [options[].apiPrefix] [/live]
 * @param	{string} [options[].apiSuffix] [.json]
 * @return {void}
 */
	function MediaLoader(publicId, options) {
		_classCallCheck(this, MediaLoader);

		var _this = _possibleConstructorReturn(this, (MediaLoader.__proto__ || Object.getPrototypeOf(MediaLoader)).call(this));

		_this.currentState = _events4.default.OFFLINE;
		_this.formats = {};
		_this.pingUri = null;

		_this.options = options;
		_this.host = _this.options.host || window.location.protocol + '//' + window.location.host;

		_this.setPublicId(publicId);
		if (_this.publicId) {
			_this.options.pollingInterval = parseInt(_this.options.pollingInterval, 10);
			_this.options.unauthorizedPollingInterval = parseInt(_this.options.unauthorizedPollingInterval, 10);
			_this.options.unauthorizedRecoveryDuration = parseInt(_this.options.unauthorizedRecoveryDuration, 10);
		}

		_this.setUri(publicId);
		_this.shouldBePolling = false;
		return _this;
	}

	_createClass(MediaLoader, [{
		key: 'modifyFormats',
		value: function modifyFormats(formats) {
			for (var k in formats) {
				if (!formats[k].encodings || !formats[k].encodings.length) {
					continue;
				}

				if (k === 'mp4-ws' && formats[k].origin && MEOW_SUPPORTED_AUDIO_CODECS.indexOf(formats[k].origin.audioCodec) === -1) {
					formats[k].origin = null;
				} else if (k === 'mp4-hls' && formats[k].origin && HLS_SUPPORTED_AUDIO_CODECS.indexOf(formats[k].origin.audioCodec) === -1) {
					formats[k].origin = null;
				}
			}

			return formats;
		}

		/**
  	{
          "formats": {
                  "mp4-rtmp": {
                          "manifest": {{urlOfMasterManifestWhichIsDuplicatedBelow}},
                          "encodings": [
                                  {
                                          videoCodec: videoCodec,
                                          videoWidth: format.videoWidth,
                                          videoHeight: format.videoHeight,
                                          videoKbps: format.videoKbps,
                                          audioCodec: audioCodec,
                                          audioKbps: format.audioKbps,
                                          location: location
                                  },
                                  { ... }
                          ]
                  },
                  "mp4-hls": {
                          "manifest": {{urlOfMasterManifestWhichIsDuplicatedBelowInJson}},
                          "encodings": [
                                  {
                                          videoCodec: videoCodec,
                                          videoWidth: format.videoWidth,
                                          videoHeight: format.videoHeight,
                                          videoKbps: format.videoKbps,
                                          audioCodec: audioCodec,
                                          audioKbps: format.audioKbps,
                                          location: location
                                  },
                                  { ... }
                          ]
                  },
                  "mp4-dash":
                          "manifest": {{urlOfMasterManifestWhichIsDuplicatedBelowInJson}},
                          "encodings": [
                                  {
                                          videoCodec: videoCodec,
                                          videoWidth: format.videoWidth,
                                          videoHeight: format.videoHeight,
                                          videoKbps: format.videoKbps,
                                          audioCodec: audioCodec,
                                          audioKbps: format.audioKbps,
                                          location: location
                                  },
                                  { ... }
                          ]
                  },
                  "mjpeg-lodef" {
                          "manifest": {{urlOfMasterManifest}}
                  },
          }
  }
  	 * Loads the media data
   * @TODO Abort the polling requests when this begins.  Initialize them when it finishes
   * @param {string} [publicId] If null will use current publicId
   * @param {function} [cb]
   * @return {void}
   */

	}, {
		key: 'load',
		value: function load(publicId, cb) {
			var _this2 = this;

			if (this.manifest || this.vod) {
				this.emit(_events4.default.MANIFEST, this.currentState);
				if (cb) {
					cb();
				}
				return;
			}

			if (!publicId && !this.uri) {
				return;
			}

			if (typeof publicId !== 'string') {
				cb = publicId;
				publicId = null;
			} else if (publicId.slice(0, 7) === 'http://' || publicId.slice(0, 8) === 'https://') {
				this.options.mediaLoaderUri = publicId;
			}

			if (!this.setUri(publicId)) {
				// Set the uri based on the new public id
				// if it fails, stop
				if (cb) {
					cb(new Error(_errors2.default.INVALID_MEDIA_URL));
				}
				return;
			}

			(0, _xhr2.default)({
				method: 'GET',
				uri: this.uri,
				json: true,
				useXDR: true
			}, function (err, response, body) {
				var e = void 0;

				if (err) {
					e = new Error(_errors2.default.HTTP_SERVER_INTERNAL_ERROR);
				} else if (response.statusCode > 499) {
					e = new Error(_errors2.default.HTTP_SERVER_INTERNAL_ERROR);
				} else if (response.statusCode === 404) {
					e = new Error(_errors2.default.HTTP_SERVER_NOT_FOUND);
				} else if (response.statusCode === 403) {
					e = new Error(_errors2.default.HTTP_SERVER_FORBIDDEN);
				} else if (response.statusCode === 401) {
					e = new Error(_errors2.default.HTTP_SERVER_UNAUTHORIZED);
				} else if (response.statusCode > 399) {
					e = new Error(_errors2.default.HTTP_SERVER_UNEXPECTED_STATUS_CODE);
				} else if (!_this2.validateResponse(body)) {
					e = new Error(_errors2.default.HTTP_SERVER_UNEXPECTED_RESPONSE);
				}

				if (e) {
					_this2.emit(_events4.default.ERROR, e.message, {
						statusCode: response.statusCode,
						body: body
					});
				}

				var state = void 0;
				if (response.statusCode === 404 || !body || !body.formats) {
					state = _events4.default.OFFLINE;
				} else if (response.statusCode === 200) {
					_this2.uri = body.self;
				}

				if (!state) {
					_this2.formats = _this2.modifyFormats(body.formats);
					state = !Object.keys(_this2.formats).length ? _events4.default.OFFLINE : _events4.default.ONLINE;
				}

				if (state !== _this2.currentState) {
					_this2.emit(state);
				}

				_this2.currentState = state;
				_this2.pingUri = body && body.ping ? body.ping : null;
				_this2.type = body && body.type ? body.type : 'live';
				_this2.emit(_events4.default.MANIFEST, _this2.currentState);

				_this2.setNextPoll(response.statusCode);
				if (cb) {
					cb();
				}
			});
		}
	}, {
		key: 'setNextPoll',
		value: function setNextPoll(statusCode) {
			var _this3 = this;

			if (this.vod) {
				return;
			}

			clearTimeout(this.pollingTimeout);
			var to = void 0;
			switch (statusCode) {
				case 401:
				case 403:
					if (this.noLongerUnauthorizedPolling) {
						to = this.options.pollingInterval;
					} else {
						to = this.options.unauthorizedPollingInterval;

						if (!this.unauthorizedRecoveryTimout) {
							this.unauthorizedRecoveryTimout = setTimeout(function () {
								_this3.noLongerUnauthorizedPolling = true;
							}, this.options.unauthorizedRecoveryDuration);
						}
					}
					break;
				default:
					this.noLongerUnauthorizedPolling = null;
					to = this.options.pollingInterval;
			}

			this.pollingTimeout = setTimeout(function () {
				_this3.load();
			}, to);
		}

		/**
   * Sets the public id
   * @param {string}
   */

	}, {
		key: 'setPublicId',
		value: function setPublicId(publicId) {
			this.type = null;
			this.formats = {};

			if (typeof publicId === 'string') {
				this.publicId = publicId;
			} else if (publicId && (typeof publicId === 'undefined' ? 'undefined' : _typeof(publicId)) === 'object') {
				this.manifest = publicId;
				this.currentState = _events4.default.ONLINE;
				this.type = this.manifest.type;
				this.formats = this.manifest.formats;
			}
		}

		/**
   * @param {any} [body]
   */

	}, {
		key: 'validateResponse',
		value: function validateResponse(body) {
			if (!body || (typeof body === 'undefined' ? 'undefined' : _typeof(body)) !== 'object') {
				return false;
			}
			if (_typeof(body.formats) !== 'object') {
				return false;
			}
			return true;
		}

		/**
   * @param {string} publicId Public id for the uri
   * @return {bool}
   */

	}, {
		key: 'setUri',
		value: function setUri(publicId) {
			if (!publicId) {
				return !!this.uri;
			}

			if (this.options.mediaLoaderUri) {
				this.uri = this.options.mediaLoaderUri;
				return true;
			}

			this.uri = (0, _parseUrl2.default)(this.host).href;
			if (!this.uri) {
				this.emit(_events4.default.ERROR, _errors2.default.INVALID_MEDIA_URL);
				return false;
			}
			this.uri += this.options.apiPrefix + '/' + publicId + this.options.apiSuffix;
			return true;
		}

		/**
  * Returns the state and formats
  * @param {string} format requested format
  * @return {object} {encodings: [], manifest: '', state: ''}
  */

	}, {
		key: 'get',
		value: function get(format) {
			if (!this.formats[format]) {
				return {
					type: null,
					encodings: [],
					origin: null,
					manifest: null,
					audioCodec: null,
					videoCodec: null,
					state: _events4.default.ONLINE
				};
			}

			var encodings = [];
			if (this.formats[format].encodings) {
				encodings = this.formats[format].encodings.sort(function (a, b) {
					if (a.videoKbps + a.audioKbps > b.videoKbps + b.audioKbps) {
						return 1;
					}
					return -1;
				});
			} else {
				var t = Object.keys(this.formats[format]).filter(function (e) {
					return !isNaN(e);
				}).sort();

				for (var i = 0; i < t.length; i++) {
					encodings.push(this.formats[format][t[i]]);
				}
			}

			var o = this.formats[format].origin;
			if (o) {
				o.origin = true;
			}

			return {
				type: this.type,
				origin: o,
				encodings: encodings,
				audioCodec: this.formats[format].audioCodec,
				videoCodec: this.formats[format].videoCodec,
				manifest: this.formats[format].manifest,
				state: _events4.default.ONLINE
			};
		}

		/**
   * @return boolean
   */

	}, {
		key: 'destroy',


		/**
   * @return void
   */
		value: function destroy() {
			clearInterval(this.pollingTimeout);
		}

		/**
   * starts a polling interval
   * @return void
   */

	}, {
		key: 'startInterval',
		value: function startInterval() {
			if (!this.options.pollingInterval || this.manifest || this.vod) {
				this.shouldBePolling = false;
				return;
			}
			this.shouldBePolling = true;
		}
	}, {
		key: 'vod',
		get: function get() {
			return this.type === 'recorded';
		}
	}]);

	return MediaLoader;
}(_events2.default);

exports.default = MediaLoader;
},{"./errors":19,"./events":20,"./parse-url":26,"events":54,"xhr":64}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (href) {
	var a = document.createElement('a');
	a.href = href;

	if (!a.pathname) {
		return false;
	}

	return {
		href: a.href,
		protocol: a.protocol,
		port: a.port,
		pathname: a.pathname,
		search: a.search,
		host: a.host || window.location.host
	};
};
},{}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _detect = require('./detect');

var _detect2 = _interopRequireDefault(_detect);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _store = require('./store');

var _store2 = _interopRequireDefault(_store);

var _stats = require('./stats');

var _mediaLoader = require('./media-loader');

var _mediaLoader2 = _interopRequireDefault(_mediaLoader);

var _errors = require('./errors');

var _errors2 = _interopRequireDefault(_errors);

var _events3 = require('./events');

var _events4 = _interopRequireDefault(_events3);

var _gcd = require('./gcd');

var _gcd2 = _interopRequireDefault(_gcd);

var _getDefaultOptions = require('./get-default-options');

var _getDefaultOptions2 = _interopRequireDefault(_getDefaultOptions);

require('./polyfills');

var _storageValues = require('./storage-values');

var _storageValues2 = _interopRequireDefault(_storageValues);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint no-underscore-dangle: 0 */

var DEFAULT_BITRATE = 1800;
var LOW_BITRATE = 600;

var DefaultOptions = {
	autoplay: true,
	bitrate: undefined,
	debug: false,
	flashWmode: 'transparent',
	flashFrameRate: 60,
	fullscreenEl: 'parent',
	forceDrivers: false,
	formats: null, // default happens on the "set"
	maxBufferLength: 30,
	maxBufferSize: 60 * 1000 * 1000,
	muted: undefined,
	pollingInterval: 10000,
	unauthorizedPollingInterval: 1000,
	unauthorizedRecoveryDuration: 5000,
	posterURI: null,
	preset: undefined,
	recoverErrorCount: 10,
	recoverTimeout: 4000,
	startTime: 0,
	// storagePrefix: '',
	viewUri: null,
	volume: 0.75,
	origin: false,

	// flash paths
	flashlsPath: '../dist/flashlsChromeless.swf',
	strobeSwfPath: '../dist/StrobeMediaPlayback.swf',
	tfSwfPath: '../dist/thin.swf',
	avpPath: '../dist/avp.swf',
	hlsjsPath: null
};

/**
 * @class Lively video video player. Includes video drivers, and video player
 */

var Player = function (_EventEmitter) {
	_inherits(Player, _EventEmitter);

	/**
  * @param {object} el containing dom element
  * @param {string} manifest uri or object
  * @param {object} options
  * @param {string} [options[].host] host
  * @param {bool} [options[].autoplay] [true] autoplays the stream when it loads
  * @param {number} [options[].bitrate] [undefined] null for adaptive when available, desired kbps otherwise
  * @param {array} [options[].drivers] ["mp4", "nativeHls", "jsHls", "flash", lodef"] driver priority
  * @param {bool} [options[].debug] [false] enables debug logging
  * @param {number} [options[].recoverErrorCount] [10] Playback error count to recover the entire driver on
  * @param {number} [options[].forceDrivers]	[false]
  * @param {bool} [options[].muted] whether or not the driver is muted
  * @param {bool} [options[].hijackingClicks] [true] whether or not the rest of the app is hijacking clicks for mobile autoplays
  * @param {number} [options[].pollingInterval] [10000] ms timeout to wait before polling again
  * @param {number} [options[].unauthorizedPollingInterval] [1000] ms timeout to wait before polling again if unauthorized, designed to be more frequent for a short interval of time to restart playback
  * @param {number} [options[].unauthorizedRecoveryDuration] [5000] ms timeout to poll quickly after receiving an unauthorized response
  * @param {string} [options[].posterUri] sets the poster attribute when available
  * @param {bool} [options[].origin] [false] play the origin source
  * @param {number} [options[].volume] [0.75] 0-1 volume
  * @return {void}
  */
	function Player(el, publicId, options) {
		_classCallCheck(this, Player);

		var _this = _possibleConstructorReturn(this, (Player.__proto__ || Object.getPrototypeOf(Player)).call(this));

		_this.availableDrivers = [];

		/** Setup element, streaming ur **/
		switch (typeof el === 'undefined' ? 'undefined' : _typeof(el)) {
			case 'string':
				_this.el = document.querySelector(el);
				break;
			case 'object':
				_this.el = el;
				break;
			default:
				_this.error(_errors2.default.INVALID_EL);
		}

		_this.options = (0, _getDefaultOptions2.default)(options, DefaultOptions);
		_this.store = new _store2.default();
		_this.firstPlay = true;

		/** Set default mute **/
		if (typeof _this.options.muted === 'undefined') {
			var mutedStore = _this.store.get(_storageValues2.default.muted);
			_this.options.muted = mutedStore !== null ? mutedStore === 'true' : _this.options.muted;
		}

		/** Set default volume **/
		var volumeStore = _this.store.get(_storageValues2.default.volume);
		_this.options.volume = isNaN(parseFloat(volumeStore)) ? _this.options.volume : parseFloat(volumeStore);
		/** Set default bitrate **/

		if (_this.options.bitrate && !parseInt(_this.options.bitrate, 10)) {
			_this.error(_errors2.default.INVALD_BITRATE);
			_this.options.bitrate = undefined;
		}

		if (typeof _this.options.bitrate !== 'undefined') {
			_this.storeBitrate(_this.options.bitrate);
		}

		var lockedKbps = parseInt(_this.store.get(_storageValues2.default.lockedKbps), 10);
		_this.options.bitrate = lockedKbps || parseInt(_this.options.bitrate, 10) || null;
		/** Set estimated bitrate **/
		_this.estimatedKbps = parseInt(_this.store.get(_storageValues2.default.estimatedKbps), 10) || DEFAULT_BITRATE;

		// tracks whether or not the user is trying to play the video
		_this.isTryingToPlay = false;
		// tracks whether or not the video should start to play when it comes online
		_this.shouldTryToPlay = _this.options.autoplay;

		// set log level.  Logger is a singleton so consider instantiating a logger for each player...
		// or storing a map in the logger...probably not that...
		if (_this.options.debug) {
			_logger2.default.setLevels({
				debug: true,
				error: 1,
				warn: 1,
				info: 1,
				timing: 1
			});
		} else {
			_logger2.default.setLevels();
		}

		/** Track timings **/
		_this.trackFirstProgress();

		/** Load manifest, attach events, play video **/
		if (_this.options.mediaLoaderUri) {
			_logger2.default.deprecated('mediaLoaderUri', 'second argument may now take a uri or publicId');
		}

		if (publicId) {
			if (typeof publicId === 'string') {
				if (publicId.slice(0, 7) === 'http://' || publicId.slice(0, 8) === 'https://') {
					_this.options.mediaLoaderUri = publicId;
				}
			} else if ((typeof publicId === 'undefined' ? 'undefined' : _typeof(publicId)) === 'object') {
				_this.options.mediaLoaderUri = publicId;
			} else if (publicId !== null) {
				_logger2.default.error('invalid manifest', publicId);
				return _possibleConstructorReturn(_this);
			}
		}

		if (!Array.isArray(_this.options.drivers)) {
			_logger2.default.error('invalid drivers, must be an array', _this.options.drivers);
			return _possibleConstructorReturn(_this);
		}

		for (var i = 0; i < _this.options.drivers.length; i++) {
			if (typeof _this.options.drivers[i] !== 'function') {
				_logger2.default.error('invalid drivers, each driver must type function, check driver at index ' + i);
				return _possibleConstructorReturn(_this);
			}
		}

		// mobile muted autoplay
		if (!_this.options.hijackingClicks && _this.options.autoplay && _detect2.default.modernMobile()) {
			_this.options.muted = true;
		}

		_this.mediaLoader = _this.options.mediaLoader || new _mediaLoader2.default(publicId, _this.options);
		_this.setDrivers(_this.options.drivers);
		_this.mediaLoader.on(_events4.default.ERROR, _this.eventHandler(_events4.default.ERROR).bind(_this));
		_this.mediaLoader.on(_events4.default.MANIFEST, _this.eventHandler(_events4.default.MANIFEST).bind(_this));

		_this.mediaLoader.on(_events4.default.MANIFEST, function () {
			if (_this.mediaLoader.currentState !== _events4.default.ONLINE) {
				return;
			}

			if (_this.watchForAudioSwitch()) {
				_this.currentDriver.options.origin = false;
				_this.currentDriver.restart();
				return;
			}

			if (!_this.shouldTryToPlay || !_this.currentDriver) {
				return;
			}

			_this.play(function (playing) {
				if (playing) {
					_this.shouldTryToPlay = false;
				}
			});

			if (!_this.currentDriver.supportsAutoplay) {
				_this.shouldTryToPlay = false;
			}
		});

		_this.mediaLoader.on(_events4.default.ONLINE, function () {
			_this.emit(_events4.default.ONLINE);
		});

		_this.mediaLoader.on(_events4.default.OFFLINE, function () {
			if (_this.tryingToPlay) {
				_this.shouldTryToPlay = true;
			}

			_this.emit(_events4.default.OFFLINE);
		});
		_this.mediaLoader.load();
		if (_this.mediaLoader.startInterval) {
			_this.mediaLoader.startInterval();
		}

		if (_this.options.autoplay && _this.currentDriver && _this.currentDriver.elementPlay) {
			// mobile autoplay
			_this.currentDriver.elementPlay();
		}
		return _this;
	}

	_createClass(Player, [{
		key: 'trackFirstProgress',
		value: function trackFirstProgress() {
			var _this2 = this;

			if (this.options.autoplay) {
				this.autoplayProgressId = _stats.stats.start(_stats.STATS_EVENTS.AUTOPLAY_PROGRESS);
				this.once(_events4.default.MEDIA_TIMEUPDATE, function () {
					_stats.stats.stop(_this2.autoplayProgressId, {
						driver: _this2.currentDriver.driver
					});
				});
			}
		}

		// watches for audio state switching from origin

	}, {
		key: 'watchForAudioSwitch',
		value: function watchForAudioSwitch() {
			// current driver is not playing origin
			if (!this.currentDriver || !this.currentDriver.options.origin) {
				return false;
			}

			// current driver is playing origin, and origin was removed
			return !this.mediaLoader.get(this.currentDriver.format).origin;
		}

		/**
   * sets an option after construction, effects depend on implementation.  May not work until next restart
   * @param {string} key
   * @param {any} [value]
   * @return {void}
   */

	}, {
		key: 'setOption',
		value: function setOption(k, v) {
			this.options[k] = v;
			if (this.currentDriver) {
				this.currentDriver.setOption(k, v);
			}
		}

		/**
   * gets the current active playing manifest, null otherwise
   * @return {string}
   */

	}, {
		key: 'load',


		/**
   * Loads the next video
   * @param {string} [publicId]
   */
		value: function load(publicId, cb) {
			this.stop();
			this.mediaLoader.setPublicId(publicId);
			this.mediaLoader.load(publicId, cb);
		}

		/**
   * destroys self, loader, and controllers
   * @return {void}
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			if (this.mediaLoader && this.mediaLoader.destroy) {
				this.mediaLoader.removeAllListeners(_events4.default.MANIFEST);
				this.mediaLoader.destroy();
			}

			var k = void 0;
			if (this.currentDriver) {
				for (k in _events4.default) {
					this.currentDriver.removeAllListeners(_events4.default[k]);
					this.currentDriver.removeAllListeners(_events4.default[k], this.eventHandler(_events4.default[k]));
				}
				this.currentDriver.destroy();
			}

			this.removeAllListeners(_events4.default.MEDIA_PROGRESS);
			this.emit(_events4.default.DESTROY);
		}

		// Helper to store bitrate from constructor and from setBitrate

	}, {
		key: 'storeBitrate',
		value: function storeBitrate(bitrate) {
			this.store.set(_storageValues2.default.lockedKbps, bitrate);
		}

		/**
   * @param {number} bitrate
   * @return {void}
   */

	}, {
		key: 'playOrigin',
		value: function playOrigin() {
			this.options.origin = true;
			this.store.set(_storageValues2.default.origin, 1);
			this.store.set(_storageValues2.default.lockedKbps, null);
			if (!this.currentDriver) {
				return;
			}
			this.currentDriver.playOrigin();
		}

		/**
   * sets the current driver
   * @param {number} [index] 0
   */

	}, {
		key: 'restart',


		/**
   * attempts to restart the current driver
   * @return {void}
   */
		value: function restart() {
			var shouldTryToPlay = this.tryingToPlay;
			this.stop();
			this.shouldTryToPlay = shouldTryToPlay;
			this.mediaLoader.load();
		}

		/**
   * switch drivers
   */

	}, {
		key: 'switchDrivers',
		value: function switchDrivers(drivers) {
			this.options.drivers = drivers;
			this.setDrivers(drivers);
			this.restart();
		}

		/**
   * Returns the current online/offline/playing state
   * @return {string}
   */

	}, {
		key: 'getState',
		value: function getState() {
			return this.mediaLoader.currentState;
		}

		// Private function to return event handler closures

	}, {
		key: 'eventHandler',
		value: function eventHandler(ev) {
			var _this3 = this;

			return function () {
				for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}

				if (ev === 'error' && (!_this3._events || !_this3._events.hasOwnProperty('error'))) {
					// return console.log('unhandled error', [ev].concat(args));
					return;
				}
				_this3.emit.apply(_this3, [ev].concat(args));
			};
		}

		// Private helper function to emit errors

	}, {
		key: 'error',
		value: function error(err, info) {
			if (!this._events || this._events.hasOwnProperty('error')) {
				this.emit(_events4.default.ERROR, err, info);
			}

			_logger2.default.warn(err);
		}

		/**
   * sets drivers
   * @param {array} sets a list of drivers to "this.drivers"
   */

	}, {
		key: 'setDrivers',
		value: function setDrivers(list) {
			var driver = void 0;
			this.availableDrivers = [];
			for (var i = 0; i < list.length; i++) {
				driver = list[i];

				if (!driver || !driver.isSupported()) {
					// Add driver requirements
					_logger2.default.debug('driver at index ' + i + ' is not supported');
					continue;
				}

				if (this.options.forceDrivers || driver.isSupported()) {
					this.availableDrivers.push(driver);
				}
			}

			if (!this.availableDrivers.length) {
				this.noDrivers();
				return;
			}
			this.driver = 0;
		}

		/**
   * pauses the video [synonym for stop]
   * @return {void}
   */

	}, {
		key: 'pause',
		value: function pause() {
			this.isTryingToPlay = false;
			if (this.currentDriver) {
				this.currentDriver.pause();
			}
			this.emit(_events4.default.MEDIA_PAUSE);
		}
	}, {
		key: 'noDrivers',
		value: function noDrivers() {
			if (this.mediaLoader.currentState !== _events4.default.ONLINE) {
				return;
			}
			this.error(_errors2.default.NO_DRIVERS);
		}

		/**
   * plays the video
   * @return {void}
   */

	}, {
		key: 'play',
		value: function play() {
			var _this4 = this;

			if (!this.currentDriver) {
				this.noDrivers();
				return;
			}

			this.isTryingToPlay = true;
			this.currentDriver.play(function (playing) {
				if (!playing) {
					_this4.isTryingToPlay = false;
					return;
				}

				_this4.shouldTryToPlay = false;
				if (_this4.store.get(_storageValues2.default.muted) === 'true') {
					_this4.currentDriver.mute();
				}

				if (_this4.firstPlay && _this4.vod && _this4.options.startTime) {
					_this4.currentDriver.currentTime = _this4.options.startTime;
				}

				_this4.isTryingToPlay = true;
				if (_this4.mediaLoader.state === _events4.default.OFFLINE) {
					return;
				}
				_this4.emit(_events4.default.MEDIA_PLAY);
				_this4.firstPlay = false;
			});
		}

		/**
   * stops the video
   * @return {void}
   */

	}, {
		key: 'stop',
		value: function stop() {
			this.isTryingToPlay = false;
			if (this.currentDriver) {
				this.currentDriver.stop();
			}
			this.emit(_events4.default.MEDIA_STOP);
		}

		/**
  * gets video duration
  * @return {number} seconds
   */

	}, {
		key: 'isTryingToPlayAudio',


		/**
   * Returns t/f whether or not the player is trying to play audio
   * @return {boolean}
   */
		value: function isTryingToPlayAudio() {
			if (!this.currentDriver) {
				return this.tryingToPlay;
			}

			return this.currentDriver.isTryingToPlayAudio(this.tryingToPlay);
		}

		/**
   * mute the video
   * @return {void}
   */

	}, {
		key: 'mute',
		value: function mute() {
			if (!this.currentDriver) {
				this.noDrivers();
				return null;
			}

			var currentValue = this.currentDriver.mute();
			this.store.set(_storageValues2.default.muted, String(currentValue));
			this.emit(_events4.default.MEDIA_MUTE);
			return currentValue;
		}

		/**
   * unmute the video
   * @return {void}
   */

	}, {
		key: 'unmute',
		value: function unmute() {
			if (!this.currentDriver) {
				this.noDrivers();
				return null;
			}

			var currentValue = this.currentDriver.unmute();
			this.store.set(_storageValues2.default.muted, String(currentValue));
			this.emit(_events4.default.MEDIA_UNMUTE);
			return currentValue;
		}

		/**
   * t/f if the video is muted
   * @return {boolean}
   */

	}, {
		key: 'currentEncoding',


		/**
   * @return {object} current encoding
   */
		value: function currentEncoding() {
			return this.currentDriver ? this.currentDriver.pickEncoding() : undefined;
		}

		/**
   * sets the volume of the video, this is persisted in local storage or a cookie
   * @param {number} volume
   * @return {number} current volume
   */

	}, {
		key: 'supportsFullscreen',


		/**
   * t/f if the current driver + browser/os supports full screen
   * @return {bool} supportsFullscreen
   */
		value: function supportsFullscreen() {
			if (!this.currentDriver) {
				return null;
			}
			return this.currentDriver.supportsFullscreen();
		}

		/**
   * t/f if the current driver + browser/os supports volume
   * @return {bool} supportsVolume
   */

	}, {
		key: 'supportsVolume',
		value: function supportsVolume() {
			if (!this.currentDriver) {
				return null;
			}
			return this.currentDriver.supportsVolume();
		}

		/**
   * Returns the current bitrate level.	null if unknown
   * @return {number}
   */

	}, {
		key: 'manifest',
		get: function get() {
			if (!this.mediaLoader || !this.mediaLoader.uri) {
				return null;
			}
			return this.mediaLoader.uri;
		}
	}, {
		key: 'bitrate',
		set: function set(bitrate) {
			this.storeBitrate(bitrate);
			this.currentDriver.bitrate = bitrate;
		}
	}, {
		key: 'driver',
		set: function set(index) {
			var _this5 = this;

			if (!this.availableDrivers[index]) {
				this.noDrivers();
				return;
			}

			var Driver = this.availableDrivers[index];
			if (this.currentDriver) {
				this.currentDriver.destroy();
			}

			this.currentDriver = new Driver(this, this.mediaLoader, {
				bitrate: this.options.bitrate,
				estimatedKbps: this.estimatedKbps,
				volume: this.options.volume,
				muted: this.options.muted,
				debug: this.options.debug,
				recoverTimeout: this.options.recoverTimeout,
				recoverErrorCount: this.options.recoverErrorCount,
				maxBufferLength: this.options.maxBufferLength,
				maxBufferSize: this.options.maxBufferSize,
				preset: this.options.preset,
				flashlsPath: this.options.flashlsPath,
				tfSwfPath: this.options.tfSwfPath,
				strobeSwfPath: this.options.strobeSwfPath,
				avpPath: this.options.avpPath,
				hlsjsPath: this.options.hlsjsPath,
				posterURI: this.options.posterURI,
				flashFrameRate: this.options.flashFrameRate,
				flashWmode: this.options.flashWmode,
				origin: this.options.origin,
				mse: this.options.mse
			});

			this.currentDriver.on(_events4.default.ERROR, function (err) {
				var nextDriver = function nextDriver() {
					if (!_this5.availableDrivers.length) {
						_this5.mediaLoader.once(_events4.default.MANIFEST, function () {
							_this5.setDrivers(_this5.options.drivers);
							if (_this5.isTryingToPlay()) {
								_this5.play();
							}
						});
						return;
					}
					_this5.currentDriver.destroy();
					_this5.availableDrivers.splice(index, 1);
					_this5.driver = index;
					if (_this5.tryingToPlay) {
						_this5.play();
					}
				};

				switch (err) {
					case _errors2.default.EMBED_SWF_FAILED:
						nextDriver();
						break;
					case _errors2.default.DRIVER_NOT_SUPPORTED:
						nextDriver();
						break;
					default:
						break;
				}
			});
			this.emit(_events4.default.SELECT_DRIVER, this.currentDriver);
			this.currentDriver.on(_events4.default.ESTIMATED_BW, function (kbps) {
				_this5.store.set(_storageValues2.default.estimatedKbps, parseInt(kbps, 10) || LOW_BITRATE);
			});

			this.currentDriver.on(_events4.default.MEDIA_ENDED, function () {
				_this5.isTryingToPlay = false;
			});

			for (var k in _events4.default) {
				this.currentDriver.on(_events4.default[k], this.eventHandler(_events4.default[k]));
			}
		}
	}, {
		key: 'duration',
		get: function get() {
			return this.currentDriver ? this.currentDriver.duration : Infinity;
		}

		/**
   * returns t/f if recorded, null if unknown
   */

	}, {
		key: 'vod',
		get: function get() {
			return this.mediaLoader ? this.mediaLoader.vod : null;
		}

		/**
   * current buffer length
   * @return {number} seconds
   */

	}, {
		key: 'bufferLength',
		get: function get() {
			return this.currentDriver ? this.currentDriver.bufferLength : 0;
		}

		/**
   * current back buffer length
   * @return {number} seconds
   */

	}, {
		key: 'backBufferLength',
		get: function get() {
			return this.currentDriver ? this.currentDriver.backBufferLength : 0;
		}

		/**
   * gets video current time
   * @return {number} seconds
   */

	}, {
		key: 'currentTime',
		get: function get() {
			return this.currentDriver ? this.currentDriver.currentTime : 0;
		}

		/**
   * seeks to the current time
   * @param {number} seconds
   */
		,
		set: function set(ct) {
			if (this.currentDriver) {
				this.currentDriver.currentTime = ct;
			}
		}
	}, {
		key: 'bufferTimes',
		get: function get() {
			return this.currentDriver ? this.currentDriver.bufferTimes : [];
		}

		/**
   * Returns t/f whether or not the player is trying to play, useful for controls
   * @return {boolean}
   */

	}, {
		key: 'tryingToPlay',
		get: function get() {
			return !!this.isTryingToPlay;
		}
	}, {
		key: 'muted',
		get: function get() {
			if (!this.currentDriver) {
				this.noDrivers();
				return null;
			}

			return this.currentDriver.muted;
		}

		/**
   * @return {object} current media data from api for given driver
   */

	}, {
		key: 'mediaData',
		get: function get() {
			if (!this.currentDriver) {
				return null;
			}

			return this.currentDriver.data;
		}

		/**
   * @return {array} media data for all available formats
   */

	}, {
		key: 'allMediaData',
		get: function get() {
			var drivers = this.availableDrivers;
			var data = [];
			var driver = void 0;

			for (var i = 0; i < drivers.length; i++) {
				driver = drivers[i];
				if (!driver.isSupported) {
					continue;
				}

				if (driver.isSupported(this.el)) {
					var d = this.mediaLoader.get(driver.format);

					if (!d.manifest) {
						continue;
					}

					d.driver = driver.driver;
					data.push(d);
				}
			}

			return data;
		}
	}, {
		key: 'volume',
		set: function set(v) {
			if (!this.currentDriver) {
				return undefined;
			}

			var currentValue = this.currentDriver.volume = v;
			this.store.set(_storageValues2.default.muted, currentValue === 0);
			this.store.set(_storageValues2.default.volume, currentValue);
			this.emit(_events4.default.MEDIA_VOLUME, currentValue);
			return currentValue;
		}

		/**
   * gets current volume
   * @return {number} current volume
   */
		,
		get: function get() {
			if (!this.currentDriver) {
				return 0;
			}
			return this.currentDriver.volume;
		}

		/**
   * gets the details
   * @return {object} details object
   */

	}, {
		key: 'details',
		get: function get() {
			if (!this.currentDriver) {
				return {};
			}

			return this.currentDriver.details;
		}
	}, {
		key: 'chosenLevel',
		get: function get() {
			if (!this.currentDriver) {
				return undefined;
			}
			return this.currentDriver.chosenLevel;
		}

		/**
   * Returns the current bitrate level.	null if unknown
   * @return {number}
   */

	}, {
		key: 'currentLevel',
		get: function get() {
			if (!this.currentDriver) {
				return undefined;
			}
			return this.currentDriver.currentLevel;
		}

		/**
   * Returns the next bitrate level.	null if unknown
   * @return {number}
   */

	}, {
		key: 'nextLevel',
		get: function get() {
			if (!this.currentDriver) {
				return undefined;
			}
			return this.currentDriver.nextLevel;
		}

		/**
   * Returns aspect ratio as width / height
   *
   * @return {number}
   */

	}, {
		key: 'aspectRatio',
		get: function get() {
			if (!this.currentDriver) {
				return null;
			}

			var data = this.currentDriver.data;
			if (!data) {
				return null;
			}

			if (!data.encodings || !data.encodings.length) {
				return null;
			}

			if (!data.encodings[0].videoWidth || !data.encodings[0].videoHeight) {
				return null;
			}

			var cd = (0, _gcd2.default)(data.encodings[0].videoWidth, data.encodings[0].videoHeight);
			return {
				width: data.encodings[0].videoWidth / cd,
				height: data.encodings[0].videoHeight / cd
			};
		}
	}]);

	return Player;
}(_events2.default);

exports.default = Player;
},{"./detect":18,"./errors":19,"./events":20,"./gcd":21,"./get-default-options":22,"./logger":23,"./media-loader":25,"./polyfills":28,"./stats":30,"./storage-values":32,"./store":37,"events":54}],28:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* eslint-disable */

// Remove Polyfill
if (!('remove' in window.Element.prototype)) {
	window.Element.prototype.remove = function () {
		if (this.parentNode) {
			this.parentNode.removeChild(this);
		}
	};
}

// Object create polyfill
if (typeof Object.create !== 'function') {
	Object.create = function (_undefined) {
		var Temp = function Temp() {};
		return function (prototype, propertiesObject) {
			if (prototype !== Object(prototype) && prototype !== null) {
				throw TypeError('Argument must be an object, or null');
			}
			Temp.prototype = prototype || {};
			if (propertiesObject !== _undefined) {
				Object.defineProperties(Temp.prototype, propertiesObject);
			}
			var result = new Temp();
			Temp.prototype = null;
			return result;
		};
	}();
}

// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel
// MIT license

(function () {
	var lastTime = 0;
	var vendors = ['ms', 'moz', 'webkit', 'o'];

	for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
		window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
		window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
	}

	if (!window.requestAnimationFrame) {
		window.requestAnimationFrame = function (callback, element) {
			var currTime = new Date().getTime();
			var timeToCall = Math.max(0, 16 - (currTime - lastTime));
			var id = window.setTimeout(function () {
				callback(currTime + timeToCall);
			}, timeToCall);
			lastTime = currTime + timeToCall;
			return id;
		};
	}

	if (!window.cancelAnimationFrame) {
		window.cancelAnimationFrame = function (id) {
			clearTimeout(id);
		};
	}
})();

// performance now polyfill
(function (window) {
	var startOffset = Date.now ? Date.now() : +new Date();
	window.performance = window.performance || {};
	window.performance.now = window.performance.webkitNow || window.performance.mozNow || window.performance.msNow || function () {
		return (Date.now ? Date.now() : +new Date()) - startOffset;
	};
})(window);

// Object keys polyfill
// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
if (!Object.keys) {
	Object.keys = function () {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		var hasDontEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
		var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
		var dontEnumsLength = dontEnums.length;

		return function (obj) {
			if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' && (typeof obj !== 'function' || obj === null)) {
				throw new TypeError('Object.keys called on non-object');
			}

			var result = [];
			var prop = void 0;
			var i = void 0;

			for (prop in obj) {
				if (hasOwnProperty.call(obj, prop)) {
					result.push(prop);
				}
			}

			if (hasDontEnumBug) {
				for (i = 0; i < dontEnumsLength; i++) {
					if (hasOwnProperty.call(obj, dontEnums[i])) {
						result.push(dontEnums[i]);
					}
				}
			}
			return result;
		};
	}();
}

/*
 * classList.js: Cross-browser full element.classList implementation.
 * 1.1.20150312
 *
 * By Eli Grey, http://eligrey.com
 * License: Dedicated to the public domain.
 *	 See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
 */

/* global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

if ('document' in self) {
	// Full polyfill for browsers with no classList support
	// Including IE < Edge missing SVGElement.classList
	if (!('classList' in document.createElement('_')) || document.createElementNS && !('classList' in document.createElementNS('http://www.w3.org/2000/svg', 'g'))) {
		(function (view) {
			'use strict';

			if (!('Element' in view)) return;

			var classListProp = 'classList';
			var protoProp = 'prototype';
			var elemCtrProto = view.Element[protoProp];
			var objCtr = Object;
			var strTrim = String[protoProp].trim || function () {
				return this.replace(/^\s+|\s+$/g, '');
			};
			var arrIndexOf = Array[protoProp].indexOf || function (item) {
				var i = 0;
				var len = this.length;

				for (; i < len; i++) {
					if (i in this && this[i] === item) {
						return i;
					}
				}
				return -1;
			};
			// Vendors: please allow content code to instantiate DOMExceptions
			var DOMEx = function DOMEx(type, message) {
				this.name = type;
				this.code = DOMException[type];
				this.message = message;
			};
			var checkTokenAndGetIndex = function checkTokenAndGetIndex(classList, token) {
				if (token === '') {
					throw new DOMEx('SYNTAX_ERR', 'An invalid or illegal string was specified');
				}
				if (/\s/.test(token)) {
					throw new DOMEx('INVALID_CHARACTER_ERR', 'String contains an invalid character');
				}
				return arrIndexOf.call(classList, token);
			};
			var ClassList = function ClassList(elem) {
				var trimmedClasses = strTrim.call(elem.getAttribute('class') || '');
				var classes = trimmedClasses ? trimmedClasses.split(/\s+/) : [];
				var i = 0;
				var len = classes.length;

				for (; i < len; i++) {
					this.push(classes[i]);
				}
				this._updateClassName = function () {
					elem.setAttribute('class', this.toString());
				};
			};
			var classListProto = ClassList[protoProp] = [];
			var classListGetter = function classListGetter() {
				return new ClassList(this);
			};

			// Most DOMException implementations don't allow calling DOMException's toString()
			// on non-DOMExceptions. Error's toString() is sufficient here.
			DOMEx[protoProp] = Error[protoProp];
			classListProto.item = function (i) {
				return this[i] || null;
			};
			classListProto.contains = function (token) {
				token += '';
				return checkTokenAndGetIndex(this, token) !== -1;
			};
			classListProto.add = function () {
				var tokens = arguments;
				var i = 0;
				var l = tokens.length;
				var token;
				var updated = false;

				do {
					token = tokens[i] + '';
					if (checkTokenAndGetIndex(this, token) === -1) {
						this.push(token);
						updated = true;
					}
				} while (++i < l);
				if (updated) {
					this._updateClassName();
				}
			};
			classListProto.remove = function () {
				var tokens = arguments;
				var i = 0;
				var l = tokens.length;
				var token;
				var updated = false;
				var index;

				do {
					token = tokens[i] + '';
					index = checkTokenAndGetIndex(this, token);
					while (index !== -1) {
						this.splice(index, 1);
						updated = true;
						index = checkTokenAndGetIndex(this, token);
					}
				} while (++i < l);
				if (updated) {
					this._updateClassName();
				}
			};
			classListProto.toggle = function (token, force) {
				token += '';

				var result = this.contains(token);
				var method = result ? force !== true && 'remove' : force !== false && 'add';

				if (method) {
					this[method](token);
				}

				if (force === true || force === false) {
					return force;
				} else {
					return !result;
				}
			};
			classListProto.toString = function () {
				return this.join(' ');
			};

			if (objCtr.defineProperty) {
				var classListPropDesc = {
					get: classListGetter, enumerable: true, configurable: true
				};
				try {
					objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
				} catch (ex) {
					// IE 8 doesn't support enumerable:true
					if (ex.number === -0x7FF5EC54) {
						classListPropDesc.enumerable = false;
						objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
					}
				}
			} else if (objCtr[protoProp].__defineGetter__) {
				elemCtrProto.__defineGetter__(classListProp, classListGetter);
			}
		})(self);
	} else {
		// There is full or partial native classList support, so just check if we need
		// to normalize the add/remove and toggle APIs.

		(function () {
			'use strict';

			var testElement = document.createElement('_');

			testElement.classList.add('c1', 'c2');

			// Polyfill for IE 10/11 and Firefox <26, where classList.add and
			// classList.remove exist but support only one argument at a time.
			if (!testElement.classList.contains('c2')) {
				var createMethod = function createMethod(method) {
					var original = DOMTokenList.prototype[method]; // eslint-disable-line
					DOMTokenList.prototype[method] = function (token) {
						// eslint-disable-line
						var i;
						var len = arguments.length;

						for (i = 0; i < len; i++) {
							token = arguments[i];
							original.call(this, token);
						}
					};
				};
				createMethod('add');
				createMethod('remove');
			}

			testElement.classList.toggle('c3', false);

			// Polyfill for IE 10 and Firefox <24, where classList.toggle does not
			// support the second argument.
			if (testElement.classList.contains('c3')) {
				var _toggle = DOMTokenList.prototype.toggle; // eslint-disable-line

				DOMTokenList.prototype.toggle = function (token, force) {
					// eslint-disable-line
					if (1 in arguments && !this.contains(token) === !force) {
						return force;
					} else {
						return _toggle.call(this, token);
					}
				};
			}

			testElement = null;
		})();
	}
}
},{}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
var STATS_EVENTS = {
	AUTOPLAY_PROGRESS: 'autoplay-first-progress',
	FIRST_LOAD: 'first-load'
};

exports.default = STATS_EVENTS;
},{}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.STATS_EVENTS = exports.stats = undefined;

var _stats = require('./stats');

var _stats2 = _interopRequireDefault(_stats);

var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * singleton interface for use by package
 * @type {Stats}
 */
var stats = new _stats2.default();

exports.stats = stats;
exports.STATS_EVENTS = _events2.default;
},{"./events":29,"./stats":31}],31:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class to track stats
 */
var Stats = function () {
	function Stats() {
		_classCallCheck(this, Stats);

		this.eventCounter = 0;
		this.timings = {};
	}

	/**
  * @param {string} name Name of timing stat to track
  * @return {number} id of stat to track
  */


	_createClass(Stats, [{
		key: 'start',
		value: function start(name) {
			var id = this.eventCounter++;
			this.timings[id] = {
				ms: Date.now(),
				name: name
			};
			return id;
		}

		/**
   * @param {number} id Id of stat top stop tracking
   * @param {object} [metadata] Metadata to send along with the stat
   * @return {void}
   */

	}, {
		key: 'stop',
		value: function stop(id, inputMetadata) {
			if (!this.timings[id]) {
				return;
			}

			var metadata = inputMetadata || {};
			metadata.ms = Date.now() - this.timings[id].ms;

			_logger2.default.timing(this.timings[id].name, metadata);
			delete this.timings[id];
		}
	}]);

	return Stats;
}();

exports.default = Stats;
},{"../logger":23}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
var STORAGE_VALUES = {
	muted: 'lv_muted',
	volume: 'lv_volume',
	lockedKbps: 'lv_locked_kbps', // [null]
	estimatedKbps: 'lv_estimated_kbps', // [1800]
	autoLastKbps: 'lv_auto_last_kbps', // [1800]
	hideSuggestion: 'lv_hide_suggestion',
	origin: 'lv_origin',
	profile: 'lv_origin'
};

exports.default = STORAGE_VALUES;
},{}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint no-console: 0 */

/**
 * @class Base driver for all storage
 */
var BaseDriver = function () {
	function BaseDriver() {
		_classCallCheck(this, BaseDriver);
	}

	_createClass(BaseDriver, [{
		key: 'set',

		/**
   * Abstract class for setting
   * @param {string} key storage key
   * @param {any} value
   */
		value: function set() {
			console.error('an abstract method has been called');
		}

		/**
   * Abstract class for getting
   * @param {string} key storage key
   * @return {any}
   */

	}, {
		key: 'get',
		value: function get() {
			console.error('an abstract method has been called');
		}
	}]);

	return BaseDriver;
}();

exports.default = BaseDriver;
},{}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _baseDriver = require('./base-driver');

var _baseDriver2 = _interopRequireDefault(_baseDriver);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint no-restricted-syntax: 0 */

var PARSE_RE = new RegExp('\\s*;\\s*');
/**
 * @class Cookie Driver
 */

var CookieDriver = function (_BaseDriver) {
	_inherits(CookieDriver, _BaseDriver);

	function CookieDriver() {
		_classCallCheck(this, CookieDriver);

		return _possibleConstructorReturn(this, (CookieDriver.__proto__ || Object.getPrototypeOf(CookieDriver)).apply(this, arguments));
	}

	_createClass(CookieDriver, [{
		key: 'parse',

		/**
   * parses a cookie string into an object
   * @param  {string} str _ga=123; blahblah=543
   * @return {object} {_ga: 123, blahblah: 543}
   */
		value: function parse(str) {
			var o = {};

			if (!str) {
				return o;
			}

			str.split(PARSE_RE).forEach(function (i) {
				var _i$split = i.split('='),
				    _i$split2 = _slicedToArray(_i$split, 2),
				    encodedKey = _i$split2[0],
				    encodedValue = _i$split2[1];

				var key = decodeURIComponent(encodedKey);
				var value = decodeURIComponent(encodedValue);
				o[key] = value;
			});

			return o;
		}

		/**
   * stringifies an object into a cookie string
   * @param  {object} o {_ga: 123, blahblah: 543}
   * @return {string} str _ga=123; blahblah=543
   */

	}, {
		key: 'stringify',
		value: function stringify(o) {
			var v = [];

			for (var k in o) {
				if ({}.hasOwnProperty.call(o, k)) {
					v.push(k + '=' + o[k]);
				}
			}

			return v.join('; ');
		}

		/**
   * local storage set item
   * @param {string} key   item key
   * @param {string} value item value
   */

	}, {
		key: 'set',
		value: function set(key, value) {
			document.cookie = key + '=' + value;
		}

		/**
   * local storage get item
   * @param {string} key   item key
   * @return {string} value item value
   */

	}, {
		key: 'get',
		value: function get(key) {
			var o = this.parse(document.cookie);
			return o[key] || null;
		}
	}]);

	return CookieDriver;
}(_baseDriver2.default);

exports.default = CookieDriver;
},{"./base-driver":33}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _baseDriver = require('./base-driver');

var _baseDriver2 = _interopRequireDefault(_baseDriver);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint no-empty: 0 */

/**
 * @class LocalStorage Driver
 */
var LocalStorageDriver = function (_BaseDriver) {
	_inherits(LocalStorageDriver, _BaseDriver);

	function LocalStorageDriver() {
		_classCallCheck(this, LocalStorageDriver);

		return _possibleConstructorReturn(this, (LocalStorageDriver.__proto__ || Object.getPrototypeOf(LocalStorageDriver)).apply(this, arguments));
	}

	_createClass(LocalStorageDriver, [{
		key: 'set',

		/**
   * local storage set item
   * @param {string} key   item key
   * @param {string} value item value
   */
		value: function set(key, value) {
			try {
				window.localStorage.setItem(key, value);
			} catch (e) {}
		}

		/**
   * local storage get item
   * @param {string} key   item key
   * @return {string} value item value
   */

	}, {
		key: 'get',
		value: function get(key) {
			var v = null;
			try {
				v = window.localStorage.getItem(key) || null;
			} catch (e) {}
			return v;
		}
	}]);

	return LocalStorageDriver;
}(_baseDriver2.default);

exports.default = LocalStorageDriver;
},{"./base-driver":33}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _baseDriver = require('./base-driver');

var _baseDriver2 = _interopRequireDefault(_baseDriver);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var o = {};

/**
 * @class Memory Driver
 */

var MemoryDriver = function (_BaseDriver) {
	_inherits(MemoryDriver, _BaseDriver);

	function MemoryDriver() {
		_classCallCheck(this, MemoryDriver);

		return _possibleConstructorReturn(this, (MemoryDriver.__proto__ || Object.getPrototypeOf(MemoryDriver)).apply(this, arguments));
	}

	_createClass(MemoryDriver, [{
		key: 'set',

		/**
   * local storage set item
   * @param {string} key   item key
   * @param {string} value item value
   */
		value: function set(key, value) {
			o[key] = value;
		}

		/**
   * local storage get item
   * @param {string} key   item key
   * @return {string} value item value
   */

	}, {
		key: 'get',
		value: function get(key) {
			return o[key] || null;
		}
	}]);

	return MemoryDriver;
}(_baseDriver2.default);

exports.default = MemoryDriver;
},{"./base-driver":33}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint no-empty: 0 */

var _cookie = require('./drivers/cookie');

var _cookie2 = _interopRequireDefault(_cookie);

var _localStorage = require('./drivers/local-storage');

var _localStorage2 = _interopRequireDefault(_localStorage);

var _memory = require('./drivers/memory');

var _memory2 = _interopRequireDefault(_memory);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class to handle storage
 */
var Store = function () {
	// sets the driver
	function Store() {
		_classCallCheck(this, Store);

		try {
			if (window.localStorage) {
				this.driver = new _localStorage2.default();
				return;
			}
		} catch (e) {}

		try {
			if (typeof document.cookie === 'string') {
				this.driver = new _cookie2.default();
				return;
			}
		} catch (e) {}

		this.driver = new _memory2.default();
	}

	/**
  * Sets a value  for a key
  * @param  {string} key identifier
  * @param {string} value
  */


	_createClass(Store, [{
		key: 'set',
		value: function set(key, value) {
			if (this.driver) {
				this.driver.set(key, value);
			}
		}

		/**
   * Retrieves the value for the key from the store
   * @param  {string} key identifier
   * @return {string} value
   */

	}, {
		key: 'get',
		value: function get(key) {
			if (!this.driver) {
				return undefined;
			}

			return this.driver.get(key);
		}
	}]);

	return Store;
}();

exports.default = Store;
},{"./drivers/cookie":34,"./drivers/local-storage":35,"./drivers/memory":36}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function () {
	var rnds = rng();

	rnds[6] = rnds[6] & 0x0f | 0x40;
	rnds[8] = rnds[8] & 0x3f | 0x80;

	return unparse(rnds);
};

/* eslint no-mixed-operators: 0 */

/**
 * copy/modified from https://github.com/broofa/node-uuid/blob/master/uuid.js
 * returns a v4 uuid RFC-4122
 */

var RNDS = new Array(16);
function rng() {
	for (var i = 0, r; i < 16; i++) {
		if ((i & 0x03) === 0) {
			r = Math.random() * 0x100000000;
		}
		RNDS[i] = r >>> ((i & 0x03) << 3) & 0xff;
	}

	return RNDS;
}

var byteToHex = [];
var hexToByte = {};

for (var i = 0; i < 256; i++) {
	byteToHex[i] = (i + 0x100).toString(16).substr(1);
	hexToByte[byteToHex[i]] = i;
}

function unparse(buf, offset) {
	var i = offset || 0;
	var bth = byteToHex;

	return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
}
},{}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _baseDriver = require('@livelyvideo/player-core/lib/base-driver');

var _baseDriver2 = _interopRequireDefault(_baseDriver);

var _logger = require('@livelyvideo/player-core/lib/logger');

var _logger2 = _interopRequireDefault(_logger);

var _events = require('@livelyvideo/player-core/lib/events');

var _events2 = _interopRequireDefault(_events);

var _errors = require('@livelyvideo/player-core/lib/errors');

var _errors2 = _interopRequireDefault(_errors);

var _swfobjectAmd = require('swfobject-amd');

var _swfobjectAmd2 = _interopRequireDefault(_swfobjectAmd);

var _lodash = require('lodash.noop');

var _lodash2 = _interopRequireDefault(_lodash);

var _broadcast = require('./thinflash/broadcast');

var _broadcast2 = _interopRequireDefault(_broadcast);

var _playback = require('./thinflash/playback');

var _playback2 = _interopRequireDefault(_playback);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PROGRESS_CHECK = 300;
var MIN_PLAYER_VERSION = '11.0.0';
var DEFAULT_SWF_ID = 'aiw-swf-uniqid';
var id = 0;

/**
 * @class Flash
 */

var FlashDriver = function (_BaseDriver) {
	_inherits(FlashDriver, _BaseDriver);

	/**
  * @param {object} livelyPlayer Lively video object
  * @param {object} mediaLoader media loader object
  * @param {object[]} [options]
  * @param {number} [options[].bitrate] attempts to find and use the bitrate nearest to this value
  * @param {bool} [options[].adaptive] defaults to true if bitrate is null, false if bitrate is supplied.	if true, switches bitrate based on bandwidth
  * @param {number} [options[].volume] [0.75] 0-1 volume
  * @param {number} [options[].maxBufferLength] [30s]
  * @param {number} [options[]. maxBufferSize] [60mb]
  * @param {bool} [options[].muted] whether or not the driver is muted
  * @param {bool} [options[].debug] [false] enables debug logging
  * @return {void}
  */
	function FlashDriver(livelyPlayer, mediaLoader, options) {
		_classCallCheck(this, FlashDriver);

		var _this = _possibleConstructorReturn(this, (FlashDriver.__proto__ || Object.getPrototypeOf(FlashDriver)).call(this, livelyPlayer, mediaLoader, options));

		if (!_this.options.bitrate) {
			_this.options.bitrate = _this.options.estimatedKbps;
		}

		// Need to set these outside of super constructor for ie9
		_this.el = livelyPlayer.el;
		_this.fragCounts = 0;
		_this.fragSize = 0;
		_this.fragDuration = 0;
		_this.fragDownloadTime = 0;
		_this.fragMaxTime = 0;
		_this.fragMinTime = 0;
		_this.bufferOverflowCount = 0;
		_this.bufferUnderflowCount = 0;
		_this.upshift = 0;
		_this.downshift = 0;
		_this.lastProgress = 0;
		_this.currentErrorCount = 0;
		_this.recentErrorCount = 0;
		_this.errors = {};
		_this.livelyPlayer = livelyPlayer;
		_this.mediaLoader = mediaLoader;
		_this.options = options;
		_this.el.volume = _this.options.volume;
		_this.el.muted = _this.options.muted;
		// End of IE9 Hack

		_this.selectedEncoding = null;
		_this.swf = null;
		_this.isStopped = true;
		_this.playing = {};
		_this.hasStarted = false;
		_this.broadcastId = -1;
		_this.currentVolume = options.volume;
		_this.currentMuted = options.muted;
		_this.id = id++;
		_this.render();
		_this.setupThinflash();
		return _this;
	}

	_createClass(FlashDriver, [{
		key: 'render',


		/**
   * Renders object
   * @return {void}
   */
		value: function render() {
			this.obj = document.createElement('div');
			this.el.appendChild(this.obj);
			this.obj.setAttribute('class', 'aiw-swf-container');
			this.obj.setAttribute('id', DEFAULT_SWF_ID + '-' + this.id);
		}

		/**
   * handles errors from thinflash api
   * @return {void}
   */

	}, {
		key: 'handleTFError',
		value: function handleTFError() {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			this.emit.apply(this, [_events2.default.ERROR].concat(args));
		}

		/**
   * Set up thinflash
   * @return {void}
   */

	}, {
		key: 'setupThinflash',
		value: function setupThinflash() {
			var _this2 = this;

			this.thinBroadcast = _broadcast2.default;
			this.thinBroadcast.logError = this.handleTFError.bind(this);
			this.thinBroadcast.getSwf = function () {
				return _this2.swf;
			};

			this.thinPlayback = _playback2.default;
			this.thinPlayback.logError = this.handleTFError.bind(this);
			this.thinPlayback.getSwf = function () {
				return _this2.swf;
			};

			this.tfIsReadyCbs = [];

			window.tfSendToJavaScript = function (elId, e, payload) {
				if (elId !== _this2.obj.getAttribute('id')) {
					return;
				}
				_this2.emit(payload[1], payload[0], payload.slice(2));
			};

			window.tfIsReady = function tfIsReady() {
				return true;
			};
		}
	}, {
		key: 'createAndPlay',
		value: function createAndPlay() {
			var _this3 = this;

			this.createBroadcast();
			this.connectToBroadcast(this.playing, function () {
				_this3.progressCounter = 0;
				_this3.startPlayback();
			});
		}
	}, {
		key: 'shouldBePlaying',
		value: function shouldBePlaying() {
			return !!this.rtmpSrc;
		}

		// Helper function to start playback and set proper audio

	}, {
		key: 'startPlayback',
		value: function startPlayback() {
			this.thinPlayback.playbackPlay(this.broadcastId);
			this.thinPlayback.setVolume(this.broadcastId, this.currentVolume);
			this.thinPlayback.muteAudio(this.broadcastId, this.currentMuted);
		}

		/**
   * Watches progress to detect when the player is struggling and emit progress events
   * @return {void}
   */

	}, {
		key: 'watchProgress',
		value: function watchProgress(recoveryMs) {
			var _this4 = this;

			clearInterval(this.recoveryInterval);

			this.progressCounter = 0;
			/** This interval restarts playback **/
			this.recoveryInterval = setInterval(function () {
				if (_this4.broadcastId < 0 || !_this4.livelyPlayer.tryingToPlay) {
					return;
				}

				var details = _this4.livelyPlayer.details;

				if (details.currentBytesPerSecond > 0) {
					_this4.progressCounter++;
				}

				if (!details.currentBytesPerSecond && _this4.livelyPlayer.tryingToPlay) {
					if (!_this4.errorTimeout) {
						_this4.errorTimeout = setTimeout(function () {
							// get fresh details
							details = _this4.livelyPlayer.details;
							_this4.errorTimeout = null;

							if (_this4.broadcastId < 0) {
								return;
							}

							if (!details.currentBytesPerSecond && _this4.progressCounter > 0) {
								_this4.destroyBroadcast();
								_this4.createAndPlay();
								_this4.emit(_events2.default.ERROR, _errors2.default.NETWORK_ERROR);
							}
						}, recoveryMs * 10);
					}
					return;
				}
				_this4.emitProgress();

				if (details.playbackBytesPerSecond > 0) {
					_this4.emitTimeupdate();
				}

				clearTimeout(_this4.errorTimeout);
				_this4.errorTimeout = null;
			}, recoveryMs);
		}

		/** TODO: this stuff is a hack to make sure the swf is on the page and usable before using it.	Ideally not necessary
   * Not sure how to best tell if it is ready, though
   * @param {function} [cb]
   * @return {void}
   */

	}, {
		key: 'onceTfIsReady',
		value: function onceTfIsReady(cb) {
			if (this.swf && this.swf.tfBroadcastCreate) {
				cb();
				return;
			}
			this.tfIsReadyCbs.push(cb);
			this.pollTf();
		}

		/**
   * hack to support thinflash not being ready
   */

	}, {
		key: 'pollTf',
		value: function pollTf() {
			var _this5 = this;

			if (this.pollingTf) {
				return;
			}
			this.pollingTfAttempts = 0;
			clearInterval(this.pollingTf);
			this.pollingTf = setInterval(function () {
				_this5.pollingTfAttempts++;

				if (_this5.pollingTfAttempts > 30) {
					clearInterval(_this5.pollingTf);
					_this5.emit(_events2.default.ERROR, _errors2.default.EMBED_SWF_FAILED, 'timeout');
					return;
				}

				if (!_this5.swf || !_this5.swf.tfBroadcastCreate) {
					return;
				}

				clearInterval(_this5.pollingTf);
				var fn = _this5.tfIsReadyCbs.shift();
				while (fn) {
					fn();
					fn = _this5.tfIsReadyCbs.shift();
				}
			}, 20);
		}

		/**
   * returns true if browser supports flash
   * @return {Boolean}
   */

	}, {
		key: 'pause',


		/**
   * @return {void}
   */
		value: function pause() {
			this.stop();
		}

		/**
   * @return {void}
   */

	}, {
		key: 'stop',
		value: function stop() {
			clearInterval(this.recoveryInterval);
			clearTimeout(this.watchLessTimeout);

			if (!this.broadcastId) {
				return;
			}

			this.removeListener(_events2.default.MEDIA_PROGRESS, this.watchProgress);
			this.isStopped = true;

			if (this.swf && this.swf.tfPlaybackPlay) {
				this.thinPlayback.playbackPlay(this.broadcastId, false);
			}
			this.destroyBroadcast();
		}

		/**
   * @return {void}
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			this.destroyed = true;
			clearInterval(this.recoveryInterval);
			clearTimeout(this.watchLessTimeout);
			this.thinBroadcast.logError = null;
			this.thinPlayback.logError = null;
			this.obj.remove();
			if (this.swf) {
				this.swf.remove();
			}
		}

		/**
   * @return {void}
   */

	}, {
		key: 'unmute',


		/**
   * @return {boolean} mute value
   */
		value: function unmute() {
			this.currentMuted = false;
			this.thinPlayback.muteAudio(this.broadcastId, false);
			return false;
		}

		/**
   * @return {boolean} mute value
   */

	}, {
		key: 'mute',
		value: function mute() {
			this.currentMuted = true;
			this.thinPlayback.muteAudio(this.broadcastId, true);
			return true;
		}

		/**
   * @return {boolean} true if enters fs
   */

	}, {
		key: 'enterFullscreen',
		value: function enterFullscreen() {
			if (this.swf.requestFullscreen) {
				this.swf.requestFullscreen();
			} else if (this.swf.mozRequestFullScreen) {
				this.swf.mozRequestFullScreen();
			} else if (this.swf.webkitRequestFullScreen) {
				this.swf.webkitRequestFullScreen();
			} else if (this.swf.msRequestFullscreen) {
				this.swf.msRequestFullscreen();
			}
		}

		/**
   * returns current volume
   * @return {number} volume
   */

	}, {
		key: 'getReady',


		/**
   * Wait for media to be ready, Set up swf, Wait for thinflash to be ready
   * @param {function} [cb]
   * @return {void}
   */
		value: function getReady(cb) {
			var _this6 = this;

			this.whenReady(function () {
				if (_this6.swf) {
					cb(_this6.swf);
					return;
				}

				_swfobjectAmd2.default.embedSWF(_this6.options.tfSwfPath, _this6.obj.getAttribute('id'), '100%', '100%', MIN_PLAYER_VERSION, '/dist/expressInstall.swf', {
					framerate: _this6.options.flashFrameRate,
					tfID: _this6.obj.getAttribute('id')
				}, {
					scale: 'noscale',
					quality: 'high',
					allowscriptaccess: 'always',
					allowfullscreen: 'true',
					wmode: _this6.options.flashWmode,
					bgcolor: '#000000',
					align: 'middle',
					salign: 'TL',
					menu: 'true',
					id: _this6.obj.getAttribute('id')
				}, {
					id: _this6.obj.getAttribute('id'),
					class: 'tf-content'
				}, function (e) {
					_this6.swf = e.ref;
					_this6.onceTfIsReady(function () {
						cb(e);
					});
				});
			});
		}

		/**
   * @param {number} [bitrate] bitrate, defaults to options.bitrate || options.estimatedKbps
   * @return {object} encoding object
   */

	}, {
		key: 'pickEncoding',
		value: function pickEncoding() {
			var bitrate = this.options.bitrate || this.options.estimatedKbps;
			var encodings = this.data.encodings;

			if (!encodings.length) {
				return null;
			}

			// Pick the encoding based on estimated encodings
			var i = void 0;
			for (i = 0; i < encodings.length; i++) {
				if (!encodings[i].videoWidth) {
					continue;
				}
				if (encodings[i].videoKbps + encodings[i].audioKbps > bitrate) {
					break;
				}
			}
			i = Math.max(i - 1, 0);
			return encodings[i];
		}

		/**
   * returns details object defined in "http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/net/NetStreamInfo.html"
   * @return {object} details
   */

	}, {
		key: 'destroyBroadcast',


		/**
   * Destroys the thinflash broadcast
   * @return {void}
   */
		value: function destroyBroadcast() {
			if (this.broadcastId >= 0) {
				if (this.thinBroadcast.destroyBroadcast(this.broadcastId)) {
					this.broadcastId = -1;
				}
			}
		}

		/**
   * Creates the thinflash broadcast
   * @return {void}
   */

	}, {
		key: 'createBroadcast',
		value: function createBroadcast() {
			if (this.broadcastId < 0) {
				this.broadcastId = this.thinBroadcast.createBroadcast();
				// todo: this seems to be an error
				if (!this.broadcastId) {
					this.broadcastId = -1;
					// cb && cb(new Error('???'));
					return;
				}
			}
		}

		/**
   * Connects to the thinflash broadcast
   * @param {object} rtmpSrc RTMP src object for thinflash {prefix: '', video: ''}
   * @return {void}
   */

	}, {
		key: 'connectToBroadcast',
		value: function connectToBroadcast(rtmpSrc, cb) {
			this.thinBroadcast.connectToBroadcast(this.broadcastId, rtmpSrc.prefix, rtmpSrc.video);
			this.once('NetConnection.Connect.Success', cb);
		}

		/**
   * Plays flash through the native Player
   * @param {boolean} [force] force play
   * @param {function} [cb] called after play
   * @return {void}
   */

	}, {
		key: 'play',
		value: function play(inputCb) {
			var _this7 = this;

			var cb = inputCb || _lodash2.default;
			var rtmpSrc = this.rtmpSrc;

			if (!rtmpSrc) {
				if (this.mediaLoader.currentState === _events2.default.ONLINE) {
					this.emit(_events2.default.ERROR, _errors2.default.DRIVER_NOT_SUPPORTED);
				}
				return;
			}

			if (this.destroyed) {
				return;
			}

			this.playing = {
				prefix: rtmpSrc.prefix,
				video: rtmpSrc.video
			};
			this.getReady(function (e) {
				if (!e.success && !_this7.swf) {
					_this7.emit(_events2.default.ERROR, _errors2.default.EMBED_SWF_FAILED);
					return;
				}

				if (_this7.mediaLoader.vod) {
					_this7.emit(_events2.default.ERROR, _errors2.default.DRIVER_NOT_SUPPORTED);
					return;
				}

				_this7.destroyBroadcast();
				_this7.createBroadcast();
				_this7.connectToBroadcast(_this7.playing, function () {
					_logger2.default.setPlayer(_this7.mediaLoader.host, _this7.mediaLoader.publicId, _this7.format, _this7.selectedEncoding.location, _this7);
					_this7.startPlayback();
					_this7.once('progress', function () {
						if (cb) {
							cb(true);
						}
						cb = null;
					});
					setTimeout(function () {
						if (cb) {
							cb(false);
						}
					}, 2000);
					_this7.watchProgress(PROGRESS_CHECK);
				});
			});
		}
	}, {
		key: 'supportsAutoplay',
		get: function get() {
			return true;
		}
	}, {
		key: 'bufferTimes',
		get: function get() {
			return [];
		}
	}, {
		key: 'data',


		/** returns the media loader data
   * @return {string}
   */
		get: function get() {
			return this.mediaLoader.get(this.format);
		}

		/** returns the RTMPSrc
   * @return {string}
   */

	}, {
		key: 'rtmpSrc',
		get: function get() {
			// mess with the location for thinflash contract
			this.selectedEncoding = this.pickEncoding();
			if (!this.selectedEncoding) {
				return null;
			}

			var e = this.selectedEncoding.location.split(/\//);
			var v = e.splice(e.length - 1, 1)[0];
			var p = e.join('/') + '/';

			return {
				prefix: p,
				video: v
			};
		}
	}, {
		key: 'stopped',
		get: function get() {
			return this.isStopped;
		}

		/**
   * @return {void}
   */

	}, {
		key: 'muted',
		get: function get() {
			return this.currentMuted;
		}

		/**
   * @return {void}
   */

	}, {
		key: 'paused',
		get: function get() {
			return this.isStopped();
		}
	}, {
		key: 'volume',
		get: function get() {
			return this.currentVolume;
		}

		/**
   * Set the volume through the video tag
   * @param {number} [volume]
   * @return {number} volume
   */
		,
		set: function set(n) {
			if (!n) {
				return this.currentVolume;
			}
			this.currentVolume = n;
			this.thinPlayback.setVolume(this.broadcastId, n);

			if (this.currentVolume > 0) {
				this.unmute();
			}

			return n;
		}

		/**
   * Switch the bitrate and start playing the video again
   * @param {number} [bitrate]
   * @return {void}
   */

	}, {
		key: 'bitrate',
		set: function set(bitrate) {
			var _this8 = this;

			this.options.bitrate = bitrate;
			this.stop();
			this.play(function (success) {
				if (success) {
					_this8.emit(_events2.default.BITRATE_SWITCH);
				}
			});
		}
	}, {
		key: 'details',
		get: function get() {
			var o = {};

			try {
				if (this.swf && this.swf.tfGetNetStreamProperty && this.broadcastId > 0) {
					o = this.swf.tfGetNetStreamProperty(this.broadcastId, 'info');
				}
			} catch (err) {
				if (this.livelyPlayer.tryingToPlay) {
					this.checkRestart({
						fatal: false,
						reason: 'swf not loaded yet'
					});
				}
			}

			o = o || {};

			o.volume = this.currentVolume;
			o.muted = this.currentMuted;

			return o;
		}
	}], [{
		key: 'isSupported',
		value: function isSupported() {
			return _swfobjectAmd2.default.hasFlashPlayerVersion(MIN_PLAYER_VERSION);
		}
	}, {
		key: 'driver',
		get: function get() {
			return 'flashRtmp';
		}
	}, {
		key: 'format',
		get: function get() {
			return 'mp4-rtmp';
		}
	}]);

	return FlashDriver;
}(_baseDriver2.default);

exports.default = FlashDriver;
},{"./thinflash/broadcast":40,"./thinflash/playback":41,"@livelyvideo/player-core/lib/base-driver":17,"@livelyvideo/player-core/lib/errors":19,"@livelyvideo/player-core/lib/events":20,"@livelyvideo/player-core/lib/logger":23,"lodash.noop":58,"swfobject-amd":61}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _logger = require('@livelyvideo/player-core/lib/logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @file broadcast.js - Provides the interface for handling broadcasts. A broadcast
 * is just a sending or receiving stream of data.
 *
 * This class is used with the mixin pattern to augment the thinflash.flash
 * object, therefore this object should not be created as a standalone object,
 * as none of the references to a logging function or swfFunction will be known.
 */

exports.default = {
	/**
  * Creates a broadcast entry in flash for the given flash object.
  *
  * @return {number|boolean} False if broadcast creation failed, otherwise a valid broadcast ID.
  */
	createBroadcast: function createBroadcast() {
		try {
			return this.getSwf().tfBroadcastCreate();
		} catch (err) {
			_logger2.default.error('broadcast', 'createBroadcast', [], 'error initializing broadcast [err=' + err + ']');
			return false;
		}
	},


	/**
  * Destroys a given broadcast
  *
  * @param {number} broadcastID - The current ID to destroy.
  * @return {boolean} True if no errors, false if something bad happened.
  */
	destroyBroadcast: function destroyBroadcast(broadcastID) {
		try {
			this.getSwf().tfBroadcastDestroy(broadcastID);
		} catch (err) {
			_logger2.default.error('broadcast', 'destroyBroadcast', [broadcastID], 'error destroying broadcast [err=' + err + ']');
			return false;
		}
		return true;
	},


	/**
  * Given a url will link a broadcast to a url or stream
  *
  * @param {number} broadcastID - ID of the broadcast we want to attach the stream to
  * @param {string} url - Location of the video to play
  * @param {string} streamName - Stream name
  * @return {boolean} True if no errors, false if something bad happened.
  */
	connectToBroadcast: function connectToBroadcast(broadcastID, url, streamName) {
		try {
			var _getSwf;

			(_getSwf = this.getSwf()).tfBroadcastConnect.apply(_getSwf, arguments);
		} catch (err) {
			_logger2.default.error('broadcast', 'connectToBroadcast', [broadcastID, url, streamName], 'error connecting to broadcast [err=' + err + ']');
			return false;
		}
		return true;
	}
}; /* eslint-disable */
},{"@livelyvideo/player-core/lib/logger":23}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _logger = require('@livelyvideo/player-core/lib/logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @file playback.js - Provides the interface for manipulating general playback
 * functionality for broadcasts.
 *
 * This class is used with the mixin pattern to augment the thinflash.flash
 * object, therefore this object should not be created as a standalone object,
 * as none of the references to a logging function or swfFunction will be known.
 */

/**
 * Defines the interface for calling ExternalInterface calls in our thinswf.
 */
exports.default = {
	/**
  * Plays a given broadcast
  *
  * @param {number} broadcastID - ID of the broadcast to play
  * @param {object} settings - optional settings
  * @property {string} streamIndex - String index of specific NetStream/Video instance
  * @property {string} name - The name of a recorded file, an identifier for live data
  *												 published by NetStream.publish(), or false.
  * @property {number} start - The start time, in seconds. Allowed values are
  *													-2, -1, 0, or a positive number. (default: -2)
  * @property {number} len - The duration of the playback, in seconds. (default: -1)
  * @property {number} reset - Optional if len is specified. Whether to clear a playlist. (default: 1)
  * @property {Array<object>} dynamicStreams - Array of streams in the following form,
  *																		 for use with DynamicStream / DynamicStreamItem:
  *																		 {name: streamName, bitrate: bitrate}
  * @property {number} startRate - When using DynamicStream, the bitrate of the
  *															stream to play first. (default: -1)
  * @return {boolean} True if no errors, false if something bad happened.
  */
	playbackPlay: function playbackPlay(broadcastID, settings) {
		try {
			this.getSwf().tfPlaybackPlay(broadcastID, settings);
		} catch (err) {
			_logger2.default.error('playback', 'playbackPlay', [broadcastID, settings], 'error playing video [err=' + err + ']');
			return false;
		}
		return true;
	},


	/**
  * Sets the volume for a given broadcast
  *
  * @param {number} broadcastID - ID of the broadcast who's volume to change
  * @param {number} volume - A value between 0 and 1 that preresents no sound and full volume
  * @return {boolean} True if no errors, false if something bad happened.
  */
	setVolume: function setVolume(broadcastID, volume) {
		try {
			this.getSwf().tfPlaybackSetVolume(broadcastID, volume);
		} catch (err) {
			_logger2.default.error('playback', 'setVolume', [broadcastID, volume], 'error setting volume [err=' + err + ']');
			return false;
		}
		return true;
	},


	/**
  * Mutes the audio for a given broadcast
  *
  * @param {number} broadcastID - ID of the broadcast to mute
  * @param {boolean} toggle - true for muted, false for not
  * @return {boolean} True if no errors, false if something bad happened.
  */
	muteAudio: function muteAudio(broadcastID, toggle) {
		try {
			this.getSwf().tfPlaybackMute(broadcastID, toggle);
		} catch (err) {
			_logger2.default.error('playback', 'muteAudio', [broadcastID, toggle], 'error muting audio [err=' + err + ']');
			return false;
		}
		return true;
	},


	/**
  * Returns value of any accessible NetStream property.
  *
  * @param {number} broadcastID - ID of the broadcast
  * @param {string} propertyName - The name of the property in NetStream
  * @return {boolean} value for specified property, if successfully read
  */
	getNetStreamProperty: function getNetStreamProperty(broadcastID, propertyName) {
		try {
			return this.getSwf().tfGetNetStreamProperty(broadcastID, propertyName);
		} catch (err) {
			_logger2.default.error('playback', 'getNetStreamProperty', [broadcastID, propertyName], 'error getting NetStream property [err=' + err + ']');
			return false;
		}
	}
}; /* eslint-disable */
},{"@livelyvideo/player-core/lib/logger":23}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint-disable */

/*
 *
 * from https://github.com/dailymotion/hls.js/blob/master/src/controller/abr-controller.js
 * slightly modified to store the last 50 bandwidth samples and minorly adjust them
 * consider rewriting to simplify
 *
 * simple ABR Controller
 *	- compute next level based on last fragment bw heuristics
 *	- implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
 */

var BW_LENGTH = 8;

var AbrController = function () {
	function AbrController(hls) {
		_classCallCheck(this, AbrController);

		hls.on(window.Hls.Events.FRAG_LOADING, this.onFragLoading.bind(this));
		hls.on(window.Hls.Events.FRAG_LOAD_PROGRESS, this.onFragLoadProgress.bind(this));
		hls.on(window.Hls.Events.FRAG_LOADED, this.onFragLoaded.bind(this));
		hls.on(window.Hls.Events.ERROR, this.onError.bind(this));

		this.lastLoadedFragLevel = 0;
		this._autoLevelCapping = -1;
		this._nextAutoLevel = -1;
		this.hls = hls;

		this.onCheck = this.checkFragProgress.bind(this);
		this.lastBws = [];
		this.lastBw = 0;
		this.lastCalculated = 0;
	}

	_createClass(AbrController, [{
		key: "getCurrentLevel",
		value: function getCurrentLevel() {
			return this.fragCurrent;
		}
	}, {
		key: "getNextLevel",
		value: function getNextLevel() {
			return this.nextAutoLevel;
		}
	}, {
		key: "destroy",
		value: function destroy() {
			this.clearTimer();
		}
	}, {
		key: "onFragLoading",
		value: function onFragLoading(ev, data) {
			this.clearTimer(this.timer);
			this.timer = setInterval(this.onCheck, 100);
			this.fragCurrent = data.frag;
		}
	}, {
		key: "calculateLastBw",
		value: function calculateLastBw() {
			this.lastCalculated = Date.now();
			this.lastBws.splice(BW_LENGTH);

			var lastBw = 0;
			for (var i = 0; i < this.lastBws.length; i++) {
				lastBw += this.lastBws[i];
			}
			lastBw = Math.floor(lastBw / this.lastBws.length);
			this.lastBw = lastBw;
		}
	}, {
		key: "addBw",
		value: function addBw(bw) {
			this.lastBws.unshift(bw);
			this.calculateLastBw();
		}
	}, {
		key: "onFragLoadProgress",
		value: function onFragLoadProgress(ev, data) {
			if (this.lastBws.length > BW_LENGTH / 2) {
				return;
			}
			this.lastfetchduration = (window.performance.now() - data.stats.trequest) / 1000;
			var bw = data.stats.loaded * 8 / this.lastfetchduration;
			if (bw) {
				this.addBw(bw);
			}
		}
	}, {
		key: "bufferedInfo",
		value: function bufferedInfo(buffered, pos, maxHoleDuration) {
			var buffered2 = [];
			var bufferLen = void 0;
			var bufferStart = void 0;
			var bufferEnd = void 0;
			var bufferStartNext = void 0;
			var i = void 0;

			// sort on buffer.start/smaller end (IE does not always return sorted buffered range)
			buffered.sort(function (a, b) {
				var diff = a.start - b.start;
				if (diff) {
					return diff;
				}
				return b.end - a.end;
			});

			// there might be some small holes between buffer time range
			// consider that holes smaller than maxHoleDuration are irrelevant and build another
			// buffer time range representations that discards those holes
			for (i = 0; i < buffered.length; i++) {
				var buf2len = buffered2.length;
				if (buf2len) {
					var buf2end = buffered2[buf2len - 1].end;
					// if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
					if (buffered[i].start - buf2end < maxHoleDuration) {
						// merge overlapping time ranges
						// update lastRange.end only if smaller than item.end
						// e.g.	[ 1, 15] with	[ 2,8] => [ 1,15] (no need to modify lastRange.end)
						// whereas [ 1, 8] with	[ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
						if (buffered[i].end > buf2end) {
							buffered2[buf2len - 1].end = buffered[i].end;
						}
					} else {
						// big hole
						buffered2.push(buffered[i]);
					}
				} else {
					// first value
					buffered2.push(buffered[i]);
				}
			}

			// in case current position is located before buffered time ranges, report area as not buffered
			if (buffered2.length && pos < buffered2[0].start) {
				return {
					len: 0,
					start: pos,
					end: pos,
					nextStart: buffered2[0].start
				};
			}

			for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {
				var start = buffered2[i].start;
				var end = buffered2[i].end;

				// logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
				if (pos + maxHoleDuration >= start && pos < end) {
					// play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
					bufferStart = start;
					bufferEnd = end;
					bufferLen = bufferEnd - pos;
				} else if (pos + maxHoleDuration < start) {
					bufferStartNext = start;
					break;
				}
			}
			return {
				len: bufferLen,
				start: bufferStart,
				end: bufferEnd,
				nextStart: bufferStartNext
			};
		}
	}, {
		key: "bufferInfo",
		value: function bufferInfo(media, pos, maxHoleDuration) {
			if (media) {
				var vbuffered = media.buffered;
				var buffered = [];
				var i = void 0;

				for (i = 0; i < vbuffered.length; i++) {
					buffered.push({
						start: vbuffered.start(i),
						end: vbuffered.end(i)
					});
				}

				return this.bufferedInfo(buffered, pos, maxHoleDuration);
			}

			return {
				len: 0,
				start: 0,
				end: 0,
				nextStart: undefined
			};
		}
	}, {
		key: "checkFragProgress",
		value: function checkFragProgress() {
			/** monitor fragment retrieval time...
    * we compute expected time of arrival of the complete fragment.
    * we compare it to expected time of buffer starvation
    */
			var hls = this.hls;
			var v = hls.media;
			var frag = this.fragCurrent;

			/* only monitor frag retrieval time if
   (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */
			if (!v || v.paused || !v.readyState) {
				return;
			}

			if (!frag.autoLevel || !frag.level) {
				return;
			}

			// monitor fragment load progress after half of expected fragment duration,to stabilize bitrate
			var requestDelay = window.performance.now() - frag.trequest;
			if (requestDelay <= 500 * frag.duration) {
				return;
			}

			var loadRate = Math.max(1, frag.loaded * 1000 / requestDelay); // byte/s; at least 1 byte/s to avoid division by zero
			if (frag.expectedLen < frag.loaded) {
				frag.expectedLen = frag.loaded;
			}
			var pos = v.currentTime;
			var fragLoadedDelay = (frag.expectedLen - frag.loaded) / loadRate;
			var bufferStarvationDelay = this.bufferInfo(v, pos, hls.config.maxBufferHole).end - pos;

			// consider emergency switch down only if we have less than 2 frag buffered AND
			// time to finish loading current fragment is bigger than buffer starvation delay
			// ie if we risk buffer starvation if bw does not increase quickly
			if (4 * bufferStarvationDelay < frag.duration && fragLoadedDelay > bufferStarvationDelay) {
				var fragLevelNextLoadedDelay = void 0,
				    nextLoadLevel = void 0;
				// lets iterate through lower level and try to find the biggest one that could avoid rebuffering
				// we start from current level - 1 and we step down , until we find a matching level
				for (nextLoadLevel = frag.level - 1; nextLoadLevel >= 0; nextLoadLevel--) {
					// compute time to load next fragment at lower level
					// 0.7 : consider only 80% of current bw to be conservative
					// 8 = bits per byte (bps/Bps)
					fragLevelNextLoadedDelay = frag.duration * hls.levels[nextLoadLevel].bitrate / (8 * 0.7 * loadRate);
					// logger.log(`fragLoadedDelay/bufferStarvationDelay/fragLevelNextLoadedDelay[${nextLoadLevel}] :${fragLoadedDelay.toFixed(1)}/${bufferStarvationDelay.toFixed(1)}/${fragLevelNextLoadedDelay.toFixed(1)}`);
					if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
						// we found a lower level that be rebuffering free with current estimated bw !
						break;
					}
				}
				// only emergency switch down if it takes less time to load new fragment at lowest level instead
				// of finishing loading current one ...
				if (fragLevelNextLoadedDelay < fragLoadedDelay) {
					// ensure nextLoadLevel is not negative
					nextLoadLevel = Math.max(0, nextLoadLevel);
					// force next load level in auto mode
					hls.nextLoadLevel = nextLoadLevel || 0;
					// abort fragment loading ...
					// logger.warn(`loading too slow, abort fragment loading and switch to level ${nextLoadLevel}`);
					// abort fragment loading
					frag.loader.abort();
					this.clearTimer();
					hls.trigger(window.Hls.Events.FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag });
				}
			}
		}
	}, {
		key: "emergencyDrop",
		value: function emergencyDrop() {
			this.hls.nextLoadLevel = Math.max(0, this.fragCurrent.level - 1) || 0;
			if (this.hls.nextLoadLevel >= this.fragCurrent.level) {
				return;
			}
			this.clearTimer();
			this.hls.trigger(window.Hls.Events.FRAG_LOAD_EMERGENCY_ABORTED, {
				frag: this.fragCurrent
			});
		}
	}, {
		key: "onFragLoaded",
		value: function onFragLoaded(ev, data) {
			this.lastfetchduration = (window.performance.now() - data.stats.trequest) / 1000;
			var bw = data.stats.loaded * 8 / this.lastfetchduration;
			if (bw) {
				this.addBw(bw);
			}
			// stop monitoring bw once frag loaded
			this.clearTimer();
			// store level id after successful fragment load
			this.lastLoadedFragLevel = data.frag.level;
			// reset forced auto level value so that next level will be selected
			this._nextAutoLevel = -1;
		}
	}, {
		key: "onError",
		value: function onError(ev, data) {
			// stop timer in case of frag loading error
			// switch (data.details) {
			// case window.Hls.ErrorDetails.FRAG_LOAD_ERROR:
			// case window.Hls.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
			// case window.Hls.ErrorDetails.FRAG_LOAD_TIMEOUT:
			// case window.Hls.ErrorDetails.FRAG_DECRYPT_ERROR:
			// case window.Hls.ErrorDetails.FRAG_PARSING_ERROR:
			// case window.Hls.ErrorDetails.BUFFER_APPENDING_ERROR:
			// case window.Hls.ErrorDetails.BUFFER_STALLED_ERROR:
			// 	this.emergencyDrop();
			// 	break;
			// default:
			// 	break;
			// }
			this.clearTimer();
		}
	}, {
		key: "clearTimer",
		value: function clearTimer() {
			if (this.timer) {
				clearInterval(this.timer);
				this.timer = null;
			}
		}

		/** Return the capping/max level value that could be used by automatic level selection algorithm **/

	}, {
		key: "autoLevelCapping",
		get: function get() {
			return this._autoLevelCapping;
		}

		/** set the capping/max level value that could be used by automatic level selection algorithm **/
		,
		set: function set(newLevel) {
			this._autoLevelCapping = newLevel;
		}
	}, {
		key: "nextAutoLevel",
		get: function get() {
			var lastBw = this.lastBw;
			var hls = this.hls;
			var adjustedbw = void 0;
			var i = void 0;
			var maxAutoLevel = void 0;

			if (!hls.levels) {
				return -1;
			}

			if (this._autoLevelCapping === -1 && hls.levels) {
				maxAutoLevel = hls.levels.length - 1;
			} else {
				return Math.min(this._autoLevelCapping, hls.levels.length - 1);
			}

			if (this._nextAutoLevel !== -1) {
				return Math.min(this._nextAutoLevel, maxAutoLevel, hls.levels.length - 1);
			}

			for (i = 0; i <= maxAutoLevel; i++) {
				adjustedbw = 0.70 * lastBw;

				if (adjustedbw < hls.levels[i].bitrate) {
					return Math.max(0, i - 1);
				}
			}
			return i - 1;
		},
		set: function set(nextLevel) {
			this._nextAutoLevel = nextLevel;
		}
	}]);

	return AbrController;
}();

exports.default = AbrController;
},{}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _baseDriver = require('@livelyvideo/player-core/lib/base-driver');

var _baseDriver2 = _interopRequireDefault(_baseDriver);

var _detect = require('@livelyvideo/player-core/lib/detect');

var _detect2 = _interopRequireDefault(_detect);

var _logger = require('@livelyvideo/player-core/lib/logger');

var _logger2 = _interopRequireDefault(_logger);

var _events = require('@livelyvideo/player-core/lib/events');

var _events2 = _interopRequireDefault(_events);

var _errors = require('@livelyvideo/player-core/lib/errors');

var _errors2 = _interopRequireDefault(_errors);

var _lodash = require('lodash.noop');

var _lodash2 = _interopRequireDefault(_lodash);

var _abrController = require('./abr-controller');

var _abrController2 = _interopRequireDefault(_abrController);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HLS_SCRIPT_SPIN = 50;
var SKIP_FORWARD_THRESHOLD = 25;

var Hls = window.Hls;
var HlsPath = function getHlsPath() {
	var scripts = document.getElementsByTagName('script');
	var path = scripts[scripts.length - 1].src.split('?')[0];
	return path.split('/').slice(0, -1).join('/') + '/hls.min.js';
}();

/**
 * @class Interface to the dailymotion hls player https://github.com/dailymotion/hls.js/tree/master
 */

var HlsJsDriver = function (_BaseDriver) {
	_inherits(HlsJsDriver, _BaseDriver);

	/**
  * @param {object} livelyPlayer Lively video object
  * @param {object} mediaLoader media loader object
  * @param {object[]} [options]
  * @param {number} [options[].bitrate] attempts to find and use the bitrate nearest to this value
  * @param {number} [options[].volume] [0.75] 0-1 volume
  * @param {number} [options[].maxBufferLength] [30s]
  * @param {number} [options[]. maxBufferSize]	[60mb]
  * @param {bool} [options[].muted] whether or not the driver is muted
  * @param {bool} [options[].debug] [false] enables debug logging
  * @return {void}
  */
	function HlsJsDriver(livelyPlayer, mediaLoader, options) {
		_classCallCheck(this, HlsJsDriver);

		var _this = _possibleConstructorReturn(this, (HlsJsDriver.__proto__ || Object.getPrototypeOf(HlsJsDriver)).call(this, livelyPlayer, mediaLoader, options));

		_this.el = document.createElement('video');
		_this.el.setAttribute('class', 'aiw-video');

		if (_this.options.posterURI) {
			_this.el.setAttribute('poster', _this.options.posterURI);
		}

		_this.livelyPlayer.el.appendChild(_this.el);
		_this.el.volume = _this.options.volume;
		_this.el.muted = _this.options.muted;

		_this.options.hlsjsPath = _this.options.hlsjsPath || HlsPath;
		_this.lastFrag = null;
		_this.loadingHls = false;
		_this.recoverDecodingErrorDate = null;
		_this.recoverSwapAudioCodecDate = null;
		_this.loadHls();
		_this.currentLevelInterval = setTimeout(_this.saveCurrentLevel.bind(_this), 1000);
		return _this;
	}

	_createClass(HlsJsDriver, [{
		key: 'saveCurrentLevel',
		value: function saveCurrentLevel() {
			var c = this.currentLevel;

			if (c) {
				var encoding = this.data.encodings[c];
				this.livelyPlayer.store.set('lv_auto_last_kbps', encoding.audioKbps + encoding.videoKbps);
			}
		}
	}, {
		key: 'reloadAndRestart',
		value: function reloadAndRestart() {
			var _this2 = this;

			this.mediaLoader.load(function () {
				if (_this2.mediaLoader.currentState === _events2.default.ONLINE) {
					_this2.restart();
				}
			});
		}
	}, {
		key: 'loadHls',
		value: function loadHls(inputCb) {
			var _this3 = this;

			var cb = inputCb || _lodash2.default;
			// Add a timeout
			if (Hls) {
				cb();
				return;
			}

			if (this.loadingHls) {
				setTimeout(function () {
					_this3.loadHls(cb);
				}, HLS_SCRIPT_SPIN);
				return;
			}

			this.loadingHls = true;
			var script = document.createElement('script');
			script.setAttribute('src', this.options.hlsjsPath);
			script.onload = function () {
				Hls = window.Hls;
				_this3.loadingHls = false;
				cb();
			};
			document.body.appendChild(script);
		}
	}, {
		key: 'whenReady',
		value: function whenReady(cb) {
			var _this4 = this;

			this.loadHls(function () {
				_get(HlsJsDriver.prototype.__proto__ || Object.getPrototypeOf(HlsJsDriver.prototype), 'whenReady', _this4).call(_this4, cb);
			});
		}
	}, {
		key: 'playNow',
		value: function playNow(inputCb) {
			var _this5 = this;

			var m = this.manifest;

			var cb = inputCb || _lodash2.default;

			if (!m && this.mediaLoader.currentState === _events2.default.ONLINE) {
				this.emit(_events2.default.ERROR, _errors2.default.DRIVER_NOT_SUPPORTED);
				return;
			}

			if (this.hls) {
				if (this.mediaLoader.vod && m === this.hls.url || this.hls.url === m) {
					this.elementPlay();
					cb(true);
					return;
				}

				this.destroyHls();
			}

			this.el.setAttribute('src', m);
			var startIt = function startIt() {
				_this5.hls = new Hls({
					abrController: _abrController2.default,
					seekHoleNudgeDuration: 0.5,
					debug: _this5.options.debug,
					maxBufferLength: _this5.options.maxBufferLength,
					maxBufferSize: _this5.options.maxBufferSize,
					fragLoadingTimeOut: 3900
				});

				_this5.listen();
				_logger2.default.setPlayer(_this5.mediaLoader.host, _this5.mediaLoader.publicId, _this5.format, m);
				_this5.hls.loadSource(m);
				_this5.hls.attachMedia(_this5.el);
				_this5.elementPlay();

				if (!_this5.mediaLoader.vod) {
					_this5.hls.on(Hls.Events.BUFFER_APPENDED, function () {
						if (!_this5.el || !_this5.el.buffered.length || _this5.el.paused) {
							return;
						}
						if (_this5.el.buffered.end(_this5.el.buffered.length - 1) - _this5.el.currentTime > SKIP_FORWARD_THRESHOLD) {
							_logger2.default.error('player fell behind more than ' + SKIP_FORWARD_THRESHOLD + 's, restarting');
							_this5.reloadAndRestart();
						}
					});
				}

				_this5.hls.on(Hls.Events.MEDIA_ATTACHED, function () {
					_this5.isAttached = true;
				});

				_this5.hls.on(Hls.Events.MEDIA_DETACHED, function () {
					_this5.isAttached = false;
				});

				_this5.hls.on(Hls.Events.MANIFEST_PARSED, function () {
					_this5.lastProgress = Date.now();
				});

				if (_this5.options.bitrate === null) {
					_this5.bitrateCap = null;
				} else if (!isNaN(_this5.options.bitrate)) {
					_this5.bitrateCap = _this5.options.bitrate;
				}
			};

			if (document.hidden) {
				document.addEventListener('visibilitychange', startIt);
			} else {
				startIt();
			}

			cb(true);
		}

		/**
   * Attaches the hls video player and plays the video
   * @param {function} [cb] called on play
   * @return {void}
   */

	}, {
		key: 'play',
		value: function play(cb) {
			var _this6 = this;

			if (this.hls && !this.el.paused) {
				return;
			}
			this.el.onprogress = null;

			if (this.ready) {
				this.playNow(cb);
				return;
			}
			this.whenReady(function () {
				_this6.playNow(cb);
			});
		}
	}, {
		key: 'stop',


		/**
   * stops playback
   * @return {void}
   */
		value: function stop() {
			if (!this.hls) {
				return;
			}
			this.hls.destroy();
		}

		/**
   * stops playback
   * @return {void}
   */

	}, {
		key: 'pause',
		value: function pause() {
			this.el.pause();
		}

		/**
   * Destroys driver
   * @return {void}
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			this.destroyed = true;
			this.el.remove();
			if (this.hls) {
				this.destroyHls();
			}
		}

		/**
   * Destroys HLS Driver
   */

	}, {
		key: 'destroyHls',
		value: function destroyHls() {
			if (this.hls.detachMedia) {
				this.hls.detachMedia();
			}

			if (this.hls.destroy) {
				this.hls.destroy();
			}

			this.hls = null;
		}
	}, {
		key: 'recoverFromBufferSeekOverHole',
		value: function recoverFromBufferSeekOverHole() {
			var encodings = this.data.encodings;
			var e = encodings[this.currentLevel];
			if (!e) {
				e = this.pickEncoding(this.options.bitrate || this.options.estimatedKbps);
			}
			if (e) {
				this.options.bitrate = e.videoKbps + e.audioKbps;
			}
			this.reloadAndRestart();
		}
	}, {
		key: 'ifNoProgress',
		value: function ifNoProgress(cb) {
			var _this7 = this;

			var ct = this.el.currentTime;
			setTimeout(function () {
				if (_this7.el.currentTime <= ct) {
					cb();
				}
			}, 250);
		}

		/**
   * Listen for important events and record or signal
   */

	}, {
		key: 'listen',
		value: function listen() {
			var _this8 = this;

			var ct = void 0;
			this.hls.on(Hls.Events.ERROR, function (type, data) {
				switch (data.details) {
					case Hls.ErrorDetails.LEVEL_LOAD_ERROR:
					case Hls.ErrorDetails.FRAG_LOAD_TIMEOUT:
						if (_this8.mediaLoader.vod) {
							_this8.handleError(_events2.default.ERROR, _errors2.default.PLAYBACK_ERROR, data);
							return;
						}

						if (_this8.mediaLoader.currentState === _events2.default.OFFLINE) {
							_this8.stop();
							return;
						}
						_logger2.default.warn('level load reload and restart', type, data);
						_this8.reloadAndRestart();

						ct = _this8.el.currentTime;
						setTimeout(function () {
							if (_this8.el.currentTime <= ct) {
								_logger2.default.warn('level load reload and restart', type, data);
								_this8.reloadAndRestart();
							}
						}, 100);
						return;
					case Hls.ErrorDetails.BUFFER_SEEK_OVER_HOLE:
						_this8.ifNoProgress(function () {
							_this8.recoverFromBufferSeekOverHole();
						});
						return;
					case Hls.ErrorDetails.BUFFER_APPEND_ERROR:
					case Hls.ErrorDetails.BUFFER_FULL_ERROR:
						_this8.bufferOverflowCount++;
						break;
					case Hls.ErrorDetails.FRAG_LOAD_ERROR:
					case Hls.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
					case Hls.ErrorDetails.FRAG_DECRYPT_ERROR:
					case Hls.ErrorDetails.FRAG_PARSING_ERROR:
					case Hls.ErrorDetails.BUFFER_APPENDING_ERROR:
					case Hls.ErrorDetails.BUFFER_STALLED_ERROR:
						_this8.bufferUnderflowCount++;
						break;
					default:
						break;
				}

				switch (data.type) {
					case Hls.ErrorTypes.NETWORK_ERROR:
						// Everything but frag timeout errors, manifest errors, etc
						// the player is busted and needs to retry
						// either rely on the retry protocol of the hls driver,
						// or just hard restart it
						// for live it seems the same either way
						if (data.details !== Hls.ErrorDetails.FRAG_LOAD_TIMEOUT) {
							_this8.currentErrorCount++;
						} else if (data.details === Hls.ErrorDetails.LEVEL_LOAD_TIMEOUT) {
							_this8.currentErrorCount = _this8.options.recoverErrorCount;
						}

						_this8.handleError(_events2.default.ERROR, _errors2.default.NETWORK_ERROR, data);
						break;
					case Hls.ErrorTypes.MEDIA_ERROR:
						if (data.fatal) {
							_this8.handleMediaError();
							return;
						}
						// don't add to current error count for buffer stalls
						if (data.details === Hls.ErrorDetails.BUFFER_STALLED_ERROR) {
							_this8.handleError(_events2.default.ERROR, _errors2.default.PLAYBACK_ERROR, data);
							return;
						}
						if (data.details === Hls.ErrorDetails.FRAG_LOOP_LOADING_ERROR) {
							// Its caused when the client sees the same segment multiple times
							// when the manifest file is being loaded several times,
							// each seem to spawn segment loads
							// many segment loads then compete and cause these errors
							// its probably just an indicator of a screwed state
							// Tracking it and reloading after a recovery count
							_this8.currentErrorCount++;
						}

						_this8.handleError(_events2.default.ERROR, _errors2.default.PLAYBACK_ERROR, data);
						break;
					case Hls.ErrorTypes.OTHER_ERROR:
						_this8.currentErrorCount++;
						_this8.handleError(_events2.default.ERROR, _errors2.default.UNKNOWN_ERROR, data);
						break;
					default:
						_logger2.default.error('unhandled hlsjs error', type, data);
						return;
				}

				_this8.checkRestart(data);
				_logger2.default.error(type, data);
			});

			this.el.addEventListener('progress', function () {
				_this8.emitProgress();
			});

			this.el.onended = function () {
				_this8.emit('ended');
			};

			this.el.addEventListener('timeupdate', function () {
				_this8.emitTimeupdate();
			});

			this.el.addEventListener('error', function (e) {
				var err = e.currentTarget.error;

				if (!err) {
					return;
				}

				switch (err.code) {
					case err.MEDIA_ERR_DECODE:
						_this8.handleMediaError();
						break;
					case err.MEDIA_ERR_SRC_NOT_SUPPORTED:
						_this8.emit(_events2.default.ERROR, _errors2.default.DRIVER_NOT_SUPPORTED);
						break;
					default:
						break;
				}
			});

			this.hls.on(Hls.Events.LEVEL_SWITCH, function (e, data) {
				_this8.bitrateSwitch(data.level);
			});

			this.hls.on(Hls.Events.FRAG_LOADED, function (e, data) {
				_this8.loadedFrag(data.frag);
			});
		}
	}, {
		key: 'handleMediaError',
		value: function handleMediaError() {
			var _this9 = this;

			var now = window.performance.now();

			if (!this.recoverDecodingErrorDate || now - this.recoverDecodingErrorDate > 3000) {
				this.recoverDecodingErrorDate = now;
				this.hls.recoverMediaError();
			} else if (!this.recoverSwapAudioCodecDate || now - this.recoverSwapAudioCodecDate > 3000) {
				this.recoverSwapAudioCodecDate = now;
				this.hls.swapAudioCodec();
				this.hls.recoverMediaError();
			}

			this.ifNoProgress(function () {
				_this9.recoverFromBufferSeekOverHole();
			});
		}
	}, {
		key: 'bitrateSwitch',
		value: function bitrateSwitch(level) {
			if (level > this.currentLevel) {
				this.upshift++;
			} else {
				this.downshift++;
			}

			this.emit(_events2.default.BITRATE_SWITCH);
		}
	}, {
		key: 'loadedFrag',
		value: function loadedFrag(inputFrag) {
			var frag = inputFrag;
			this.fragCounts++;
			frag.request = this.lastFrag ? frag.trequest - this.lastFrag.trequest : frag.trequest;
			this.lastFrag = frag;
			this.fragSize += frag.loaded;
			this.fragDuration += frag.duration;
			this.fragDownloadTime += frag.request;
			this.fragMaxTime = Math.max(this.fragMaxTime, frag.request);
			this.fragMinTime = Math.min(this.fragMinTime || frag.request, frag.request);
		}
	}, {
		key: 'ready',
		get: function get() {
			return Hls && this.manifest;
		}

		/** returns the manifest string
   * @return {string}
   */

	}, {
		key: 'manifest',
		get: function get() {
			var d = this.data;

			if (this.options.origin) {
				return this.originLocation;
			}

			uri = d.manifest;

			if (!this.options.origin && !d.encodings.length) {
				this.options.origin = true;
				return this.originLocation;
			}

			var uri = void 0;
			uri = d.manifest;

			if (!this.options.origin && !d.encodings.length) {
				this.options.origin = true;
				return this.originLocation;
			}

			if (!uri) {
				return null;
			}

			var separator = uri.indexOf('?') === -1 ? '?' : '&';

			if (this.options.preset === null) {
				uri += separator;
			} else if (this.options.preset) {
				uri += separator + 'preset=' + this.options.preset;
			} else if (!_detect2.default.any()) {
				uri += separator + 'preset=desktop';
			}

			var lastAutoKbps = this.livelyPlayer.store.get('lv_auto_last_kbps');
			if (lastAutoKbps) {
				uri += 'kbps=' + lastAutoKbps;
			}

			return uri;
		}

		/** Returns t/f if the hlsjs driver is supported
   * @return {boolean}
   */

	}, {
		key: 'bitrateCap',
		set: function set(bitrate) {
			this.options.bitrate = bitrate;
			if (!bitrate) {
				this.hls.abrController.autoLevelCapping = -1;
				this.emit(_events2.default.MEDIA_PLAY);
				return;
			}
			var encodings = this.data.encodings;

			if (!encodings || !encodings.length || !this.hls) {
				return;
			}

			var i = void 0;
			for (i = 0; i < encodings.length; i++) {
				if (encodings[i].videoKbps + encodings[i].audioKbps > bitrate) {
					break;
				}
			}
			this.hls.abrController.autoLevelCapping = Math.max(i - 1, 0);
			this.emit(_events2.default.MEDIA_PLAY);
		}

		/**
   * @param {number} bitrate
   * @return {void}
   */

	}, {
		key: 'bitrate',
		set: function set(bitrate) {
			var _this10 = this;

			this.bitrateCap = bitrate;
			if (_detect2.default.firefox() || this.mediaLoader.vod) {
				var ct = this.el.currentTime;
				this.stop();
				if (!this.livelyPlayer.tryingToPlay) {
					if (this.mediaLoader.vod) {
						this.el.currentTime = ct;
					}
					return;
				}

				if (this.mediaLoader.vod) {
					this.el.onloadedmetadata = function () {
						_this10.el.onloadedmetadata = null;
						_this10.el.currentTime = ct;
					};
				}
				this.play();
			}
		}
	}, {
		key: 'currentLevel',
		get: function get() {
			if (!this.hls) {
				return undefined;
			}
			if (!this.hls.abrController.fragCurrent) {
				return undefined;
			}
			return this.hls.abrController.fragCurrent.level;
		}
	}, {
		key: 'nextLevel',
		get: function get() {
			if (!this.hls) {
				return null;
			}
			return this.hls.abrController.nextAutoLevel;
		}
	}], [{
		key: 'isSupported',
		value: function isSupported() {
			// win chrome 51 and below have a bug in mse causing black screens on bitrate switches
			if (_detect2.default.winChrome51()) {
				return false;
			}

			// disable safari, native hls performs better -- this is because there is no OS preference list
			if (_detect2.default.safari() && !_detect2.default.android() && !_detect2.default.chrome() && !_detect2.default.ie()) {
				return false;
			}

			// This is directly copied from the hls library so that the library can be dynamically loaded in
			return window.MediaSource && window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
		}
	}, {
		key: 'driver',
		get: function get() {
			return 'hlsjs';
		}
	}, {
		key: 'format',
		get: function get() {
			return 'mp4-hls';
		}
	}]);

	return HlsJsDriver;
}(_baseDriver2.default);

exports.default = HlsJsDriver;
},{"./abr-controller":42,"@livelyvideo/player-core/lib/base-driver":17,"@livelyvideo/player-core/lib/detect":18,"@livelyvideo/player-core/lib/errors":19,"@livelyvideo/player-core/lib/events":20,"@livelyvideo/player-core/lib/logger":23,"lodash.noop":58}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _logger = require('@livelyvideo/player-core/lib/logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable no-param-reassign */


// TODO: emergency drop

var SAMPLE_SIZE = 300; // sample size for estimating bandwidth
var RECENT_KBPS = 120;
var PROFILE_INTERVAL = 10000;
var RECENT_KBPS_INTERVAL = 1000;
var MAX_BW_ESTIMATE = 50000 * 8;
var BASE_SWITCH_THRESHOLD = 60 * 1000 * 5; // 8 * 1000; // 8 seconds
var MIN_SIZE = 2000; // minimum size to use in estimated bw
var MIN_MS_TIME = 2; // minimum required ms download time
var IGNORE = 0;
var MIN_SAMPLE_SIZE = 25;
var EMERGENCY_RELEASE = 900;

var profileTypes = {
	stable: {
		key: 'stable',
		bwModifier: function bwModifier(bytes) {
			var b = Math.min(bytes, bytes - (bytes * 0.01 + Math.log(bytes * bytes) / Math.log(2)));
			return b;
		},
		resistUpshift: function resistUpshift(kbps, encodingKbps) {
			return encodingKbps * 2.5 + Math.pow(Math.log(encodingKbps * 2), 3.2) > kbps * 2;
		},
		resistDownshift: function resistDownshift(kbps, encodingKbps) {
			return kbps * 2 + Math.pow(Math.log(kbps * 2), 3.2) > encodingKbps * 2;
		}
	},

	normal: {
		key: 'normal',
		bwModifier: function bwModifier(bytes) {
			var b = Math.min(bytes, bytes - (bytes * 0.06 + Math.log(bytes * bytes) / Math.log(2)));
			return b;
		},
		resistUpshift: function resistUpshift(kbps, encodingKbps) {
			return encodingKbps * 2.5 + Math.pow(Math.log(encodingKbps * 2), 3.4) > kbps * 2;
		},
		resistDownshift: function resistDownshift(kbps, encodingKbps) {
			return kbps * 2 + Math.pow(Math.log(kbps * 2), 3.4) > encodingKbps * 2;
		}
	},

	uncertain: {
		key: 'uncertain',
		bwModifier: function bwModifier(bytes) {
			var b = Math.min(bytes, bytes - (bytes * 0.3 + Math.log(bytes * bytes) / Math.log(2)));
			return b;
		},
		resistUpshift: function resistUpshift(kbps, encodingKbps) {
			return encodingKbps * 2.5 + Math.pow(Math.log(encodingKbps * 2), 3.6) > kbps * 2;
		},
		resistDownshift: function resistDownshift(kbps, encodingKbps) {
			return kbps * 2 + Math.pow(Math.log(kbps * 2), 3.4) > encodingKbps * 2;
		}
	},

	sporadic: {
		key: 'sporadic',
		bwModifier: function bwModifier(bytes) {
			var b = Math.min(bytes, bytes - (bytes * 0.5 + Math.log(bytes * bytes) / Math.log(2)));
			return b;
		},
		resistUpshift: function resistUpshift(kbps, encodingKbps) {
			return encodingKbps * 2.5 + Math.pow(Math.log(encodingKbps * 2), 4) > kbps * 2;
		},
		resistDownshift: function resistDownshift(kbps, encodingKbps) {
			return kbps * 2 + Math.pow(Math.log(kbps * 2), 3.4) > encodingKbps * 2;
		}
	}
};

var AbrController = function (_EventEmitter) {
	_inherits(AbrController, _EventEmitter);

	function AbrController(player, driver, profile, switchImmediately, maxShifts) {
		_classCallCheck(this, AbrController);

		var _this = _possibleConstructorReturn(this, (AbrController.__proto__ || Object.getPrototypeOf(AbrController)).call(this));

		_this.player = player;
		_this.driver = driver;
		_this.switchImmediately = switchImmediately;
		_this.switchThreshold = BASE_SWITCH_THRESHOLD;
		_this.count = 0;
		_this.dropCount = 0;
		_this.totalShifts = 0;
		_this.profile = profileTypes[profile] || profileTypes.normal;
		_this.maxShifts = maxShifts || Infinity;
		_this.currentKbps = driver.options.bitrate || Math.max(driver.options.estimatedKbps, 244);
		_this.rawKbps = [];
		_this.recentKbps = [];
		_this.sampleBws = [];
		_this.selectedEncoding = null;
		_this.lastMessageTime = window.performance.now();
		_this.lastSwitch = -1 * BASE_SWITCH_THRESHOLD;

		_this.emergencyModifier = 1;
		_this.releaseEmergencyTimeout = null;

		_this.init();
		return _this;
	}

	_createClass(AbrController, [{
		key: 'updateTransport',
		value: function updateTransport() {
			this.player.removeListener('fragment', this.onMessage);
			this.player.on('fragment', this.onMessage.bind(this));
		}
	}, {
		key: 'init',
		value: function init() {
			var _this2 = this;

			this.player.on('fragment', this.onMessage.bind(this));
			this.profileInterval = setInterval(this.profileStream.bind(this), PROFILE_INTERVAL);
			this.trackRecentKbpsInterval = setInterval(function () {
				var total = 0;
				for (var i = 0; i < _this2.rawKbps.length; i++) {
					total += _this2.rawKbps[i];
				}
				var sample = total / _this2.rawKbps.length;
				_this2.rawKbps = [];
				_this2.recentKbps.unshift(sample);
				_this2.recentKbps.splice(RECENT_KBPS);
			}, RECENT_KBPS_INTERVAL);

			this.estimatedKbpsInterval = setInterval(function () {
				_this2.emit('profile', {
					estimatedKbps: _this2.currentKbps,
					profile: _this2.profile
				});

				if (!_this2.selectedEncoding) {
					_logger2.default.debug('Estimated KBPS=' + _this2.currentKbps + ', Emergency modifier=' + _this2.emergencyModifier + ', Last BW Switch=' + _this2.lastSwitch + ', Shiftable=' + _this2.shiftable + ', Profile=' + _this2.profile.key);
					return;
				}
				_logger2.default.debug('Estimated KBPS=' + _this2.currentKbps + ', Emergency modifier=' + _this2.emergencyModifier + ', Last BW Switch=' + _this2.lastSwitch + ', Last Selected Bitrated=' + (_this2.selectedEncoding.audioKbps + _this2.selectedEncoding.videoKbps) + ', Shiftable=' + _this2.shiftable + ', Profile=' + _this2.profile.key);
			}, 4000);
		}
	}, {
		key: 'handleEmergencyDrop',
		value: function handleEmergencyDrop(modifier, remainingSample) {
			var _this3 = this;

			this.dropCount++;

			if (this.dropCount < 2) {
				return;
			}
			this.dropCount = 0;
			this.emergencyModifier = modifier;
			this.sampleBws.splice(remainingSample);

			clearTimeout(this.releaseEmergencyTimeout);
			setTimeout(function () {
				_this3.emergencyModifier = 1;
			}, EMERGENCY_RELEASE);
		}
	}, {
		key: 'profileStream',
		value: function profileStream() {
			var sortedKbps = [];
			sortedKbps.push.apply(sortedKbps, this.recentKbps);
			sortedKbps.sort(function (a, b) {
				if (a > b) {
					return 1;
				}
				return -1;
			});

			var quartile = Math.floor(sortedKbps.length / 4);
			var percentDiff1 = (sortedKbps[quartile * 2] - sortedKbps[quartile]) / sortedKbps[quartile * 2];
			var percentDiff2 = (sortedKbps[quartile * 3] - sortedKbps[quartile * 2]) / sortedKbps[quartile * 3];
			var sum = percentDiff1 + percentDiff2;

			if (sum > 1) {
				this.profile = profileTypes.sporadic;
			} else if (sum > 0.65) {
				this.profile = profileTypes.uncertain;
			} else if (sum > 0.3) {
				this.profile = profileTypes.normal;
			} else {
				this.profile = profileTypes.stable;
			}
		}
	}, {
		key: 'onMessage',
		value: function onMessage(ev) {
			if (this.destroyed) {
				return;
			}

			this.lastMessageTime = window.performance.now();
			if (ev.time > ev.duration * 2.5) {
				this.dropCount++;
				this.handleEmergencyDrop(0.6, (MIN_SAMPLE_SIZE - 1) * 3);
			} else if (ev.time > ev.duration * 2.25) {
				this.handleEmergencyDrop(0.7, Math.max(MIN_SAMPLE_SIZE - 1, Math.floor(SAMPLE_SIZE * 0.5)));
			} else if (ev.time > ev.duration * 2) {
				this.handleEmergencyDrop(0.8, Math.max(MIN_SAMPLE_SIZE - 1, Math.floor(SAMPLE_SIZE * 0.7)));
			} else if (ev.time > ev.duration * 1.75) {
				this.handleEmergencyDrop(0.9, Math.max(MIN_SAMPLE_SIZE - 1, Math.floor(SAMPLE_SIZE * 0.8)));
			} else {
				this.dropCount = 0;
			}

			var bw = this.profile.bwModifier(ev.size * 8) * this.emergencyModifier / ev.time;
			this.rawKbps.push(ev.size * 8 / ev.time);

			if (ev.time < MIN_MS_TIME) {
				ev.time = MIN_MS_TIME;
			}

			// Init
			if (ev.size < MIN_SIZE) {
				if (this.count > IGNORE) {
					this.count = Math.floor(IGNORE / 2);
				}
				return;
			}

			// if (this.currentKbps && bw > this.currentKbps * 6 && this.sampleBws.length * 2 < MIN_SIZE) {
			// 	bw = this.currentKbps * 6;
			// }

			this.count++;
			if (!isNaN(bw) && this.count > IGNORE && bw < MAX_BW_ESTIMATE) {
				this.sampleBws.unshift(bw);
				this.sampleBws.splice(SAMPLE_SIZE);
				this.currentKbps = this.calculateCurrentKbps();
			}

			if (this.shiftable) {
				this.shiftIfNecessary();
			}
		}
	}, {
		key: 'shiftIfNecessary',
		value: function shiftIfNecessary() {
			var encodings = this.driver.data.encodings;
			var currentEncoding = encodings[this.driver.currentLevel];

			var suggestedEncoding = encodings[0];
			var chosenI = 0;
			for (var i = 0; i < encodings.length; i++) {
				if (encodings[i].videoKbps + encodings[i].audioKbps < this.currentKbps) {
					suggestedEncoding = encodings[i];
					chosenI = i;
				} else {
					break;
				}
			}

			if (this.switchImmediately) {
				this.switchBitrate(suggestedEncoding);
				this.switchImmediately = false;
				_logger2.default.debug('pick first adaptive encoding', suggestedEncoding);
				return;
			}

			if (!currentEncoding || currentEncoding.videoKbps === suggestedEncoding.videoKbps) {
				return;
			}

			suggestedEncoding.kbps = suggestedEncoding.videoKbps + suggestedEncoding.audioKbps;
			currentEncoding.kbps = currentEncoding.videoKbps + currentEncoding.audioKbps;

			// Stiffness criteria
			if (suggestedEncoding.kbps > currentEncoding.kbps) {
				while (this.profile.resistUpshift(this.currentKbps, suggestedEncoding.kbps) && suggestedEncoding.kbps > currentEncoding.kbps) {
					suggestedEncoding = encodings[--chosenI];
					if (!suggestedEncoding || suggestedEncoding.kbps < currentEncoding.kbps) {
						_logger2.default.debug('tried to upshift - too stiff');
						return;
					}
				}

				this.emit('upshift');
			} else {
				while (this.profile.resistDownshift(this.currentKbps, suggestedEncoding.kbps) && suggestedEncoding.kbps < currentEncoding.kbps) {
					suggestedEncoding = encodings[++chosenI];
					if (!suggestedEncoding || suggestedEncoding.kbps > currentEncoding.kbps) {
						_logger2.default.debug('tried to downshift - too stiff');
						return;
					}
				}

				this.emit('downshift');
			}

			if (currentEncoding.videoKbps === suggestedEncoding.videoKbps) {
				return;
			}

			_logger2.default.debug('switching bitrate', {
				currentEncoding: currentEncoding,
				suggestedEncoding: suggestedEncoding,
				currentKbps: this.currentKbps
			});

			this.lastSwitch = window.performance.now();
			this.selectedEncoding = suggestedEncoding;
			this.switchBitrate(suggestedEncoding);
			this.totalShifts++;
		}
	}, {
		key: 'switchBitrate',
		value: function switchBitrate(suggestedEncoding) {
			this.emit('profile', {
				estimatedKbps: this.currentKbps,
				profile: this.profile
			});
			this.driver.setEncoding(suggestedEncoding);
		}
	}, {
		key: 'calculateCurrentKbps',
		value: function calculateCurrentKbps() {
			var total = 0;
			for (var i = 0; i < this.sampleBws.length; i++) {
				total += this.sampleBws[i];
			}

			return total / this.sampleBws.length;
		}
	}, {
		key: 'destroy',
		value: function destroy() {
			clearTimeout(this.spinTimeout);
			clearTimeout(this.releaseEmergencyTimeout);
			clearInterval(this.estimatedKbpsInterval);
			this.destroyed = true;
			if (this.player) {
				this.player.removeListener('fragment', this.onMessage);
			}
		}
	}, {
		key: 'shiftable',
		get: function get() {
			return this.totalShifts < this.maxShifts && this.sampleBws.length > MIN_SAMPLE_SIZE && window.performance.now() - this.lastSwitch > this.switchThreshold;
		}
	}]);

	return AbrController;
}(_events2.default);

exports.default = AbrController;
},{"@livelyvideo/player-core/lib/logger":23,"events":54}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (blob, cb) {
	var reader = new window.FileReader();
	reader.onload = function readerOnload() {
		cb(reader.result);
	};
	reader.readAsArrayBuffer(blob);
};
},{}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _baseDriver = require('@livelyvideo/player-core/lib/base-driver');

var _baseDriver2 = _interopRequireDefault(_baseDriver);

var _detect = require('@livelyvideo/player-core/lib/detect');

var _detect2 = _interopRequireDefault(_detect);

var _logger = require('@livelyvideo/player-core/lib/logger');

var _logger2 = _interopRequireDefault(_logger);

var _events = require('@livelyvideo/player-core/lib/events');

var _events2 = _interopRequireDefault(_events);

var _errors = require('@livelyvideo/player-core/lib/errors');

var _errors2 = _interopRequireDefault(_errors);

var _player = require('./player');

var _player2 = _interopRequireDefault(_player);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable no-param-reassign */

// const REESTABLISH_CONNECTION_TIMER = 500; // ms to reestablish a ws connection before determining if error is fatal
var ACCEPTABLE_MODES = ['A', 'B', 'N'];
// const BACK_OFF = [0, 1000, 2000, 5000, 25000];

/**
 * @class MediaSourceMp4Driver
 */

var MediaSourceMp4Driver = function (_BaseDriver) {
	_inherits(MediaSourceMp4Driver, _BaseDriver);

	/**
  * @param {object} livelyPlayer all in wonder object
  * @param {object} mediaLoader media loader object
  * @param {object[]} [options]
  * @param {number} [options[].bitrate] attempts to find and use the bitrate nearest to this value
  * @param {bool} [options[].adaptive] defaults to true if bitrate is null, false if bitrate is supplied.	if true, switches bitrate based on bandwidth
  * @param {number} [options[].volume] [0.75] 0-1 volume
  * @param {number} [options[].maxBufferLength] [30s]
  * @param {number} [options[]. maxBufferSize] [60mb]
  * @param {bool} [options[].muted] whether or not the driver is muted
  * @param {bool} [options[].debug] [false] enables debug logging
  * @return {void}
  */
	function MediaSourceMp4Driver(livelyPlayer, mediaLoader, options) {
		_classCallCheck(this, MediaSourceMp4Driver);

		var _this = _possibleConstructorReturn(this, (MediaSourceMp4Driver.__proto__ || Object.getPrototypeOf(MediaSourceMp4Driver)).call(this, livelyPlayer, mediaLoader, options));

		_this.currentManifest = null;

		if (!_this.options.mse) {
			_this.options.mse = {};
		}

		if (!_this.options.mse.backFill || isNaN(_this.options.mse.backFill) || _this.options.mse.backFill < 0 || _this.options.mse.backFill > 10) {
			_this.options.mse.backFill = 2;
		}

		if (!_this.options.mse.maxGap || isNaN(_this.options.mse.maxGap) || _this.options.mse.maxGap < 0 || _this.options.mse.maxGap > 10000) {
			_this.options.mse.maxGap = 500;
		}

		if (!_this.options.mse.retry || isNaN(_this.options.mse.retry) || _this.options.mse.retry < 0 || _this.options.mse.retry > 30) {
			_this.options.mse.retry = 20;
		}

		if (!_this.options.mse.requiredBuffer || isNaN(_this.options.mse.requiredBuffer) || _this.options.mse.requiredBuffer < 0 || _this.options.mse.requiredBuffer > 10) {
			// seconds of buffer required for play to start
			_this.options.mse.requiredBuffer = 1;
		}

		if (!_this.options.mse.initFailTimeout || isNaN(_this.options.mse.initFailTimeout) || _this.options.mse.initFailTimeout < 0) {
			_this.options.mse.initFailTimeout = 30000;
		}

		if (!_this.options.mse.playbackFailTimeout || isNaN(_this.options.mse.playbackFailTimeout) || _this.options.mse.playbackFailTimeout < 0) {
			_this.options.mse.playbackFailTimeout = 60000;
		}

		if (!_this.options.mse.mode || ACCEPTABLE_MODES.indexOf(_this.options.mse.mode) === -1) {
			_this.options.mse.mode = 'B';
		}
		// seconds of buffer required before removing buffer
		_this.options.mse.requiredBufferBeforeRemove = _this.options.mse.requiredBuffer;
		// ms interval to check current time against buffer and skip forward
		_this.options.mse.skipWatchInterval = Math.floor(_this.options.mse.requiredBuffer * 400);
		// seconds behind end of buffer before skipping forward to end of buffer - this.options.mse.requiredBuffer
		_this.options.mse.skipForwardThreshold = 25;
		// download each playback attempt
		_this.options.mse.download = !!_this.options.mse.download;
		// adaptive, max shifts
		if (isNaN(_this.options.mse.maxShifts)) {
			_this.options.mse.maxShifts = Infinity;
		}

		_this.seekingOverHole = false;
		_this.activeEncoding = null;
		_this.render();
		return _this;
	}

	_createClass(MediaSourceMp4Driver, [{
		key: 'handleBufferOverholeSeeking',
		value: function handleBufferOverholeSeeking() {
			var _this2 = this;

			var seekTo = function seekTo(targetTime) {
				_this2.seekingOverHole = true;
				setTimeout(function () {
					_this2.seekingOverHole = false;

					_logger2.default.debug(_events2.default.SEEK_OVER_HOLE, {
						currentTime: _this2.el.currentTime,
						nextBufferStart: _this2.nextBufferStart,
						currentBufferEnd: _this2.currentBufferEnd
					});

					_this2.emit(_events2.default.SEEK_OVER_HOLE, {
						currentBufferEnd: _this2.currentBufferEnd,
						nextBufferStart: _this2.nextBufferStart
					});

					if (!isNaN(targetTime)) {
						_this2.el.currentTime = targetTime;
					}
				}, Math.max(Math.floor((_this2.currentBufferEnd - _this2.el.currentTime) * 1000) - 50, 1));
			};

			if (this.el.currentTime > 0 && this.el.currentTime >= this.currentBufferEnd - 0.025 && this.el.currentTime < this.nextBufferStart && !this.seekingOverHole) {
				seekTo(this.nextBufferStart);
			}

			if (this.currentBufferEnd === 0 && this.nextBufferStart === 0 && this.lastBufferStart > this.el.currentTime) {
				seekTo(this.lastBufferStart);
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _this3 = this;

			this.el = document.createElement('video');
			this.el.setAttribute('class', 'aiw-video');
			if (this.options.posterURI) {
				this.el.setAttribute('poster', this.options.posterURI);
			}
			this.livelyPlayer.el.appendChild(this.el);

			this.el.addEventListener('timeupdate', function () {
				_this3.handleBufferOverholeSeeking();
				_this3.emitTimeupdate();
			});

			this.el.addEventListener('progress', function () {
				_this3.emitProgress();
			});

			this.el.addEventListener('error', function (e) {
				switch (e.target.code) {
					case 1:
						_this3.emit('error', 'media-error', {
							code: e.target.code,
							description: 'MEDIA_ERR_ABORTED',
							fatal: true
						});
						break;
					case 2:
						_this3.emit('error', 'media-error', {
							code: e.target.code,
							description: 'MEDIA_ERR_NETWORK',
							fatal: true
						});
						break;
					case 3:
						_this3.emit(_events2.default.ERROR, _errors2.default.DRIVER_NOT_SUPPORTED, {
							description: 'MEDIA_ERR_DECODE',
							fatal: true
						});
						break;
					case 4:
						_this3.emit(_events2.default.ERROR, _errors2.default.DRIVER_NOT_SUPPORTED, {
							description: 'MEDIA_ERR_SRC_NOT_SUPPORTED',
							fatal: true
						});
						break;
					default:
						_this3.emit(_events2.default.ERROR, _errors2.default.DRIVER_NOT_SUPPORTED, {
							description: 'unknown element error',
							fatal: true
						});
				}
			});

			// when video pauses, check if offline and cleanup
			this.el.addEventListener('pause', function () {
				if (_this3.mediaLoader.currentState === _events2.default.OFFLINE) {
					_this3.stop();
				}
			});
			this.el.volume = this.options.volume;
			this.el.muted = this.options.muted;
		}

		/**
   * returns true if browser supports native mp4
   * @return {Boolean}
   */

	}, {
		key: 'getLevelForBitrate',
		value: function getLevelForBitrate(bitrate) {
			var encodings = this.data.encodings;

			if (!encodings.length) {
				return null;
			}

			var i = void 0;
			for (i = 0; i < encodings.length; i++) {
				if (!encodings[i].videoWidth) {
					continue;
				}
				if (encodings[i].videoKbps + encodings[i].audioKbps > bitrate) {
					break;
				}
			}
			i = Math.max(i - 1, 0);
			return i;
		}
	}, {
		key: 'pickEncoding',


		/**
   * @param {number} [bitrate] bitrate, defaults to options.bitrate || options.estimatedKbps
   * @return {object} encoding object
   */
		value: function pickEncoding(bitrate) {
			bitrate = bitrate || this.options.bitrate;
			if (!bitrate) {
				return null;
			}

			var encodings = this.data.encodings;

			if (!encodings.length) {
				return null;
			}

			return encodings[this.currentLevel];
		}

		/**
   * calls to the transport to set the encoding
   * @param {object} encodings
   * @return {void}
   */

	}, {
		key: 'setEncoding',
		value: function setEncoding(encoding) {
			if (this.activeEncoding && this.activeEncoding.videoKbps === encoding.videoKbps && this.activeEncoding.audioKbps === encoding.audioKbps) {
				return;
			}

			this.activeEncoding = encoding;
			var x = encoding.location.split('/');
			this.player.switchBitrate(x[x.length - 1]);
		}

		/**
   * @param {number} bitrate
   * @return {void}
   */

	}, {
		key: 'switchBitrate',
		value: function switchBitrate(bitrate) {
			var _this4 = this;

			this.options.origin = false;
			this.options.bitrate = bitrate;

			if (!bitrate) {
				this.options.bitrate = null;
				this.stop(function () {
					_this4.play();
				});
				return;
			}
			this.setEncoding(this.pickEncoding(bitrate));
		}
	}, {
		key: 'addSessionKey',
		value: function addSessionKey(l) {
			var delimiter = l.indexOf('?') === -1 ? '?' : '&';
			l += delimiter + 'sid=' + _logger2.default.sessionKey;
			return l;
		}
	}, {
		key: 'destroy',


		/**
   * destroys the driver
   * @return {void}
   */
		value: function destroy() {
			this.stop();
			this.el.remove();
		}
	}, {
		key: 'pause',
		value: function pause() {
			this.stop();
		}
	}, {
		key: 'stop',
		value: function stop(cb) {
			var _this5 = this;

			this.playbackLock = false;
			clearInterval(this.nudgeInterval);
			if (!this.player) {
				if (cb) {
					cb();
				}
				return;
			}
			this.player.destroy(function () {
				for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}

				_this5.player = null;
				if (cb) {
					cb.apply(cb, args);
				}
			});
		}

		/**
   * @param {function} [cb]
   */

	}, {
		key: 'play',
		value: function play(cb) {
			var _this6 = this;

			if (this.playbackLock) {
				return;
			}

			this.playbackLock = true;
			this.elementPlay();
			if (this.player) {
				this.player.play(cb);
				return;
			}

			this.whenReady(function () {
				clearInterval(_this6.nudgeInterval);
				_this6.nudgeTime = null;
				var nudges = 0;
				_this6.nudgeInterval = setInterval(function () {
					if (!_this6.livelyPlayer.tryingToPlay || _this6.el.currentTime === 0) {
						return;
					}

					if (_this6.nudgeTime && _this6.el.currentTime === _this6.nudgeTime && (!_this6.lastBufferEnd || _this6.el.currentTime < _this6.lastBufferEnd)) {
						_logger2.default.debug('playback halted, nudging');
						nudges++;
						_this6.el.currentTime = _this6.el.currentTime + 0.1;
						var p = _this6.el.play();
						if (typeof Promise !== 'undefined' && p instanceof Promise) {
							p.catch(function () {
								// its ok, it didn't work out this time
							});
						}
					} else {
						nudges = 0;
						_this6.nudgeTime = _this6.el.currentTime;
					}

					if (nudges > 29) {
						clearInterval(_this6.nudgeInterval);
						_this6.reloadAndRestart();
					}
				}, 500);

				if (_this6.player) {
					_this6.player.destroy();
				}
				_this6.player = new _player2.default(_this6, _this6.options);
				_this6.upshift = 0;
				_this6.downshift = 0;
				_this6.currentErrorCount = 0;
				_this6.fragCounts = 0;
				_this6.fragSize = 0;
				_this6.fragFetchTime = 0;
				_this6.fragMaxTime = 0;
				_this6.fragMinTime = 0;

				_this6.player.on('upshift', function () {
					_this6.upshift++;
				});

				_this6.player.on('downshift', function () {
					_this6.downshift++;
				});

				_this6.player.on('fragment', function (data) {
					_this6.fragCounts++;
					_this6.fragSize += data.size;
					_this6.fragFetchTime += data.fetchTime;
					_this6.fragMaxTime = Math.max(_this6.fragMaxTime, data.fetchTime);
					_this6.fragMinTime = Math.min(_this6.fragMinTime || data.fetchTime, data.fetchTime);
				});

				_this6.player.on('error', function (e, data) {
					_this6.currentErrorCount++;
					_this6.emit(e, data);
					if (data.fatal) {
						_this6.reloadAndRestart();
					}
				});
				_this6.player.play(cb);
			});
		}
	}, {
		key: 'lastBufferEnd',
		get: function get() {
			if (!this.sourceBuffer || !this.sourceBuffer.buffered.length) {
				return 0;
			}

			return this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length - 1);
		}
	}, {
		key: 'lastBufferStart',
		get: function get() {
			if (!this.sourceBuffer || !this.sourceBuffer.buffered.length) {
				return 0;
			}

			return this.sourceBuffer.buffered.start(this.sourceBuffer.buffered.length - 1);
		}
	}, {
		key: 'nextBufferStart',
		get: function get() {
			if (!this.sourceBuffer) {
				return 0;
			}

			for (var i = 0; i < this.sourceBuffer.buffered.length; i++) {
				var b = this.sourceBuffer.buffered;

				if (this.el.currentTime >= b.start(i) && this.el.currentTime <= b.end(i)) {
					if (this.sourceBuffer.buffered.length > i + 1) {
						return this.sourceBuffer.buffered.start(i + 1);
					}
					return this.sourceBuffer.buffered.end(i);
				}
			}
			return 0;
		}
	}, {
		key: 'currentBufferEnd',
		get: function get() {
			if (!this.sourceBuffer || !this.sourceBuffer.buffered.length) {
				return 0;
			}

			for (var i = 0; i < this.sourceBuffer.buffered.length; i++) {
				if (this.el.currentTime >= this.sourceBuffer.buffered.start(i) && this.el.currentTime <= this.sourceBuffer.buffered.end(i)) {
					return this.sourceBuffer.buffered.end(i);
				}
			}
			return 0;
		}
	}, {
		key: 'currentLevel',
		get: function get() {
			if (this.options.bitrate) {
				return this.getLevelForBitrate(this.options.bitrate);
			}

			if (!this.activeEncoding) {
				return this.getLevelForBitrate(this.options.estimatedKbps);
			}

			return this.getLevelForBitrate(this.activeEncoding.videoKbps + this.activeEncoding.audioKbps);
		}
	}, {
		key: 'originLocation',
		get: function get() {
			var o = this.origin;

			if (!o) {
				return null;
			}

			return this.addSessionKey(o.location);
		}

		/**
   * returns null if there is no ws endpoint available, otherwise returns the active ws url
   * @return {string} manifest url
   */

	}, {
		key: 'manifest',
		get: function get() {
			var l = void 0;

			if (this.options.origin) {
				l = this.originLocation;
				if (!l) {
					this.options.origin = false;
					return this.manifest;
				}
			} else {
				var d = this.data;
				if (!d.encodings.length) {
					var o = this.originLocation;
					if (o) {
						this.options.origin = true;
					}
					return o;
				}

				var e = this.pickEncoding(this.options.bitrate || this.options.estimatedKbps);

				if (!e) {
					return null;
				}

				l = e.location;
			}

			if (!l) {
				return null;
			}

			return this.addSessionKey(l);
		}
	}], [{
		key: 'isSupported',
		value: function isSupported() {
			if (_detect2.default.chrome() && !_detect2.default.chromeGreater50()) {
				return false;
			}

			return window.WebSocket && window.MediaSource && window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.4d4028,mp4a.40.2"');
		}
	}, {
		key: 'driver',
		get: function get() {
			return 'mediaSourceMp4';
		}
	}, {
		key: 'format',
		get: function get() {
			return 'mp4-ws';
		}
	}]);

	return MediaSourceMp4Driver;
}(_baseDriver2.default);

exports.default = MediaSourceMp4Driver;
},{"./player":47,"@livelyvideo/player-core/lib/base-driver":17,"@livelyvideo/player-core/lib/detect":18,"@livelyvideo/player-core/lib/errors":19,"@livelyvideo/player-core/lib/events":20,"@livelyvideo/player-core/lib/logger":23}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _transport = require('./transport');

var _transport2 = _interopRequireDefault(_transport);

var _abrController = require('./abr-controller');

var _abrController2 = _interopRequireDefault(_abrController);

var _logger = require('@livelyvideo/player-core/lib/logger');

var _logger2 = _interopRequireDefault(_logger);

var _blobToArrayBuffer = require('./blob-to-array-buffer');

var _blobToArrayBuffer2 = _interopRequireDefault(_blobToArrayBuffer);

var _storageValues = require('@livelyvideo/player-core/lib/storage-values');

var _storageValues2 = _interopRequireDefault(_storageValues);

var _detect = require('@livelyvideo/player-core/lib/detect');

var _detect2 = _interopRequireDefault(_detect);

var _errors = require('@livelyvideo/player-core/lib/errors');

var _errors2 = _interopRequireDefault(_errors);

var _events3 = require('@livelyvideo/player-core/lib/events');

var _events4 = _interopRequireDefault(_events3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable no-param-reassign */


var Player = function (_EventEmitter) {
	_inherits(Player, _EventEmitter);

	function Player(driver, options) {
		_classCallCheck(this, Player);

		var _this = _possibleConstructorReturn(this, (Player.__proto__ || Object.getPrototypeOf(Player)).call(this));

		_this.livelyPlayer = driver.livelyPlayer;
		_this.mediaLoader = driver.mediaLoader;
		_this.driver = driver;
		_this.options = options;
		_this.el = _this.driver.el;

		_this.buffering = false;
		_this.queue = [];
		_this.sourceBuffers = [];

		// set up the ABR Controller
		if (!_this.options.bitrate) {
			_this.abrController = new _abrController2.default(_this, _this.driver, _this.livelyPlayer.store.get(_storageValues2.default.profile), false, _this.driver.options.mse.maxShifts);
			_this.abrController.on('profile', function (data) {
				var ttl = _detect2.default.any() ? 6 * 1000 * 60 * 60 : 1000 * 60 * 60 * 24 * 60;

				_this.livelyPlayer.store.set(_storageValues2.default.estimatedKbps, data.estimatedKbps, ttl);
				_this.livelyPlayer.store.set(_storageValues2.default.profile, data.profile.key, ttl);
			});

			_this.abrController.on('upshift', function () {
				_this.emit('upshift');
			});

			_this.abrController.on('downshift', function () {
				_this.emit('downshift');
			});
		}

		var e = void 0;
		if (_this.options.origin) {
			e = _this.driver.data.origin;
		} else {
			e = _this.driver.pickEncoding();
		}

		if (!e && _this.driver.data.encodings.length) {
			e = _this.driver.data.encodings[0];
		}
		_this.encoding = e;

		_this.setupMSE();
		return _this;
	}

	_createClass(Player, [{
		key: 'appendBuffer',
		value: function appendBuffer() {
			var _this2 = this;

			if (this.buffering) {
				return;
			}

			var wait = function wait() {
				_this2.buffering = true;
				setTimeout(function () {
					_this2.buffering = false;
					_this2.appendBuffer();
				}, 20);
			};

			if (!this.ms.readyState) {
				wait();
				return;
			}

			var op = this.queue.shift();

			if (!op) {
				wait();
				return;
			}

			this.buffering = true;
			if (op.type === 'remove') {
				_logger2.default.debug('remove buffer', op.start + '-' + op.end + ' buffered until ' + op.sb.buffered.end(0));
				op.sb.remove(op.start, op.end);
			} else {
				(0, _blobToArrayBuffer2.default)(op.blob, function (ab) {
					var currentSegmentInfo = _this2.transport.getSegmentInfo(ab);

					// backwards compat
					if (_this2.version === 1) {
						currentSegmentInfo.contentTag = 0;
					}

					var sb = _this2.sourceBuffers[currentSegmentInfo.contentTag];

					_this2.emit('fragment', {
						size: op.blob.size,
						time: op.time,
						duration: 300
					});

					if (!sb) {
						_this2.queue.unshift(op);
						wait();
						return;
					}

					sb.appendBuffer(ab);
				});
			}
		}
	}, {
		key: 'newSourceBuffer',
		value: function newSourceBuffer(mimetype) {
			var _this3 = this;

			if (!mimetype || !window.MediaSource.isTypeSupported(mimetype)) {
				this.sourceBuffers.push(null);
				return;
			}

			var sb = this.ms.addSourceBuffer(mimetype);
			sb.mimetype = mimetype;
			sb.addEventListener('updateend', function () {
				_this3.buffering = false;
				_this3.appendBuffer();

				if (_this3.el.currentTime === 0 && _this3.el.buffered.length) {
					if (_this3.el.buffered.end(_this3.el.buffered.length - 1) - _this3.el.buffered.start(0) > _this3.options.mse.requiredBuffer) {
						_this3.el.currentTime = Math.max(_this3.el.buffered.end(_this3.el.buffered.length - 1) - _this3.options.mse.requiredBuffer, _this3.el.buffered.start(0));
						var p = _this3.el.play();
						if (typeof Promise !== 'undefined' && p instanceof Promise) {
							p.catch(function () {
								// its ok, it didn't work out this time
							});
						}
					}
				}
				/** logs */
				// this.sourceBuffers.forEach((sbl, k) => {
				// 	if (!sbl) {
				// 		return;
				// 	}
				// 	let out = `Buffers: ${k} ${this.el.currentTime} `;
				// 	for (let i = 0; i < sbl.buffered.length; i++) {
				// 		out += `${sbl.buffered.start(i)}-${sbl.buffered.end(i)} `;
				// 	}
				// 	// logger.info(out);
				// });
				// /** end logs*/
			});
			this.sourceBuffers.push(sb);
		}
	}, {
		key: 'setupMSE',
		value: function setupMSE() {
			var _this4 = this;

			this.ms = new window.MediaSource();

			this.ms.addEventListener('error', function () {
				// if it errors, its because of a fatal decoding error
				_this4.emit(_events4.default.ERROR, _errors2.default.MEDIA_ERROR, {
					fatal: true
				});
			});

			this.ms.addEventListener('sourceopen', function () {
				var e = _this4.encoding;

				if (!e) {
					_this4.emit(_events4.default.ERROR, _errors2.default.MEDIA_ERROR, { fatal: true });
					return;
				}

				if (e && e.channels) {
					_this4.version = 2;
					e.channels.forEach(function (c) {
						_this4.newSourceBuffer(c);
					});
				} else {
					_this4.version = 1;
					var o = _this4.driver.data.origin;
					var mimetype = void 0;
					if (_this4.options.origin && o && o.audioCodec !== 'aac' || !_this4.options.origin && _this4.driver.data.audioCodec !== 'aac') {
						mimetype = 'video/mp4; codecs="avc1.4d4028"';
					} else {
						mimetype = 'video/mp4; codecs="avc1.4d4028, mp4a.40.2"';
					}

					_this4.newSourceBuffer(mimetype);
				}
			});

			this.el.src = window.URL.createObjectURL(this.ms);
		}
	}, {
		key: 'setupTransport',
		value: function setupTransport() {
			var _this5 = this;

			var channelCount = this.encoding.channels && this.encoding.channels.length ? this.encoding.channels.length : 1;
			this.transport = new _transport2.default(this.driver.manifest, this.options.mse.backFill, this.options.mse.maxGap, this.options.mse.retry, this.options.mse.mode, this.options.mse.download, this.options.mse.segmentDuration, channelCount);
			this.transport.on('error', function () {
				if (_this5.transport && _this5.transport.isDisconnected) {
					_this5.emit(_events4.default.ERROR, _errors2.default.WS_NETWORK_ERROR, { fatal: false });
				} else {
					_this5.emit(_events4.default.ERROR, _errors2.default.WS_CONNECTION, { fatal: false });
				}
			});

			this.transport.on('destroy', function () {
				_this5.emit(_events4.default.ERROR, _errors2.default.WS_CONNECTION, { fatal: true });
			});
			this.transport.on('message', function (ev) {
				_this5.queue.push({
					type: 'append',
					blob: ev.data,
					time: ev.fetchTime
				});
				_this5.appendBuffer();
			});
		}
	}, {
		key: 'switchBitrate',
		value: function switchBitrate(name) {
			if (this.abrController) {
				this.abrController.destroy();
			}
			this.transport.switchBitrate(name);
		}
	}, {
		key: 'play',
		value: function play(cb) {
			var _this6 = this;

			this.queue = [];
			if (!this.transport) {
				this.setupTransport();
			}

			this.gcInterval = setInterval(function () {
				_this6.sourceBuffers.forEach(function (sb) {
					_this6.queue.push({
						type: 'remove',
						sb: sb,
						start: 0,
						end: _this6.el.currentTime - 15
					});
				});
			}, 30 * 1000);

			var returnTrue = function returnTrue() {
				_this6.el.removeEventListener('timeupdate', returnTrue);
				clearTimeout(waitForPlay);
				if (cb) {
					cb(true);
				}
				cb = null;
			};
			this.el.addEventListener('timeupdate', returnTrue);

			var waitForPlay = setTimeout(function () {
				_this6.el.removeEventListener('timeupdate', returnTrue);
				if (cb) {
					cb(false);
				}
				cb = null;
			}, 4000);
			this.el.play();
		}
	}, {
		key: 'stop',
		value: function stop(cb) {
			clearInterval(this.gcInterval);
			this.transport.removeAllListeners('message');
			this.buffering = false;
			this.el.pause();
			if (cb) {
				cb();
			}
		}
	}, {
		key: 'destroy',
		value: function destroy(cb) {
			this.transport.removeAllListeners('error');
			this.transport.removeAllListeners('destroy');
			this.transport.removeAllListeners('message');
			this.transport.destroy();

			if (this.abrController) {
				this.abrController.destroy();
			}

			this.stop(cb);
		}
	}]);

	return Player;
}(_events2.default);

exports.default = Player;
},{"./abr-controller":44,"./blob-to-array-buffer":45,"./transport":48,"@livelyvideo/player-core/lib/detect":18,"@livelyvideo/player-core/lib/errors":19,"@livelyvideo/player-core/lib/events":20,"@livelyvideo/player-core/lib/logger":23,"@livelyvideo/player-core/lib/storage-values":32,"events":54}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /* eslint-disable no-param-reassign */

var BOX_NAMES = ['moof', 'mfhd'];
var INIT_BOX = 'ftyp';

function sFCC(dv, n) {
	return String.fromCharCode(dv.getUint8(n));
}

function getContentTag(ab, dv) {
	if (ab.byteLength < 9) {
		return 1;
	}

	// last box should be skip
	if (dv.getUint32(ab.byteLength - 5) !== 0x736b6970) {
		return 1;
	}
	return dv.getUint8(ab.byteLength - 1);
}

var Latency = function Latency() {
	_classCallCheck(this, Latency);

	this.lastTime = window.performance.now();
	this.lastSegmentTime = window.performance.now();
	this.lastSegmentDuration = 0;
};

/**
 * @class Transport
 */


var Transport = function (_EventEmitter) {
	_inherits(Transport, _EventEmitter);

	/**
  * @param {string} websocket uri
  * @param {int} backFill
  * @param {int} maxGap
  * @param {int} retry
  */
	function Transport(uri) {
		var backFill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
		var maxGap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 500;
		var retry = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 20;
		var mode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'B';
		var download = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
		var segmentDuration = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 300;
		var channelCount = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 1;

		_classCallCheck(this, Transport);

		var _this = _possibleConstructorReturn(this, (Transport.__proto__ || Object.getPrototypeOf(Transport)).call(this));

		_this.uri = uri;
		_this.backFill = backFill;
		_this.maxGap = maxGap;
		_this.retry = retry;
		_this.mode = mode;
		_this.segmentDuration = segmentDuration;
		_this.saveToDownload = download;
		_this.downloadedSegments = [];
		_this.ws = new window.WebSocket(_this.uri + '&bckfil=' + _this.backFill);

		_this.channelTracker = 0;
		_this.channelLatency = [];
		for (var i = 0; i < channelCount; i++) {
			_this.channelLatency.push(new Latency());
		}

		_this.ws.onmessage = function (ev) {
			if (_typeof(ev.data) === 'object') {
				ev.fetchTime = window.performance.now() - _this.lastTime + 10;
				ev.segmentDuration = _this.lastSegmentDuration || _this.segmentDuration;

				_this.emit('message', ev);

				_this.lastSegmentTime = window.performance.now();
				if (_this.saveToDownload) {
					_this.downloadedSegments.push(ev.data);
				}

				_this.nextChannel();
			} else {
				_this.lastTime = window.performance.now();
				var currentSegmentDuration = parseInt(ev.data, 10);
				_this.lastSegmentDuration = currentSegmentDuration < 2000 && currentSegmentDuration > 0 ? currentSegmentDuration : _this.segmentDuration;
			}
		};
		_this.ws.onclose = function () {
			_this.emit('close');
			_this.emit('destroy');
		};
		_this.ws.onerror = function () {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			_this.emit.apply(_this, ['error'].concat(args));
		};
		return _this;
	}

	_createClass(Transport, [{
		key: 'nextChannel',
		value: function nextChannel() {
			this.channelTracker++;
			if (this.channelLatency.length >= this.channelTracker) {
				this.channelTracker = 0;
			}
		}
	}, {
		key: 'download',
		value: function download() {
			var a = document.createElement('a');
			document.body.appendChild(a);
			a.style = 'display: none';

			var blob = new window.Blob(this.downloadedSegments, {
				type: 'octet/stream'
			});
			var url = window.URL.createObjectURL(blob);
			a.href = url;
			a.download = 'blah.mp4';
			a.click();
			window.URL.revokeObjectURL(url);
		}
	}, {
		key: 'getSegmentInfo',


		// get latency () {
		// 	if (!this.latencyCount) {
		// 		return 0;
		// 	}
		// 	return this.latencySum / this.latencyCount * 0.75;
		// }

		/**
   * parse out current segment number from skip boxes
   * @return {int} current segment number
   */
		value: function getSegmentInfo(ab) {
			var dv = new DataView(ab);

			var contentTag = getContentTag(ab, dv);

			var boxSize = 0;
			var i = 0;
			var j = 0;
			var len = ab.byteLength;

			var segmentNo = 0;
			var init = false;

			if ('' + sFCC(dv, 4) + sFCC(dv, 5) + sFCC(dv, 6) + sFCC(dv, 7) === INIT_BOX) {
				init = true;
			}

			for (i = 0; i < len && j < BOX_NAMES.length;) {
				boxSize = dv.getUint32(i);
				// step into box
				if (sFCC(dv, i + 4) === BOX_NAMES[j].charAt(0) && sFCC(dv, i + 5) === BOX_NAMES[j].charAt(1) && sFCC(dv, i + 6) === BOX_NAMES[j].charAt(2) && sFCC(dv, i + 7) === BOX_NAMES[j].charAt(3)) {
					len = i + boxSize;
					j++;
					i += 8; // works only for Box, not for extended box
				} else {
					i += boxSize;
				}
			}

			// we found it
			if (j === BOX_NAMES.length) {
				segmentNo = dv.getUint32(i + 4);
			}

			return {
				contentTag: contentTag,
				segment: segmentNo,
				init: init
			};
		}

		/**
  * Switches the current active bitrate
  *
  * @param {string} stream name
  * @param {string}
   */

	}, {
		key: 'switchBitrate',
		value: function switchBitrate(name) {
			this.ws.send('switch_stream?name=' + name + '&mode=' + this.mode + '&bckfil=' + this.backFill + '&retry=' + this.retry + '&mxgap=' + this.maxGap);
		}

		/**
   * Destroys the websocket connection
   */

	}, {
		key: 'destroy',
		value: function destroy(cb) {
			this.downloadedSegments = [];
			if (!cb) {
				cb = function cb() {};
			}

			clearInterval(this.pingInterval);
			if (!this.ws) {
				cb();
				return;
			}

			this.ws.close();
			setTimeout(function () {
				cb();
			}, 50);
		}
	}, {
		key: 'lastTime',
		get: function get() {
			return this.channelLatency[this.channelTracker].lastTime;
		},
		set: function set(v) {
			this.channelLatency[this.channelTracker].lastTime = v;
		}
	}, {
		key: 'lastSegmentTime',
		get: function get() {
			return this.channelLatency[this.channelTracker].lastSegmentTime;
		},
		set: function set(v) {
			this.channelLatency[this.channelTracker].lastSegmentTime = v;
		}
	}, {
		key: 'lastSegmentDuration',
		get: function get() {
			return this.channelLatency[this.channelTracker].lastSegmentDuration;
		},
		set: function set(v) {
			this.channelLatency[this.channelTracker].lastSegmentDuration = v;
		}
	}, {
		key: 'disconnected',
		get: function get() {
			return this.ws.readyState > 1;
		}
	}]);

	return Transport;
}(_events2.default);

exports.default = Transport;
},{"events":54}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _baseDriver = require('@livelyvideo/player-core/lib/base-driver');

var _baseDriver2 = _interopRequireDefault(_baseDriver);

var _detect = require('@livelyvideo/player-core/lib/detect');

var _detect2 = _interopRequireDefault(_detect);

var _events = require('@livelyvideo/player-core/lib/events');

var _events2 = _interopRequireDefault(_events);

var _errors = require('@livelyvideo/player-core/lib/errors');

var _errors2 = _interopRequireDefault(_errors);

var _lodash = require('lodash.noop');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ERROR_CODES = {
	1: 'MEDIA_ERR_ABORTED',
	2: 'MEDIA_ERR_NETWORK',
	3: 'MEDIA_ERR_DECODE',
	4: 'MEDIA_ERR_SRC_NOT_SUPPORTED'
};

var ERROR_RETRY_TIMER = 250;

/**
 * @class NativeHLS
 */

var NativeHLSDriver = function (_BaseDriver) {
	_inherits(NativeHLSDriver, _BaseDriver);

	/**
  * @param {object} livelyPlayer Lively video object
  * @param {object} mediaLoader media loader object
  * @param {object[]} [options]
  * @param {number} [options[].bitrate] attempts to find and use the bitrate nearest to this value
  * @param {bool} [options[].adaptive] defaults to true if bitrate is null, false if bitrate is supplied.	if true, switches bitrate based on bandwidth
  * @param {number} [options[].volume] [0.75] 0-1 volume
  * @param {number} [options[].maxBufferLength] [30s]
  * @param {number} [options[]. maxBufferSize] [60mb]
  * @param {bool} [options[].muted] whether or not the driver is muted
  * @param {bool} [options[].debug] [false] enables debug logging
  * @return {void}
  */
	function NativeHLSDriver(livelyPlayer, mediaLoader, options) {
		_classCallCheck(this, NativeHLSDriver);

		var _this = _possibleConstructorReturn(this, (NativeHLSDriver.__proto__ || Object.getPrototypeOf(NativeHLSDriver)).call(this, livelyPlayer, mediaLoader, options));

		_this.el = document.createElement('video');
		_this.el.setAttribute('class', 'aiw-video');
		_this.el.setAttribute('playsinline', true);
		_this.el.setAttribute('webkit-playsinline', true);
		if (options.autoplay) {
			_this.el.setAttribute('autoplay', true);
		}

		if (_this.options.posterURI) {
			_this.el.setAttribute('poster', _this.options.posterURI);
		}

		_this.livelyPlayer.el.appendChild(_this.el);
		_this.el.volume = _this.options.volume;
		_this.el.muted = _this.options.muted;

		_this.el.addEventListener(_events2.default.ERROR, function () {
			if (!_this.el.getAttribute('src')) {
				return;
			}

			_this.handleError(_events2.default.ERROR, _errors2.default.UNKNOWN_ERROR, {
				fatal: true,
				details: ERROR_CODES[_this.el.error.code]
			});
			setTimeout(function () {
				if (!_this.livelyPlayer.tryingToPlay) {
					return;
				}
				_this.play();
			}, ERROR_RETRY_TIMER);
		});

		_this.el.addEventListener('webkitendfullscreen', function () {
			_this.livelyPlayer.stop();
			_this.el.setAttribute('src', _this.manifest);
		});

		_this.lastProgress = Date.now();
		return _this;
	}

	_createClass(NativeHLSDriver, [{
		key: 'stop',


		/**
   * Stops the HLS player
   * @return {void}
   */
		value: function stop() {
			_get(NativeHLSDriver.prototype.__proto__ || Object.getPrototypeOf(NativeHLSDriver.prototype), 'stop', this).call(this);
			clearInterval(this.progressInterval);
		}
	}, {
		key: 'play',
		value: function play(inputCb) {
			var _this2 = this;

			var cb = inputCb || _lodash2.default;
			_get(NativeHLSDriver.prototype.__proto__ || Object.getPrototypeOf(NativeHLSDriver.prototype), 'play', this).call(this, function (playing) {
				// cannot attach progress or timeupdate until playing is successfully called
				// otherwise ios10 autoplay will not work properly
				if (playing) {
					_this2.el.onprogress = function () {
						_this2.emitProgress();
					};

					_this2.el.onended = function () {
						_this2.emit('ended');
					};

					_this2.el.ontimeupdate = function () {
						_this2.fragCounts++;
						_this2.emitTimeupdate();
					};
				}

				cb(playing);
			});
		}
	}], [{
		key: 'isSupported',


		/**
   * returns true if browser supports native hls
   * @return {Boolean}
   */
		value: function isSupported() {
			var el = document.createElement('video');
			var result = el.canPlayType && (el.canPlayType('application/vnd.apple.mpegURL') === 'maybe' || el.canPlayType('application/vnd.apple.mpegURL') === 'probably');
			el.remove();
			return result;
		}
	}, {
		key: 'driver',
		get: function get() {
			return 'hls';
		}
	}, {
		key: 'format',
		get: function get() {
			return 'mp4-hls';
		}
	}]);

	return NativeHLSDriver;
}(_baseDriver2.default);

exports.default = NativeHLSDriver;
},{"@livelyvideo/player-core/lib/base-driver":17,"@livelyvideo/player-core/lib/detect":18,"@livelyvideo/player-core/lib/errors":19,"@livelyvideo/player-core/lib/events":20,"lodash.noop":58}],50:[function(require,module,exports){
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.LivelyStockBroadcaster=t():e.LivelyStockBroadcaster=t()}(this,function(){return function(e){function t(n){if(r[n])return r[n].exports;var i=r[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,t),i.l=!0,i.exports}var r={};return t.m=e,t.c=r,t.i=function(e){return e},t.d=function(e,t,r){Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=17)}([function(e,t){"use strict";function r(e,t){var r=document.createElement(e);return r.classList.add.apply(r.classList,t),r}Object.defineProperty(t,"__esModule",{value:!0}),t.default=r},function(e,t){function r(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function n(e){return"function"==typeof e}function i(e){return"number"==typeof e}function o(e){return"object"==typeof e&&null!==e}function s(e){return void 0===e}e.exports=r,r.EventEmitter=r,r.prototype._events=void 0,r.prototype._maxListeners=void 0,r.defaultMaxListeners=10,r.prototype.setMaxListeners=function(e){if(!i(e)||e<0||isNaN(e))throw TypeError("n must be a positive number");return this._maxListeners=e,this},r.prototype.emit=function(e){var t,r,i,a,c,u;if(this._events||(this._events={}),"error"===e&&(!this._events.error||o(this._events.error)&&!this._events.error.length)){if(t=arguments[1],t instanceof Error)throw t;var l=new Error('Uncaught, unspecified "error" event. ('+t+")");throw l.context=t,l}if(r=this._events[e],s(r))return!1;if(n(r))switch(arguments.length){case 1:r.call(this);break;case 2:r.call(this,arguments[1]);break;case 3:r.call(this,arguments[1],arguments[2]);break;default:a=Array.prototype.slice.call(arguments,1),r.apply(this,a)}else if(o(r))for(a=Array.prototype.slice.call(arguments,1),u=r.slice(),i=u.length,c=0;c<i;c++)u[c].apply(this,a);return!0},r.prototype.addListener=function(e,t){var i;if(!n(t))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",e,n(t.listener)?t.listener:t),this._events[e]?o(this._events[e])?this._events[e].push(t):this._events[e]=[this._events[e],t]:this._events[e]=t,o(this._events[e])&&!this._events[e].warned&&(i=s(this._maxListeners)?r.defaultMaxListeners:this._maxListeners,i&&i>0&&this._events[e].length>i&&(this._events[e].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[e].length),"function"==typeof console.trace&&console.trace())),this},r.prototype.on=r.prototype.addListener,r.prototype.once=function(e,t){function r(){this.removeListener(e,r),i||(i=!0,t.apply(this,arguments))}if(!n(t))throw TypeError("listener must be a function");var i=!1;return r.listener=t,this.on(e,r),this},r.prototype.removeListener=function(e,t){var r,i,s,a;if(!n(t))throw TypeError("listener must be a function");if(!this._events||!this._events[e])return this;if(r=this._events[e],s=r.length,i=-1,r===t||n(r.listener)&&r.listener===t)delete this._events[e],this._events.removeListener&&this.emit("removeListener",e,t);else if(o(r)){for(a=s;a-- >0;)if(r[a]===t||r[a].listener&&r[a].listener===t){i=a;break}if(i<0)return this;1===r.length?(r.length=0,delete this._events[e]):r.splice(i,1),this._events.removeListener&&this.emit("removeListener",e,t)}return this},r.prototype.removeAllListeners=function(e){var t,r;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[e]&&delete this._events[e],this;if(0===arguments.length){for(t in this._events)"removeListener"!==t&&this.removeAllListeners(t);return this.removeAllListeners("removeListener"),this._events={},this}if(r=this._events[e],n(r))this.removeListener(e,r);else if(r)for(;r.length;)this.removeListener(e,r[r.length-1]);return delete this._events[e],this},r.prototype.listeners=function(e){var t;return t=this._events&&this._events[e]?n(this._events[e])?[this._events[e]]:this._events[e].slice():[]},r.prototype.listenerCount=function(e){if(this._events){var t=this._events[e];if(n(t))return 1;if(t)return t.length}return 0},r.listenerCount=function(e,t){return e.listenerCount(t)}},function(e,t){e.exports=function(e,t){var r=void 0!==e.textContent?"textContent":"innerText";return"undefined"!=typeof t&&(e[r]=t),e[r]}},function(e,t){function r(e){var t=n.call(e);return"[object Function]"===t||"function"==typeof e&&"[object RegExp]"!==t||"undefined"!=typeof window&&(e===window.setTimeout||e===window.alert||e===window.confirm||e===window.prompt)}e.exports=r;var n=Object.prototype.toString},function(e,t,r){!function(t,r){e.exports=r()}(this,function(){return function(e){function t(n){if(r[n])return r[n].exports;var i=r[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,t),i.l=!0,i.exports}var r={};return t.m=e,t.c=r,t.i=function(e){return e},t.d=function(e,t,r){Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=9)}([function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default={createBroadcast:function(){try{return this.getSwf().tfBroadcastCreate()}catch(e){return this.logError("broadcast","createBroadcast",[],"error initializing broadcast [err="+e+"]"),!1}},destroyBroadcast:function(e){try{this.getSwf().tfBroadcastDestroy(e)}catch(t){return this.logError("broadcast","destroyBroadcast",[e],"error destroying broadcast [err="+t+"]"),!1}return!0},connectToBroadcast:function(e,t,r){try{var n;(n=this.getSwf()).tfBroadcastConnect.apply(n,arguments)}catch(n){return this.logError("broadcast","connectToBroadcast",[e,t,r],"error connecting to broadcast [err="+n+"]"),!1}return!0},setVideoPath:function(e,t){try{this.getSwf().tfBroadcastConnect(e,null,t)}catch(r){return this.logError("broadcast","connectToVideo",[e,t],"error connecting to video [err="+r+"]"),!1}return!0},setStreamName:function(e,t){try{this.getSwf().tfBroadcastSetStreamName(e,t)}catch(r){return this.logError("broadcast","setStreamName",[e,t],"error setting stream name [err="+r+"]"),!1}return!0},broadcastAttachCamera:function(e,t){try{this.getSwf().tfBroadcastAttachCamera(e,t)}catch(r){return this.logError("broadcast","broadcastAttachCamera",[e,t],"error attaching camera to broadcast [err="+r+"]"),!1}return!0},broadcastAttachMicrophone:function(e,t){try{this.getSwf().tfBroadcastAttachMicrophone(e,t)}catch(r){return this.logError("broadcast","broadcastAttachMicrophone",[e,t],"error attaching mic to broadcast [err="+r+"]"),!1}return!0}}},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default={createCamera:function(){try{return this.getSwf().tfCameraCreate()}catch(e){return this.logError("camera","createCamera",[],"error creating camera [err="+e+"]"),!1}},destroyCamera:function(e){try{this.getSwf().tfCameraDestroy(e)}catch(t){return this.logError("camera","destroyCamera",[e],"error destroying camera [err="+t+"]"),!1}return!0},cameraSetQuality:function(e,t,r){try{this.getSwf().tfCameraSetQuality(e,t,r)}catch(n){return this.logError("Camera","cameraSetQuality",[e,t,r],"error setting camera quality [err="+n+"]"),!1}return!0},cameraSetMode:function(e,t,r,n,i){try{this.getSwf().tfCameraSetMode(e,t,r,n,i)}catch(o){return this.logError("camera","cameraSetMode",[e,t,r,n,i],"error setting camera mode [err="+o+"]"),!1}return!0},cameraSetKeyFrameInterval:function(e,t){try{this.getSwf().tfCameraSetKeyFrameInterval(e,t)}catch(r){return this.logError("camera","cameraSetKeyFrameInterval",[e,t],"error setting key frame interval [err="+r+"]"),!1}return!0},getProperty:function(e,t){try{this.getSwf().tfGetCameraProperty(e,t)}catch(r){return this.logError("camera","getProperty",[e,t],"cannot get property from Camera [err="+r+"]"),!1}return!0},cameraAttachToStage:function(e){try{this.getSwf().tfCameraAttachToStage(e)}catch(t){return this.logError("camera","cameraAttachToStage",[e],"error adding camera to stage [err="+t+"]"),!1}return!0},cameraDetachFromStage:function(e){try{this.getSwf().tfCameraDetachFromStage(e)}catch(t){return this.logError("camera","cameraDetachFromStage",[e],"error detaching camera from stage [err="+t+"]"),!1}return!0},cameraSetDisplayProperties:function(e,t){try{this.getSwf().tfCameraSetDisplayProperties(e,t)}catch(r){return this.logError("camera","cameraSetDisplayProperties",[e,t],"error set camera display properties [err="+r+"]"),!1}return!0}}},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default={createMicrophone:function(){try{return this.getSwf().tfMicrophoneCreate()}catch(e){return this.logError("microphone","createMicrophone",[],"error creating microphone [err="+e+"]"),!1}},setVolume:function(e,t){try{return this.getSwf().tfSetMicrophoneVolume(e,t)}catch(e){return this.logError("microphone","createMicrophone",[],"error creating microphone [err="+e+"]"),!1}},getVolume:function(e){try{return this.getSwf().tfGetMicrophoneVolume(e)}catch(e){return this.logError("microphone","createMicrophone",[],"error creating microphone [err="+e+"]"),!1}},destroyMicrophone:function(e){try{this.getSwf().tfMicrophoneDestroy(e)}catch(t){return this.logError("microphone","destroyMicrophone",[e],"error destroying microphone [err="+t+"]"),!1}return!0},micUseEchoSuppression:function(e,t){try{this.getSwf().tfMicrophoneSetUseEchoSuppression(e,t)}catch(r){return this.logError("microphone","micUseEchoSuppression",[e,t],"error setting suppression [err="+r+"]"),!1}return!0},getProperty:function(e,t){try{return this.getSwf().tfGetMicrophoneProperty(e,t)}catch(r){return this.logError("microphone","getProperty",[e,t],"cannot get property on Microphone"),!1}},setProperty:function(e,t,r){try{return this.getSwf().tfSetMicrophoneProperty(t,r)}catch(n){return this.logError("microphone","setProperty",[t,e,r],"cannot set property on microphone"),!1}}}},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default={playbackPlay:function(e,t){try{this.getSwf().tfPlaybackPlay(e,t)}catch(r){return this.logError("playback","playbackPlay",[e,t],"error playing video [err="+r+"]"),!1}return!0},setVolume:function(e,t){try{this.getSwf().tfPlaybackSetVolume(e,t)}catch(r){return this.logError("playback","setVolume",[e,t],"error setting volume [err="+r+"]"),!1}return!0},muteAudio:function(e,t){try{this.getSwf().tfPlaybackMute(e,t)}catch(r){return this.logError("playback","muteAudio",[e,t],"error muting audio [err="+r+"]"),!1}return!0},pausePlayback:function(e,t){try{this.getSwf().tfPlaybackPause(e,t)}catch(r){return this.logError("playback","pausePlayback",[e,t],"error pausing playback [err="+r+"]"),!1}return!0},pausePlaybackToggle:function(e){try{this.getSwf().tfPlaybackTogglePause(e)}catch(t){return this.logError("playback","pausePlaybackToggle",[e],"error pausing playback [err="+t+"]"),!1}return!0},createStream:function(e,t){try{this.getSwf().tfBroadcastCreateStream(e,t)}catch(t){return this.logError("playback","createStream",[e],"error creating stream [err="+t+"]"),!1}return!0},destroyStream:function(e,t){try{this.getSwf().tfBroadcastDestroyStream(e,t)}catch(r){return this.logError("playback","destroyStream",[e,t],"error destroying stream [err="+r+"]"),!1}return!0},setCurrentStreamIndex:function(e,t){try{this.getSwf().tfBroadcastSetCurrentStreamIndex(e,t)}catch(r){return this.logError("playback","setCurrentStreamIndex",[e,t],"error setting stream index [err="+r+"]"),!1}return!0},getNetStreamProperty:function(e,t){try{return this.getSwf().tfGetNetStreamProperty(e,t)}catch(r){return this.logError("playback","getNetStreamProperty",[e,t],"error getting NetStream property [err="+r+"]"),!1}},setNetStreamProperty:function(e,t,r){try{this.getSwf().tfSetNetStreamProperty(e,t,r)}catch(n){return this.logError("playback","setVideoProperties",[e,t,r],"error setting NetStream property [err="+n+"]"),!1}return!0},invokeNetStreamMethod:function(e,t){try{var r;(r=this.getSwf()).tfInvokeNetStreamMethod.apply(r,arguments)}catch(r){return this.logError("playback","invokeNetStreamMethod",[e,t],"error invoking NetStream method [err="+r+"]"),!1}return!0},setVideoProperties:function(e,t,r){try{var n;(n=this.getSwf()).tfSetVideoProperties.apply(n,arguments)}catch(n){return this.logError("playback","setVideoProperties",[e,t,r],"error setting video properties [err="+n+"]"),!1}return!0}}},function(e,t){"use strict";/**
 * @license ThinFlash
 * Copyright (c) 2014 Accretive Technology Group, Inc.  http://accretivetg.com
 * MIT Licensed  https://github.com/accretive/thinflash/blob/master/LICENSE
 */
var r={width:320,height:240,fps:15,favorArea:!0},n={bandwidth:144e3,quality:85},i={active:!1,pending:!1,dead:!0};e.exports={mode:r,quality:n,keyFrameInterval:60,status:i}},function(e,t){"use strict";/**
 * @license ThinFlash
 * Copyright (c) 2014 Accretive Technology Group, Inc.  http://accretivetg.com
 * MIT Licensed  https://github.com/accretive/thinflash/blob/master/LICENSE
 *
 * @file broadcastSettings.js - A FACTORY for providing a simple wrapper around
 * a broadcasts rtmp information.
 */
var r=[{name:"Modem (56K) wide",id:"9",mode:"160,90,12",keyframeinterval:"12",quality:"16384,0",level:"LEVEL_3",profile:"MAIN",ish264:"1",isdefault:"0"},{name:"ISDN (128K) wide",id:"10",mode:"320,180,12",keyframeinterval:"12",quality:"49152,0",level:"LEVEL_3",profile:"MAIN",ish264:"1",isdefault:"0"},{name:"DSL (256K) wide",id:"11",mode:"320,180,15",keyframeinterval:"15",quality:"65536,0",level:"LEVEL_3",profile:"MAIN",ish264:"1",isdefault:"0"},{name:"Cable (512K) wide",id:"12",mode:"320,180,24",keyframeinterval:"24",quality:"128000,0",level:"LEVEL_3",profile:"MAIN",ish264:"1",isdefault:"0"},{name:"HD (Low) wide",id:"13",mode:"640,360,24",keyframeinterval:"72",quality:"128000,30",level:"LEVEL_3",profile:"MAIN",ish264:"1",isdefault:"1"},{name:"HD (High) wide",id:"14",mode:"640,360,30",keyframeinterval:"150",quality:"128000,40",level:"LEVEL_3",profile:"MAIN",ish264:"1",isdefault:"0"},{name:"Modem (56K)",id:"15",mode:"160,120,12",keyframeinterval:"12",quality:"16384,0",level:"LEVEL_3",profile:"MAIN",ish264:"1",isdefault:"0"},{name:"ISDN (128K)",id:"16",mode:"320,240,12",keyframeinterval:"12",quality:"49152,0",level:"LEVEL_3",profile:"MAIN",ish264:"1",isdefault:"0"},{name:"DSL (256K)",id:"17",mode:"320,240,15",keyframeinterval:"15",quality:"65536,0",level:"LEVEL_3",profile:"MAIN",ish264:"1",isdefault:"0"},{name:"Cable (512K)",id:"18",mode:"320,240,24",keyframeinterval:"24",quality:"128000,0",level:"LEVEL_3",profile:"MAIN",ish264:"1",isdefault:"0"},{name:"HD (Low)",id:"19",mode:"640,480,24",keyframeinterval:"72",quality:"128000,30",level:"LEVEL_3",profile:"MAIN",ish264:"1",isdefault:"0"},{name:"HD (High)",id:"20",mode:"640,480,30",keyframeinterval:"150",quality:"128000,40",level:"LEVEL_3",profile:"MAIN",ish264:"1",isdefault:"0"}];e.exports={encoderSettings:r,preset:r[4]}},function(e,t){"use strict";/**
 * @license ThinFlash
 * Copyright (c) 2014 Accretive Technology Group, Inc.  http://accretivetg.com
 * MIT Licensed  https://github.com/accretive/thinflash/blob/master/LICENSE
 */
var r={active:!1,pending:!1,dead:!0};e.exports={useEchoSuppression:!1,status:r}},function(e,t){function r(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function n(e){return"function"==typeof e}function i(e){return"number"==typeof e}function o(e){return"object"==typeof e&&null!==e}function s(e){return void 0===e}e.exports=r,r.EventEmitter=r,r.prototype._events=void 0,r.prototype._maxListeners=void 0,r.defaultMaxListeners=10,r.prototype.setMaxListeners=function(e){if(!i(e)||e<0||isNaN(e))throw TypeError("n must be a positive number");return this._maxListeners=e,this},r.prototype.emit=function(e){var t,r,i,a,c,u;if(this._events||(this._events={}),"error"===e&&(!this._events.error||o(this._events.error)&&!this._events.error.length)){if(t=arguments[1],t instanceof Error)throw t;var l=new Error('Uncaught, unspecified "error" event. ('+t+")");throw l.context=t,l}if(r=this._events[e],s(r))return!1;if(n(r))switch(arguments.length){case 1:r.call(this);break;case 2:r.call(this,arguments[1]);break;case 3:r.call(this,arguments[1],arguments[2]);break;default:a=Array.prototype.slice.call(arguments,1),r.apply(this,a)}else if(o(r))for(a=Array.prototype.slice.call(arguments,1),u=r.slice(),i=u.length,c=0;c<i;c++)u[c].apply(this,a);return!0},r.prototype.addListener=function(e,t){var i;if(!n(t))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",e,n(t.listener)?t.listener:t),this._events[e]?o(this._events[e])?this._events[e].push(t):this._events[e]=[this._events[e],t]:this._events[e]=t,o(this._events[e])&&!this._events[e].warned&&(i=s(this._maxListeners)?r.defaultMaxListeners:this._maxListeners,i&&i>0&&this._events[e].length>i&&(this._events[e].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[e].length),"function"==typeof console.trace&&console.trace())),this},r.prototype.on=r.prototype.addListener,r.prototype.once=function(e,t){function r(){this.removeListener(e,r),i||(i=!0,t.apply(this,arguments))}if(!n(t))throw TypeError("listener must be a function");var i=!1;return r.listener=t,this.on(e,r),this},r.prototype.removeListener=function(e,t){var r,i,s,a;if(!n(t))throw TypeError("listener must be a function");if(!this._events||!this._events[e])return this;if(r=this._events[e],s=r.length,i=-1,r===t||n(r.listener)&&r.listener===t)delete this._events[e],this._events.removeListener&&this.emit("removeListener",e,t);else if(o(r)){for(a=s;a-- >0;)if(r[a]===t||r[a].listener&&r[a].listener===t){i=a;break}if(i<0)return this;1===r.length?(r.length=0,delete this._events[e]):r.splice(i,1),this._events.removeListener&&this.emit("removeListener",e,t)}return this},r.prototype.removeAllListeners=function(e){var t,r;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[e]&&delete this._events[e],this;if(0===arguments.length){for(t in this._events)"removeListener"!==t&&this.removeAllListeners(t);return this.removeAllListeners("removeListener"),this._events={},this}if(r=this._events[e],n(r))this.removeListener(e,r);else if(r)for(;r.length;)this.removeListener(e,r[r.length-1]);return delete this._events[e],this},r.prototype.listeners=function(e){var t;return t=this._events&&this._events[e]?n(this._events[e])?[this._events[e]]:this._events[e].slice():[]},r.prototype.listenerCount=function(e){if(this._events){var t=this._events[e];if(n(t))return 1;if(t)return t.length}return 0},r.listenerCount=function(e,t){return e.listenerCount(t)}},function(e,t,r){/*!    SWFObject v2.3.20120118 <http://github.com/swfobject/swfobject>
    is released under the MIT License <http://www.opensource.org/licenses/mit-license.php>
*/
!function(t,r){e.exports=r()}(this,function(){function e(){if(!X&&document.getElementsByTagName("body")[0]){try{var e,t=m("span");t.style.display="none",e=B.getElementsByTagName("body")[0].appendChild(t),e.parentNode.removeChild(e),e=null,t=null}catch(e){return}X=!0;for(var r=U.length,n=0;n<r;n++)U[n]()}}function t(e){X?e():U[U.length]=e}function r(e){if(typeof N.addEventListener!=M)N.addEventListener("load",e,!1);else if(typeof B.addEventListener!=M)B.addEventListener("load",e,!1);else if(typeof N.attachEvent!=M)g(N,"onload",e);else if("function"==typeof N.onload){var t=N.onload;N.onload=function(){t(),e()}}else N.onload=e}function n(){var e=B.getElementsByTagName("body")[0],t=m(j);t.setAttribute("style","visibility: hidden;"),t.setAttribute("type",P);var r=e.appendChild(t);if(r){var n=0;!function o(){if(typeof r.GetVariable!=M)try{var s=r.GetVariable("$version");s&&(s=s.split(" ")[1].split(","),J.pv=[b(s[0]),b(s[1]),b(s[2])])}catch(e){J.pv=[8,0,0]}else if(n<10)return n++,void setTimeout(o,10);e.removeChild(t),r=null,i()}()}else i()}function i(){var e=F.length;if(e>0)for(var t=0;t<e;t++){var r=F[t].id,n=F[t].callbackFn,i={success:!1,id:r};if(J.pv[0]>0){var u=y(r);if(u)if(!w(F[t].swfVersion)||J.wk&&J.wk<312)if(F[t].expressInstall&&s()){var l={};l.data=F[t].expressInstall,l.width=u.getAttribute("width")||"0",l.height=u.getAttribute("height")||"0",u.getAttribute("class")&&(l.styleclass=u.getAttribute("class")),u.getAttribute("align")&&(l.align=u.getAttribute("align"));for(var f={},h=u.getElementsByTagName("param"),d=h.length,p=0;p<d;p++)"movie"!=h[p].getAttribute("name").toLowerCase()&&(f[h[p].getAttribute("name")]=h[p].getAttribute("value"));a(l,f,r,n)}else c(u),n&&n(i);else E(r,!0),n&&(i.success=!0,i.ref=o(r),i.id=r,n(i))}else if(E(r,!0),n){var v=o(r);v&&typeof v.SetVariable!=M&&(i.success=!0,i.ref=v,i.id=v.id),n(i)}}}function o(e){var t=null,r=y(e);return r&&"OBJECT"===r.nodeName.toUpperCase()&&(t=typeof r.SetVariable!==M?r:r.getElementsByTagName(j)[0]||r),t}function s(){return!G&&w("6.0.65")&&(J.win||J.mac)&&!(J.wk&&J.wk<312)}function a(e,t,r,n){var i=y(r);if(r=v(r),G=!0,A=n||null,O={success:!1,id:r},i){"OBJECT"==i.nodeName.toUpperCase()?(k=u(i),L=null):(k=i,L=r),e.id=R,(typeof e.width==M||!/%$/.test(e.width)&&b(e.width)<310)&&(e.width="310"),(typeof e.height==M||!/%$/.test(e.height)&&b(e.height)<137)&&(e.height="137"),B.title=B.title.slice(0,47)+" - Flash Player Installation";var o=J.ie?"ActiveX":"PlugIn",s="MMredirectURL="+encodeURIComponent(N.location.toString().replace(/&/g,"%26"))+"&MMplayerType="+o+"&MMdoctitle="+B.title;if(typeof t.flashvars!=M?t.flashvars+="&"+s:t.flashvars=s,J.ie&&4!=i.readyState){var a=m("div");r+="SWFObjectNew",a.setAttribute("id",r),i.parentNode.insertBefore(a,i),i.style.display="none",d(i)}f(e,t,r)}}function c(e){if(J.ie&&4!=e.readyState){e.style.display="none";var t=m("div");e.parentNode.insertBefore(t,e),t.parentNode.replaceChild(u(e),t),d(e)}else e.parentNode.replaceChild(u(e),e)}function u(e){var t=m("div");if(J.win&&J.ie)t.innerHTML=e.innerHTML;else{var r=e.getElementsByTagName(j)[0];if(r){var n=r.childNodes;if(n)for(var i=n.length,o=0;o<i;o++)1==n[o].nodeType&&"PARAM"==n[o].nodeName||8==n[o].nodeType||t.appendChild(n[o].cloneNode(!0))}}return t}function l(e,t){var r=m("div");return r.innerHTML="<object classid='clsid:D27CDB6E-AE6D-11cf-96B8-444553540000'><param name='movie' value='"+e+"'>"+t+"</object>",r.firstChild}function f(e,t,r){var n,i=y(r);if(r=v(r),J.wk&&J.wk<312)return n;if(i){var o,s,a,c=m(J.ie?"div":j);typeof e.id==M&&(e.id=r);for(a in t)t.hasOwnProperty(a)&&"movie"!==a.toLowerCase()&&h(c,a,t[a]);J.ie&&(c=l(e.data,c.innerHTML));for(o in e)e.hasOwnProperty(o)&&(s=o.toLowerCase(),"styleclass"===s?c.setAttribute("class",e[o]):"classid"!==s&&"data"!==s&&c.setAttribute(o,e[o]));J.ie?K[K.length]=e.id:(c.setAttribute("type",P),c.setAttribute("data",e.data)),i.parentNode.replaceChild(c,i),n=c}return n}function h(e,t,r){var n=m("param");n.setAttribute("name",t),n.setAttribute("value",r),e.appendChild(n)}function d(e){var t=y(e);t&&"OBJECT"==t.nodeName.toUpperCase()&&(J.ie?(t.style.display="none",function e(){if(4==t.readyState){for(var r in t)"function"==typeof t[r]&&(t[r]=null);t.parentNode.removeChild(t)}else setTimeout(e,10)}()):t.parentNode.removeChild(t))}function p(e){return e&&e.nodeType&&1===e.nodeType}function v(e){return p(e)?e.id:e}function y(e){if(p(e))return e;var t=null;try{t=B.getElementById(e)}catch(e){}return t}function m(e){return B.createElement(e)}function b(e){return parseInt(e,10)}function g(e,t,r){e.attachEvent(t,r),H[H.length]=[e,t,r]}function w(e){e+="";var t=J.pv,r=e.split(".");return r[0]=b(r[0]),r[1]=b(r[1])||0,r[2]=b(r[2])||0,t[0]>r[0]||t[0]==r[0]&&t[1]>r[1]||t[0]==r[0]&&t[1]==r[1]&&t[2]>=r[2]}function _(e,t,r,n){var i=B.getElementsByTagName("head")[0];if(i){var o="string"==typeof r?r:"screen";if(n&&(C=null,T=null),!C||T!=o){var s=m("style");s.setAttribute("type","text/css"),s.setAttribute("media",o),C=i.appendChild(s),J.ie&&typeof B.styleSheets!=M&&B.styleSheets.length>0&&(C=B.styleSheets[B.styleSheets.length-1]),T=o}C&&(typeof C.addRule!=M?C.addRule(e,t):typeof B.createTextNode!=M&&C.appendChild(B.createTextNode(e+" {"+t+"}")))}}function E(e,t){if($){var r=t?"visible":"hidden",n=y(e);X&&n?n.style.visibility=r:"string"==typeof e&&_("#"+e,"visibility:"+r)}}function S(e){var t=/[\\\"<>\.;]/,r=null!=t.exec(e);return r&&typeof encodeURIComponent!=M?encodeURIComponent(e):e}var k,L,A,O,C,T,M="undefined",j="object",x="Shockwave Flash",I="ShockwaveFlash.ShockwaveFlash",P="application/x-shockwave-flash",R="SWFObjectExprInst",D="onreadystatechange",N=window,B=document,V=navigator,q=!1,U=[],F=[],K=[],H=[],X=!1,G=!1,$=!0,W=!1,J=function(){var e=typeof B.getElementById!=M&&typeof B.getElementsByTagName!=M&&typeof B.createElement!=M,t=V.userAgent.toLowerCase(),r=V.platform.toLowerCase(),n=r?/win/.test(r):/win/.test(t),i=r?/mac/.test(r):/mac/.test(t),o=!!/webkit/.test(t)&&parseFloat(t.replace(/^.*webkit\/(\d+(\.\d+)?).*$/,"$1")),s="Microsoft Internet Explorer"===V.appName,a=[0,0,0],c=null;if(typeof V.plugins!=M&&typeof V.plugins[x]==j)c=V.plugins[x].description,c&&typeof V.mimeTypes!=M&&V.mimeTypes[P]&&V.mimeTypes[P].enabledPlugin&&(q=!0,s=!1,c=c.replace(/^.*\s+(\S+\s+\S+$)/,"$1"),a[0]=b(c.replace(/^(.*)\..*$/,"$1")),a[1]=b(c.replace(/^.*\.(.*)\s.*$/,"$1")),a[2]=/[a-zA-Z]/.test(c)?b(c.replace(/^.*[a-zA-Z]+(.*)$/,"$1")):0);else if(typeof N.ActiveXObject!=M)try{var u=new ActiveXObject(I);u&&(c=u.GetVariable("$version"),c&&(s=!0,c=c.split(" ")[1].split(","),a=[b(c[0]),b(c[1]),b(c[2])]))}catch(e){}return{w3:e,pv:a,wk:o,ie:s,win:n,mac:i}}();return function(){J.w3&&((typeof B.readyState!=M&&("complete"===B.readyState||"interactive"===B.readyState)||typeof B.readyState==M&&(B.getElementsByTagName("body")[0]||B.body))&&e(),X||(typeof B.addEventListener!=M&&B.addEventListener("DOMContentLoaded",e,!1),J.ie&&(B.attachEvent(D,function t(){"complete"==B.readyState&&(B.detachEvent(D,t),e())}),N==top&&!function t(){if(!X){try{B.documentElement.doScroll("left")}catch(e){return void setTimeout(t,0)}e()}}()),J.wk&&!function t(){if(!X)return/loaded|complete/.test(B.readyState)?void e():void setTimeout(t,0)}()))}(),U[0]=function(){q?n():i()},function(){J.ie&&window.attachEvent("onunload",function(){for(var e=H.length,t=0;t<e;t++)H[t][0].detachEvent(H[t][1],H[t][2]);for(var r=K.length,n=0;n<r;n++)d(K[n]);for(var i in J)J[i]=null;if(J=null,"undefined"!=typeof swfobject){for(var o in swfobject)swfobject[o]=null;swfobject=null}})}(),{registerObject:function(e,t,r,n){if(J.w3&&e&&t){var i={};i.id=e,i.swfVersion=t,i.expressInstall=r,i.callbackFn=n,F[F.length]=i,E(e,!1)}else n&&n({success:!1,id:e})},getObjectById:function(e){if(J.w3)return o(e)},embedSWF:function(e,r,n,i,o,c,u,l,h,d){var p=v(r),y={success:!1,id:p};J.w3&&!(J.wk&&J.wk<312)&&e&&r&&n&&i&&o?(E(p,!1),t(function(){n+="",i+="";var t={};if(h&&typeof h===j)for(var v in h)t[v]=h[v];t.data=e,t.width=n,t.height=i;var m={};if(l&&typeof l===j)for(var b in l)m[b]=l[b];if(u&&typeof u===j)for(var g in u)if(u.hasOwnProperty(g)){var _=W?encodeURIComponent(g):g,S=W?encodeURIComponent(u[g]):u[g];typeof m.flashvars!=M?m.flashvars+="&"+_+"="+S:m.flashvars=_+"="+S}if(w(o)){var k=f(t,m,r);t.id==p&&E(p,!0),y.success=!0,y.ref=k,y.id=k.id}else{if(c&&s())return t.data=c,void a(t,m,r,d);E(p,!0)}d&&d(y)})):d&&d(y)},switchOffAutoHideShow:function(){$=!1},enableUriEncoding:function(e){W=typeof e===M||e},ua:J,getFlashPlayerVersion:function(){return{major:J.pv[0],minor:J.pv[1],release:J.pv[2]}},hasFlashPlayerVersion:w,createSWF:function(e,t,r){return J.w3?f(e,t,r):void 0},showExpressInstall:function(e,t,r,n){J.w3&&s()&&a(e,t,r,n)},removeSWF:function(e){J.w3&&d(e)},createCSS:function(e,t,r,n){J.w3&&_(e,t,r,n)},addDomLoadEvent:t,addLoadEvent:r,getQueryParamValue:function(e){var t=B.location.search||B.location.hash;if(t){if(/\?/.test(t)&&(t=t.split("?")[1]),null==e)return S(t);for(var r=t.split("&"),n=0;n<r.length;n++)if(r[n].substring(0,r[n].indexOf("="))==e)return S(r[n].substring(r[n].indexOf("=")+1))}return""},expressInstallCallback:function(){if(G){var e=y(R);e&&k&&(e.parentNode.replaceChild(k,e),L&&(E(L,!0),J.ie&&(k.style.display="block")),A&&A(O)),G=!1}},version:"2.3"}})},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function o(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function s(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}var a=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),c=r(7),u=n(c),l=r(8),f=n(l),h=r(0),d=n(h),p=r(1),v=n(p),y=r(2),m=n(y),b=r(3),g=n(b),w=r(4),_=n(w),E=r(5),S=n(E),k=r(6),L=n(k),A="11.0.0",O="aiwswfbroadcast",C=0,T=function(e){function t(e,r,n){i(this,t);var s=o(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return s.el=e,s.accessKey=r,s.options=n,s.encodingSettings=n.encodingSettings||S.default.preset,s.origin=n.rtmpUrl,s.origin||s.emit("error","no origin supplied"),s.origin+="?host="+s.options.host,s.options.affiliate&&(s.origin+="&affiliate="+s.options.affiliate),s.id=C++,s.broadcastId=null,s.cameraId=null,s.microphoneId=null,s.swf=null,s.pollingTf=null,s.pollingTfAttempts=0,s.devicesAttempts=0,s.tfIsReadyCbs=[],s.render(),s.setupThinflash(function(){s.emit("ready")}),s}return s(t,e),a(t,[{key:"supportsDevices",value:function(){return!1}},{key:"supportsMute",value:function(){return!0}},{key:"supportsEncodingSettings",value:function(){return!0}},{key:"onceDevicesAreReady",value:function(e){var t=this;return this.devicesAttempts++,this.cameraId||(this.cameraId=this.cameraApi.createCamera()),this.microphoneId||this.createMicrophone(),this.cameraId&&this.microphoneId?void e():this.devicesAttempts>10?void this.emit("error","no devices"):void setTimeout(function(){t.onceDevicesAreReady(e)},200)}},{key:"onceTfIsReady",value:function(e){return this.swf&&this.swf.tfBroadcastCreate?void e():(this.tfIsReadyCbs.push(e),void this.pollTf())}},{key:"pollTf",value:function(){var e=this;this.pollingTf||(this.pollingTfAttempts=0,clearInterval(this.pollingTf),this.pollingTf=setInterval(function(){if(e.pollingTfAttempts++,e.pollingTfAttempts>30)return clearInterval(e.pollingTf),void e.emit("error","embedding swf timed out");if(e.swf&&e.swf.tfBroadcastCreate){clearInterval(e.pollingTf);for(var t=e.tfIsReadyCbs.shift();t;)t(),t=e.tfIsReadyCbs.shift()}},20))}},{key:"getDetails",value:function(){var e={state:this.state};if(this.broadcastId){var t=this.swf.tfGetNetStreamProperty(this.broadcastId,"info");e.droppedFrames=t.droppedFrames,e.kbps=.008*t.currentBytesPerSecond}return e}},{key:"destroy",value:function(){this.stop(),this.cameraApi.cameraDetachFromStage(this.cameraId),this.cameraApi.destroyCamera(this.cameraId),this.microphoneApi.destroyMicrophone(this.microphoneId),this.swf&&this.swf.remove()}},{key:"stop",value:function(e){this.cameraId&&(this.cameraApi.cameraDetachFromStage(this.cameraId),this.cameraApi.destroyCamera(this.cameraId),this.cameraId=null),this.microphoneId&&(this.microphoneApi.destroyMicrophone(this.microphoneId),this.microphoneId=null),this.broadcastId?this.broadcastApi.destroyBroadcast(this.broadcastId)?(this.broadcastId=null,this.emit("stop")):(this.broadcastId=null,this.emit("error","stop failed")):this.emit("stop"),this.setup(e)}},{key:"attachCamera",value:function(){this.cameraApi.cameraSetMode(this.cameraId,_.default.mode.width,_.default.mode.height,_.default.mode.fps,_.default.mode.favorArea),this.cameraApi.cameraSetQuality(this.cameraId,this.encodingSettings.quality.split(",")[0],this.encodingSettings.quality.split(",")[1]),this.cameraApi.cameraSetKeyFrameInterval(this.cameraId,this.encodingSettings.keyframeinterval),this.options.preview&&this.cameraApi.cameraAttachToStage(this.cameraId)}},{key:"createMicrophone",value:function(){this.microphoneId=this.microphoneApi.createMicrophone(),this.microphoneApi.micUseEchoSuppression(this.microphoneId,L.default.useEchoSuppression)}},{key:"broadcast",value:function(e){var t=this;this.setupThinflash(function(){return t.broadcastId=t.broadcastApi.createBroadcast(),t.broadcastId?(t.once("BroadcastEvent",function(){t.broadcastApi.broadcastAttachCamera(t.broadcastId,t.cameraId),t.microphoneId&&t.broadcastApi.broadcastAttachMicrophone(t.broadcastId,t.microphoneId),t.emit("broadcasting"),e&&e()}),void t.broadcastApi.connectToBroadcast.apply(t.broadcastApi,[t.broadcastId,t.origin,t.accessKey].concat(t.options.tfArgs))):void t.emit("error","could not start broadcast")})}},{key:"enumerateDevices",value:function(){return null}},{key:"setup",value:function(e){var t=this;this.onceDevicesAreReady(function(){t.attachCamera(),e&&e()})}},{key:"render",value:function(){this.obj=document.createElement("div"),this.el.appendChild(this.obj),this.obj.setAttribute("class","aiw-swf-container"),this.obj.setAttribute("id",O+"_"+this.id)}},{key:"setupThinflash",value:function(e){var t=this;if(this.swf)return void(e&&e());if(this.loading)return void setTimeout(this.setupThinflash.bind(this,e),50);window.tfSendToJavaScript=function(e,r,n){if(e===t.obj.getAttribute("id")){switch(n[1]){case"NetConnection.Connect.Closed":t.stop()}t.emit(r,n[1],n[0],n.slice(2))}},window.tfIsReady=function(){return!0};var r=function(e){var r=Object.create(e);return r.logError=function(){for(var e=arguments.length,r=Array(e),n=0;n<e;n++)r[n]=arguments[n];t.emit("tf-error",r)},r.getSwf=function(){return t.swf},r};this.broadcastApi=r(d.default),this.cameraApi=r(v.default),this.microphoneApi=r(m.default),this.playbackApi=r(g.default),f.default.embedSWF(this.options.tfSwfPath,this.obj.getAttribute("id"),"100%","100%",11,"/dist/expressInstall.swf",{tfID:this.obj.getAttribute("id")},{scale:"noscale",quality:"high",allowscriptaccess:"always",allowfullscreen:"true",wmode:"direct",align:"middle",salign:"TL",menu:"true",id:this.obj.getAttribute("id")},{id:this.obj.getAttribute("id"),class:"tf-content"},function(r){return t.swf=r.ref,t.swf?void t.onceTfIsReady(function(){t.onceDevicesAreReady(function(){t.attachCamera(),e&&e(r)})}):(t.emit("error","embedding swf failed"),void(e&&e()))})}},{key:"encodingSettings",set:function(e){var t=this;return e.quality&&"string"==typeof e.quality?isNaN(e.keyframeinterval)?void this.emit("error","encoder settings must include a keyframeinterval, must be a number"):"broadcasting"!==this.state?void(this.encodingSettingsValue=e):void this.stop(function(){t.encodingSettingsValue=e,t.broadcast()}):void this.emit("error","encoder settings must include a quality, must be a string")},get:function(){return this.encodingSettingsValue||S.default.preset}},{key:"mute",set:function(e){return!!this.microphoneId&&(e?this.microphoneApi.setVolume(this.microphoneId,0):this.microphoneApi.setVolume(this.microphoneId,60),this.emit(this.mute?"mute":"unmute"),this.mute)},get:function(){return!!this.microphoneId&&!this.microphoneApi.getVolume(this.microphoneId)}},{key:"state",get:function(){return this.broadcastId?"broadcasting":"stopped"}}],[{key:"isSupported",value:function(){return f.default.hasFlashPlayerVersion(A)}}]),t}(u.default);e.exports=T}])})},function(e,t,r){!function(t,r){e.exports=r()}(this,function(){return function(e){function t(n){if(r[n])return r[n].exports;var i=r[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,t),i.l=!0,i.exports}var r={};return t.m=e,t.c=r,t.i=function(e){return e},t.d=function(e,t,r){Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=6)}([function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function o(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function s(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),c=r(5),u=n(c),l=r(1),f=n(l),h=r(2),d=n(h),p=r(3),v=n(p);r(4);var y={accessKey:null,affiliate:null,drivers:["flash","webrtc"],flashWmode:"transparent",gateway:null,host:null,iceServers:[],preview:!0,rtmpUrl:null,tfArgs:[],tfSwfPath:"",user:null},m=function(e){function t(e,r,n){i(this,t);var s=o(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));if(s.el=e,s.accessKey=r,s.options=(0,v.default)(n,y),!s.options.affiliate)throw new Error("affiliate required for broadcaster");if(!s.options.host)throw new Error("host required for broadcaster");s.drivers=[],s.currentDriver=null;for(var a=0;a<s.options.drivers.length;a++)s.options.drivers[a].isSupported()&&s.drivers.push(s.options.drivers[a]);return s.setup(),s}return s(t,e),a(t,[{key:"setup",value:function(){return this.drivers.length?(this.currentDriver=new this.drivers[0](this.el,this.accessKey,(0,v.default)(this.options)),void this.proxyEvents()):void this.emit(d.default.ERROR,f.default.NO_DRIVERS)}},{key:"broadcast",value:function(){var e=this;return this.currentDriver||this.setup(),this.currentDriver?void this.currentDriver.broadcast(function(){e.emit(d.default.START)}):void this.emit(d.default.NO_DRIVERS)}},{key:"proxyEvent",value:function(e){return function(){for(var t=arguments.length,r=Array(t),n=0;n<t;n++)r[n]=arguments[n];this.emit.apply(this,[e].concat(r))}.bind(this)}},{key:"proxyEvents",value:function(){for(var e in d.default)this.currentDriver.on(d.default[e],this.proxyEvent(d.default[e]))}},{key:"destroy",value:function(){this.currentDriver&&this.currentDriver.destroy()}},{key:"stop",value:function(){var e=this;return this.currentDriver?void this.currentDriver.stop(function(){e.emit(d.default.STOP)}):void this.emit(d.default.ERROR,"cannot stop, no driver set")}},{key:"enumerateDevices",value:function(){return this.currentDriver?this.currentDriver.enumerateDevices?this.currentDriver.enumerateDevices():null:(this.emit(d.default.ERROR,"cannot get cameras, no driver set"),null)}},{key:"setCamera",value:function(e){return this.currentDriver?void this.currentDriver.setCamera(e):void this.emit(d.default.ERROR,"cannot set camera, no driver set")}},{key:"supportsEncodingSettings",value:function(){return!!this.currentDriver&&this.currentDriver.supportsEncodingSettings()}},{key:"supportsMute",value:function(){return!!this.currentDriver&&this.currentDriver.supportsMute()}},{key:"supportsDevices",value:function(){return!!this.currentDriver&&this.currentDriver.supportsDevices()}},{key:"mute",set:function(e){return this.currentDriver?(this.currentDriver.mute=e,this.currentDriver.mute):void this.emit(d.default.ERROR,"cannot set mute, no driver set")},get:function(){return this.currentDriver?this.currentDriver.mute:void this.emit(d.default.ERROR,"cannot get mute, no driver set")}},{key:"state",get:function(){return this.currentDriver?this.currentDriver.state:"uninitialized"}},{key:"encodingSettings",set:function(e){this.currentDriver&&this.this.currentDriver.supportsEncodingSettings()&&this.currentDriver.setEncodingSettings(e)}}]),t}(u.default);t.default=m},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r={ELEMENT_REQUIRED:"element required",EMBED_SWF_FAILED:"embedding flash swf failed",GATEWAY_ERROR:"gateway error",GATEWAY_HANDLE_ERROR:"gateway create handle error",GATEWAY_REQUIRED:"gateway required",RTC_OFFER_FAILED:"rtc offer failed",SETUP_PEER_ANSWER_FAILED:"setup peer answer failed",NO_DRIVERS:"no supported drivers",NO_DEVICES:"no devices found",STOP_FAILED:"could not stop broadcast",ICE_SERVERS:"no valid ice servers"};t.default=r},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r={UPDATE_STREAM:"update-local-stream",REMOVE_STREAM:"remove-local-stream",ERROR:"error",HANGUP:"hangup",JANUS:"janus",MUTE:"mute",UNMUTE:"unmute",BROADCASTING:"broadcasting",READY:"ready",START:"start",STOP:"stop"};t.default=r},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){var r=e?Object.create(e):{};if(!t)return r;for(var n in t)"undefined"==typeof r[n]&&(r[n]=t[n]);return r}},function(e,t){"use strict";"function"!=typeof Object.create&&(Object.create=function(e){var t=function(){};return function(r,n){if(r!==Object(r)&&null!==r)throw TypeError("Argument must be an object, or null");t.prototype=r||{},n!==e&&Object.defineProperties(t.prototype,n);var i=new t;return t.prototype=null,i}}())},function(e,t){function r(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function n(e){return"function"==typeof e}function i(e){return"number"==typeof e}function o(e){return"object"==typeof e&&null!==e}function s(e){return void 0===e}e.exports=r,r.EventEmitter=r,r.prototype._events=void 0,r.prototype._maxListeners=void 0,r.defaultMaxListeners=10,r.prototype.setMaxListeners=function(e){if(!i(e)||e<0||isNaN(e))throw TypeError("n must be a positive number");return this._maxListeners=e,this},r.prototype.emit=function(e){var t,r,i,a,c,u;if(this._events||(this._events={}),"error"===e&&(!this._events.error||o(this._events.error)&&!this._events.error.length)){if(t=arguments[1],t instanceof Error)throw t;var l=new Error('Uncaught, unspecified "error" event. ('+t+")");throw l.context=t,l}if(r=this._events[e],s(r))return!1;if(n(r))switch(arguments.length){case 1:r.call(this);break;case 2:r.call(this,arguments[1]);break;case 3:r.call(this,arguments[1],arguments[2]);break;default:a=Array.prototype.slice.call(arguments,1),r.apply(this,a)}else if(o(r))for(a=Array.prototype.slice.call(arguments,1),u=r.slice(),i=u.length,c=0;c<i;c++)u[c].apply(this,a);return!0},r.prototype.addListener=function(e,t){var i;if(!n(t))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",e,n(t.listener)?t.listener:t),this._events[e]?o(this._events[e])?this._events[e].push(t):this._events[e]=[this._events[e],t]:this._events[e]=t,o(this._events[e])&&!this._events[e].warned&&(i=s(this._maxListeners)?r.defaultMaxListeners:this._maxListeners,i&&i>0&&this._events[e].length>i&&(this._events[e].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[e].length),"function"==typeof console.trace&&console.trace())),this},r.prototype.on=r.prototype.addListener,r.prototype.once=function(e,t){function r(){this.removeListener(e,r),i||(i=!0,t.apply(this,arguments))}if(!n(t))throw TypeError("listener must be a function");var i=!1;return r.listener=t,this.on(e,r),this},r.prototype.removeListener=function(e,t){var r,i,s,a;if(!n(t))throw TypeError("listener must be a function");if(!this._events||!this._events[e])return this;if(r=this._events[e],s=r.length,i=-1,r===t||n(r.listener)&&r.listener===t)delete this._events[e],this._events.removeListener&&this.emit("removeListener",e,t);else if(o(r)){for(a=s;a-- >0;)if(r[a]===t||r[a].listener&&r[a].listener===t){i=a;break}if(i<0)return this;1===r.length?(r.length=0,delete this._events[e]):r.splice(i,1),this._events.removeListener&&this.emit("removeListener",e,t)}return this},r.prototype.removeAllListeners=function(e){var t,r;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[e]&&delete this._events[e],this;if(0===arguments.length){for(t in this._events)"removeListener"!==t&&this.removeAllListeners(t);return this.removeAllListeners("removeListener"),this._events={},this}if(r=this._events[e],n(r))this.removeListener(e,r);else if(r)for(;r.length;)this.removeListener(e,r[r.length-1]);return delete this._events[e],this},r.prototype.listeners=function(e){var t;return t=this._events&&this._events[e]?n(this._events[e])?[this._events[e]]:this._events[e].slice():[]},r.prototype.listenerCount=function(e){if(this._events){var t=this._events[e];if(n(t))return 1;if(t)return t.length}return 0},r.listenerCount=function(e,t){return e.listenerCount(t)}},function(e,t,r){"use strict";"undefined"==typeof window?e.exports=function(){}:e.exports=r(0).default}])})},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function o(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function s(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),c=r(1),u=n(c),l=r(2),f=n(l),h=r(0),d=n(h),p=function(e){function t(e){i(this,t);var r=o(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return r.stock=e,r.el=(0,d.default)("div",["access_key"]),r.accessKeyDiv=(0,d.default)("div",["access_key__key"]),r.originDiv=(0,d.default)("div",["access_key__origin"]),r.regenerateEl=(0,d.default)("button",["access_key__regenerate"]),r.stock.bar.appendChild(r.el),r.stock.bar.appendChild(r.regenerateEl),r.el.appendChild(r.originDiv),r.el.appendChild(r.accessKeyDiv),(0,f.default)(r.originDiv,"Origin Server: "+r.stock.options.rtmpUrl),(0,f.default)(r.accessKeyDiv,"Access Key: "+r.stock.accessKey),(0,f.default)(r.regenerateEl,"Reset key"),r.regenerateEl.onclick=function(){r.stock.regenerate()},r}return s(t,e),a(t,[{key:"destroy",value:function(){this.el.remove(),this.regenerateEl.remove()}}]),t}(u.default);t.default=p},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function o(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function s(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),c=r(1),u=n(c),l=r(2),f=n(l),h=r(0),d=n(h),p=function(e){function t(e){i(this,t);var r=o(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));r.stock=e,r.el=(0,d.default)("button",["broadcast"]),r.stock.bar.appendChild(r.el);var n=function(){"stopped"===r.stock.broadcaster.state?(r.el.classList.add("stopped"),(0,f.default)(r.el,"Broadcast")):(r.el.classList.remove("stopped"),(0,f.default)(r.el,"Stop"))};n();var s=function(){"stopped"===r.stock.broadcaster.state?r.stock.broadcaster.broadcast():r.stock.broadcaster.stop()};return e.broadcaster.on("start",n),e.broadcaster.on("stop",n),r.el.addEventListener("click",s),r}return s(t,e),a(t,[{key:"destroy",value:function(){this.el.remove()}}]),t}(u.default);t.default=p},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function o(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function s(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),c=r(1),u=n(c),l=r(2),f=n(l),h=r(0),d=n(h),p=function(e){function t(e){i(this,t);var r=o(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return r.stock=e,r.stock.broadcaster.on("error",r.updateError.bind(r)),r.el=(0,d.default)("div",["error"]),r.stock.bar.appendChild(r.el),r.stock.broadcaster.on("start",r.clearError.bind(r)),r.stock.broadcaster.on("error",r.updateError.bind(r)),r}return s(t,e),a(t,[{key:"clearError",value:function(){(0,f.default)(this.el,"")}},{key:"updateError",value:function(e){var t=void 0;switch(e){default:t="Unknown broadcast failure"}(0,f.default)(this.el,t)}},{key:"destroy",value:function(){this.stock.broadcaster.removeListener("error",this.updateError),this.el.remove()}}]),t}(u.default);t.default=p},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function o(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function s(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0
}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),c=r(1),u=n(c),l=r(2),f=n(l),h=r(0),d=n(h),p=function(e){function t(e){i(this,t);var r=o(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));r.stock=e,r.el=(0,d.default)("button",["mute"]),r.stock.bar.appendChild(r.el),r.updateMuteButton();var n=function(){r.stock.broadcaster.mute=!r.stock.broadcaster.mute};return r.stock.broadcaster.on("mute",r.updateMuteButton.bind(r)),r.stock.broadcaster.on("unmute",r.updateMuteButton.bind(r)),r.el.addEventListener("click",n),r}return s(t,e),a(t,[{key:"updateMuteButton",value:function(){(0,f.default)(this.el,this.stock.broadcaster.mute?"Unmute":"Mute")}},{key:"destroy",value:function(){this.stock.broadcaster.removeListener("mute",this.updateMuteButton),this.stock.broadcaster.removeListener("unmute",this.updateMuteButton),this.el.remove()}}]),t}(u.default);t.default=p},function(e,t,r){"use strict";function n(e,t){for(var r=0;r<e.length;r++)t(e[r])}function i(e){for(var t in e)if(e.hasOwnProperty(t))return!1;return!0}function o(e,t,r){var n=e;return f(t)?(r=t,"string"==typeof e&&(n={uri:e})):n=d(t,{uri:e}),n.callback=r,n}function s(e,t,r){return t=o(e,t,r),a(t)}function a(e){function t(){4===f.readyState&&o()}function r(){var e=void 0;if(e=f.response?f.response:f.responseText||c(f),_)try{e=JSON.parse(e)}catch(e){}return e}function n(e){return clearTimeout(v),e instanceof Error||(e=new Error(""+(e||"Unknown XMLHttpRequest Error"))),e.statusCode=0,u(e,l)}function o(){if(!p){var t;clearTimeout(v),t=e.useXDR&&void 0===f.status?200:1223===f.status?204:f.status;var n=l,i=null;return 0!==t?(n={body:r(),statusCode:t,method:m,headers:{},url:y,rawRequest:f},f.getAllResponseHeaders&&(n.headers=h(f.getAllResponseHeaders()))):i=new Error("Internal XMLHttpRequest Error"),u(i,n,n.body)}}if("undefined"==typeof e.callback)throw new Error("callback argument missing");var a=!1,u=function(t,r,n){a||(a=!0,e.callback(t,r,n))},l={body:void 0,headers:{},statusCode:0,method:m,url:y,rawRequest:f},f=e.xhr||null;f||(f=e.cors||e.useXDR?new s.XDomainRequest:new s.XMLHttpRequest);var d,p,v,y=f.url=e.uri||e.url,m=f.method=e.method||"GET",b=e.body||e.data||null,g=f.headers=e.headers||{},w=!!e.sync,_=!1;if("json"in e&&(_=!0,g.accept||g.Accept||(g.Accept="application/json"),"GET"!==m&&"HEAD"!==m&&(g["content-type"]||g["Content-Type"]||(g["Content-Type"]="application/json"),b=JSON.stringify(e.json))),f.onreadystatechange=t,f.onload=o,f.onerror=n,f.onprogress=function(){},f.ontimeout=n,f.open(m,y,!w,e.username,e.password),w||(f.withCredentials=!!e.withCredentials),!w&&e.timeout>0&&(v=setTimeout(function(){p=!0,f.abort("timeout");var e=new Error("XMLHttpRequest timeout");e.code="ETIMEDOUT",n(e)},e.timeout)),f.setRequestHeader)for(d in g)g.hasOwnProperty(d)&&f.setRequestHeader(d,g[d]);else if(e.headers&&!i(e.headers))throw new Error("Headers cannot be set on an XDomainRequest object");return"responseType"in e&&(f.responseType=e.responseType),"beforeSend"in e&&"function"==typeof e.beforeSend&&e.beforeSend(f),f.send(b),f}function c(e){if("document"===e.responseType)return e.responseXML;var t=204===e.status&&e.responseXML&&"parsererror"===e.responseXML.documentElement.nodeName;return""!==e.responseType||t?null:e.responseXML}function u(){}var l=r(12),f=r(3),h=r(13),d=r(16);e.exports=s,s.XMLHttpRequest=l.XMLHttpRequest||u,s.XDomainRequest="withCredentials"in new s.XMLHttpRequest?s.XMLHttpRequest:l.XDomainRequest,n(["get","put","post","patch","head","delete"],function(e){s["delete"===e?"del":e]=function(t,r,n){return r=o(t,r,n),r.method=e.toUpperCase(),a(r)}})},function(e,t,r){function n(e,t,r){if(!a(t))throw new TypeError("iterator must be a function");arguments.length<3&&(r=this),"[object Array]"===c.call(e)?i(e,t,r):"string"==typeof e?o(e,t,r):s(e,t,r)}function i(e,t,r){for(var n=0,i=e.length;n<i;n++)u.call(e,n)&&t.call(r,e[n],n,e)}function o(e,t,r){for(var n=0,i=e.length;n<i;n++)t.call(r,e.charAt(n),n,e)}function s(e,t,r){for(var n in e)u.call(e,n)&&t.call(r,e[n],n,e)}var a=r(3);e.exports=n;var c=Object.prototype.toString,u=Object.prototype.hasOwnProperty},function(e,t,r){(function(t){"undefined"!=typeof window?e.exports=window:"undefined"!=typeof t?e.exports=t:"undefined"!=typeof self?e.exports=self:e.exports={}}).call(t,r(15))},function(e,t,r){var n=r(14),i=r(11),o=function(e){return"[object Array]"===Object.prototype.toString.call(e)};e.exports=function(e){if(!e)return{};var t={};return i(n(e).split("\n"),function(e){var r=e.indexOf(":"),i=n(e.slice(0,r)).toLowerCase(),s=n(e.slice(r+1));"undefined"==typeof t[i]?t[i]=s:o(t[i])?t[i].push(s):t[i]=[t[i],s]}),t}},function(e,t){function r(e){return e.replace(/^\s*|\s*$/g,"")}t=e.exports=r,t.left=function(e){return e.replace(/^\s*/,"")},t.right=function(e){return e.replace(/\s*$/,"")}},function(e,t){var r;r=function(){return this}();try{r=r||Function("return this")()||(0,eval)("this")}catch(e){"object"==typeof window&&(r=window)}e.exports=r},function(e,t){function r(){for(var e={},t=0;t<arguments.length;t++){var r=arguments[t];for(var i in r)n.call(r,i)&&(e[i]=r[i])}return e}e.exports=r;var n=Object.prototype.hasOwnProperty},function(e,t,r){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function o(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function s(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),c=r(1),u=n(c),l=r(5),f=n(l),h=r(4),d=n(h),p=r(10),v=n(p),y=r(0),m=n(y),b=r(9),g=n(b),w=r(6),_=n(w),E=r(7),S=n(E),k=r(8),L=n(k),A=["ready","mute","unmute","start","stop","error"],O=function(e){function t(e,r,n){i(this,t);var s=o(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));s.broadcasterEl=(0,m.default)("div",["broadcaster"]),s.bar=(0,m.default)("div",["control-bar"]),s.el=e,s.el.appendChild(s.broadcasterEl),s.el.appendChild(s.bar),s.accessKeyEndpoint=r,s.options=n,n.gateway&&(n.janusGateway=n.gateway),n.host||(n.host="livelyvideo.tv");for(var a=[],c=[],u=0;u<s.options.drivers.length;u++)switch(s.options.drivers[u]){case"flash":n.rtmpUrl||a.push("flash driver requires rtmpUrl"),c.push(d.default);break;case"webrtc":n.janusGateway||a.push("webrtc driver requires gateway"),n.rtmpUrl||a.push("webrtc driver requires rtmpUrl"),n.iceServers&&!n.iceServers.length&&a.push("webrtc requires ice servers");break;default:a.push("unknown driver "+s.options.drivers[u])}if(a.length)throw new Error(a.join(", "));return n.drivers=c,n.preview=!0,s.controls=[],s}return s(t,e),a(t,[{key:"destroy",value:function(){this.previewEl&&this.previewEl.remove(),this.bar.remove(),this.broadcaster&&this.broadcaster.destroy()}},{key:"destroyControls",value:function(){for(var e=0;e<this.controls.length;e++)this.controls[e].destroy()}},{key:"setupControls",value:function(){this.controls=[],this.controls.push(new g.default(this)),this.controls.push(new S.default(this)),this.controls.push(new _.default(this)),this.controls.push(new L.default(this))}},{key:"setup",value:function(e,t){var r=this,n=this.accessKeyEndpoint;if(t){var i=n.indexOf("?")===-1?"?":"&";n+=i+"regenerate=1"}this.destroyControls(),(0,v.default)({method:"GET",uri:n,json:!0},function(t,n,i){if(t)return r.emit("error","failed to get access key",t),void(e&&e(t));if(n.statusCode>399){var o=new Error(i);return r.emit("error","failed to get access key",o),void(e&&e(o))}r.accessKey=i.results.pvtKey,r.broadcaster=new f.default(r.broadcasterEl,r.accessKey,r.options);for(var s=function(e){r.broadcaster.on(A[e],function(){for(var t=arguments.length,n=Array(t),i=0;i<t;i++)n[i]=arguments[i];n.unshift(A[e]),r.emit.apply(r,n)})},a=0;a<A.length;a++)s(a);r.setupControls(),r.emit("access-key",r.accessKey),e&&e()})}},{key:"regenerate",value:function(e){this.broadcaster&&this.broadcaster.destroy(),this.setup(e,!0)}}]),t}(u.default);t.default=O}])});
},{}],51:[function(require,module,exports){
'use strict';

if (typeof window === 'undefined') {
	module.exports = function noop() {};
} else {
	module.exports = require('./stock-live-player').default;
}
},{"./stock-live-player":52}],52:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _player = require('@livelyvideo/player-core/lib/player');

var _player2 = _interopRequireDefault(_player);

var _driver = require('@livelyvideo/player-media-source-mp4-driver/lib/driver');

var _driver2 = _interopRequireDefault(_driver);

var _driver3 = require('@livelyvideo/player-hlsjs-driver/lib/driver');

var _driver4 = _interopRequireDefault(_driver3);

var _driver5 = require('@livelyvideo/player-native-hls-driver/lib/driver');

var _driver6 = _interopRequireDefault(_driver5);

var _driver7 = require('@livelyvideo/player-flash-rtmp-driver/lib/driver');

var _driver8 = _interopRequireDefault(_driver7);

var _index = require('@livelyvideo/player-controls/lib/index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Class representing StockLivePlayer
 */
var StockLivePlayer = function (_EventEmitter) {
	_inherits(StockLivePlayer, _EventEmitter);

	/**
  * Constructs an instance of StockLivePlayer
  *
  * @property player
  * @property controls
  * @param {object} el - el containing dom element
  * @param {string} manifest - manifest uri or object
  * @param {Config} options
  * @param {string} [options.host] - host
  * @param {bool} [options.autoplay=true] - autoplays the stream when it loads
  * @param {number} [options.bitrate=undefined] - null for adaptive when available, desired kbps otherwise
  * @param {array} [options.drivers=['mediaSourceMp4', 'hls', 'hlsjs', 'flash']] - driver priority
  * @param {bool} [options.debug=false] - enables debug logging
  * @param {number} [options.recoverErrorCount=10] - Playback error count to recover the entire driver on
  * @param {number} [options.forceDrivers=false]
  * @param {bool} [options.muted] - whether or not the driver is muted
  * @param {bool} [options.hijackingClicks=true] - whether or not the rest of the app is hijacking clicks for mobile autoplays
  * @param {number} [options.pollingInterval=10000] - ms timeout to wait before polling again
  * @param {number} [options.unauthorizedPollingInterval=1000] - ms timeout to wait before polling again if unauthorized, designed to be more frequent for a short interval of time to restart playback
  * @param {number} [options.unauthorizedRecoveryDuration=5000] - ms timeout to poll quickly after receiving an unauthorized response
  * @param {string} [options.posterUri] - sets the poster attribute when available
  * @param {bool} [options.origin=false] - play the origin source
  * @param {number} [options.volume=0.75] - 0-1 volume
  * @param {Config} [controlsOptions] controls options
  * @param {array} [controlsOptions.controls=['overlay', 'playpause', 'fullscreen', 'popout', 'progress', 'quality-selector','volume']] - controls to attach
  * @param {object} [controlsOptions.popout] - popout options
  * @param {string} [controlsOptions.popout.url] - url for popout
  * @param {number} [controlsOptions.popout.width] - width for popout in px
  * @param {number} [controlsOptions.popout.height] - height for popout in px
  * @constructs StockLivePlayer
  */
	function StockLivePlayer(el, manifest, options, controlsOptions) {
		_classCallCheck(this, StockLivePlayer);

		var _this = _possibleConstructorReturn(this, (StockLivePlayer.__proto__ || Object.getPrototypeOf(StockLivePlayer)).call(this));

		_this.el = el;
		_this.playerEl = document.createElement('div');
		_this.controlsEl = document.createElement('div');
		_this.el.appendChild(_this.playerEl);
		_this.el.appendChild(_this.controlsEl);

		options = options || {};
		controlsOptions = controlsOptions || {};

		var drivers = [];
		if (!options.drivers) {
			drivers = [_driver2.default, _driver4.default, _driver6.default, _driver8.default];
		} else {
			for (var i = 0; i < options.drivers.length; i++) {
				switch (options.drivers[i]) {
					case 'hlsjs':
						drivers.push(_driver4.default);
						break;
					case 'hls':
						drivers.push(_driver6.default);
						break;
					case 'mediaSourceMp4':
						drivers.push(_driver2.default);
						break;
					case 'flashRtmp':
						drivers.push(_driver8.default);
						break;
					default:
						break;
				}
			}
		}
		controlsOptions.messages = controlsOptions.messages || {};
		options.drivers = drivers;
		_this.player = new _player2.default(_this.playerEl, manifest, options);
		_this.controls = new _index2.default(_this.controlsEl, controlsOptions);
		_this.controls.attach(_this.player);
		return _this;
	}

	/**
  * Destroys controls and player
  */


	_createClass(StockLivePlayer, [{
		key: 'destroy',
		value: function destroy() {
			this.playerEl.remove();
			this.controlsEl.remove();
			this.controls.destroy();
			this.player.destroy();
		}
	}]);

	return StockLivePlayer;
}(_events2.default);

exports.default = StockLivePlayer;
},{"@livelyvideo/player-controls/lib/index":7,"@livelyvideo/player-core/lib/player":27,"@livelyvideo/player-flash-rtmp-driver/lib/driver":39,"@livelyvideo/player-hlsjs-driver/lib/driver":43,"@livelyvideo/player-media-source-mp4-driver/lib/driver":46,"@livelyvideo/player-native-hls-driver/lib/driver":49,"events":54}],53:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],54:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],55:[function(require,module,exports){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

},{"is-function":57}],56:[function(require,module,exports){
(function (global){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],57:[function(require,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],58:[function(require,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize include="noop" exports="npm" -o ./foo`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A no-operation function that returns `undefined` regardless of the
 * arguments it receives.
 *
 * @static
 * @memberOf _
 * @category Util
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.noop(object) === undefined;
 * // => true
 */
function noop() {
  // No operation performed.
}

module.exports = noop;

},{}],59:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = throttle;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],60:[function(require,module,exports){
var trim = require('trim')
  , forEach = require('for-each')
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}
},{"for-each":55,"trim":63}],61:[function(require,module,exports){
/*!    SWFObject v2.3.20120118 <http://github.com/swfobject/swfobject>
    is released under the MIT License <http://www.opensource.org/licenses/mit-license.php>
*/

(function (root, factory) {
    if (typeof module !== 'undefined') {
        module.exports = factory();
    } else if (typeof define === 'function' && typeof define.amd !== 'undefined') {
        define(factory);
    } else {
        root.swfobject = factory();
    }
}(this, function () {

    var UNDEF = "undefined",
        OBJECT = "object",
        SHOCKWAVE_FLASH = "Shockwave Flash",
        SHOCKWAVE_FLASH_AX = "ShockwaveFlash.ShockwaveFlash",
        FLASH_MIME_TYPE = "application/x-shockwave-flash",
        EXPRESS_INSTALL_ID = "SWFObjectExprInst",
        ON_READY_STATE_CHANGE = "onreadystatechange",

        win = window,
        doc = document,
        nav = navigator,

        plugin = false,
        domLoadFnArr = [],
        regObjArr = [],
        objIdArr = [],
        listenersArr = [],
        storedFbContent,
        storedFbContentId,
        storedCallbackFn,
        storedCallbackObj,
        isDomLoaded = false,
        isExpressInstallActive = false,
        dynamicStylesheet,
        dynamicStylesheetMedia,
        autoHideShow = true,
        encodeURI_enabled = false,

    /* Centralized function for browser feature detection
        - User agent string detection is only used when no good alternative is possible
        - Is executed directly for optimal performance
    */
    ua = function() {
        var w3cdom = typeof doc.getElementById != UNDEF && typeof doc.getElementsByTagName != UNDEF && typeof doc.createElement != UNDEF,
            u = nav.userAgent.toLowerCase(),
            p = nav.platform.toLowerCase(),
            windows = p ? /win/.test(p) : /win/.test(u),
            mac = p ? /mac/.test(p) : /mac/.test(u),
            webkit = /webkit/.test(u) ? parseFloat(u.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")) : false, // returns either the webkit version or false if not webkit
            ie = nav.appName === "Microsoft Internet Explorer",
            playerVersion = [0,0,0],
            d = null;
        if (typeof nav.plugins != UNDEF && typeof nav.plugins[SHOCKWAVE_FLASH] == OBJECT) {
            d = nav.plugins[SHOCKWAVE_FLASH].description;
            // nav.mimeTypes["application/x-shockwave-flash"].enabledPlugin indicates whether plug-ins are enabled or disabled in Safari 3+
            if (d && (typeof nav.mimeTypes != UNDEF && nav.mimeTypes[FLASH_MIME_TYPE] && nav.mimeTypes[FLASH_MIME_TYPE].enabledPlugin)){
                plugin = true;
                ie = false; // cascaded feature detection for Internet Explorer
                d = d.replace(/^.*\s+(\S+\s+\S+$)/, "$1");
                playerVersion[0] = toInt(d.replace(/^(.*)\..*$/, "$1"));
                playerVersion[1] = toInt(d.replace(/^.*\.(.*)\s.*$/, "$1"));
                playerVersion[2] = /[a-zA-Z]/.test(d) ? toInt(d.replace(/^.*[a-zA-Z]+(.*)$/, "$1")) : 0;
            }
        }
        else if (typeof win.ActiveXObject != UNDEF) {
            try {
                var a = new ActiveXObject(SHOCKWAVE_FLASH_AX);
                if (a) { // a will return null when ActiveX is disabled
                    d = a.GetVariable("$version");
                    if (d) {
                        ie = true; // cascaded feature detection for Internet Explorer
                        d = d.split(" ")[1].split(",");
                        playerVersion = [toInt(d[0]), toInt(d[1]), toInt(d[2])];
                    }
                }
            }
            catch(e) {}
        }
        return { w3:w3cdom, pv:playerVersion, wk:webkit, ie:ie, win:windows, mac:mac };
    }(),

    /* Cross-browser onDomLoad
        - Will fire an event as soon as the DOM of a web page is loaded
        - Internet Explorer workaround based on Diego Perini's solution: http://javascript.nwbox.com/IEContentLoaded/
        - Regular onload serves as fallback
    */
    onDomLoad = function() {
        if (!ua.w3) { return; }
        if ((typeof doc.readyState != UNDEF && (doc.readyState === "complete" || doc.readyState === "interactive")) || (typeof doc.readyState == UNDEF && (doc.getElementsByTagName("body")[0] || doc.body))) { // function is fired after onload, e.g. when script is inserted dynamically
            callDomLoadFunctions();
        }
        if (!isDomLoaded) {
            if (typeof doc.addEventListener != UNDEF) {
                doc.addEventListener("DOMContentLoaded", callDomLoadFunctions, false);
            }
            if (ua.ie) {
                doc.attachEvent(ON_READY_STATE_CHANGE, function detach() {
                    if (doc.readyState == "complete") {
                        doc.detachEvent(ON_READY_STATE_CHANGE, detach);
                        callDomLoadFunctions();
                    }
                });
                if (win == top) { // if not inside an iframe
                    (function checkDomLoadedIE(){
                        if (isDomLoaded) { return; }
                        try {
                            doc.documentElement.doScroll("left");
                        }
                        catch(e) {
                            setTimeout(checkDomLoadedIE, 0);
                            return;
                        }
                        callDomLoadFunctions();
                    }());
                }
            }
            if (ua.wk) {
                (function checkDomLoadedWK(){
                    if (isDomLoaded) { return; }
                    if (!/loaded|complete/.test(doc.readyState)) {
                        setTimeout(checkDomLoadedWK, 0);
                        return;
                    }
                    callDomLoadFunctions();
                }());
            }
        }
    }();

    function callDomLoadFunctions() {
        if (isDomLoaded || !document.getElementsByTagName("body")[0]) { return; }
        try { // test if we can really add/remove elements to/from the DOM; we don't want to fire it too early
            var t, span = createElement("span");
            span.style.display = "none"; //hide the span in case someone has styled spans via CSS
            t = doc.getElementsByTagName("body")[0].appendChild(span);
            t.parentNode.removeChild(t);
            t = null; //clear the variables
            span = null;
        }
        catch (e) { return; }
        isDomLoaded = true;
        var dl = domLoadFnArr.length;
        for (var i = 0; i < dl; i++) {
            domLoadFnArr[i]();
        }
    }

    function addDomLoadEvent(fn) {
        if (isDomLoaded) {
            fn();
        }
        else {
            domLoadFnArr[domLoadFnArr.length] = fn; // Array.push() is only available in IE5.5+
        }
    }

    /* Cross-browser onload
        - Based on James Edwards' solution: http://brothercake.com/site/resources/scripts/onload/
        - Will fire an event as soon as a web page including all of its assets are loaded
     */
    function addLoadEvent(fn) {
        if (typeof win.addEventListener != UNDEF) {
            win.addEventListener("load", fn, false);
        }
        else if (typeof doc.addEventListener != UNDEF) {
            doc.addEventListener("load", fn, false);
        }
        else if (typeof win.attachEvent != UNDEF) {
            addListener(win, "onload", fn);
        }
        else if (typeof win.onload == "function") {
            var fnOld = win.onload;
            win.onload = function() {
                fnOld();
                fn();
            };
        }
        else {
            win.onload = fn;
        }
    }


    /* Detect the Flash Player version for non-Internet Explorer browsers
        - Detecting the plug-in version via the object element is more precise than using the plugins collection item's description:
          a. Both release and build numbers can be detected
          b. Avoid wrong descriptions by corrupt installers provided by Adobe
          c. Avoid wrong descriptions by multiple Flash Player entries in the plugin Array, caused by incorrect browser imports
        - Disadvantage of this method is that it depends on the availability of the DOM, while the plugins collection is immediately available
    */
    function testPlayerVersion() {
        var b = doc.getElementsByTagName("body")[0];
        var o = createElement(OBJECT);
        o.setAttribute("style", "visibility: hidden;");
        o.setAttribute("type", FLASH_MIME_TYPE);
        var t = b.appendChild(o);
        if (t) {
            var counter = 0;
            (function checkGetVariable(){
                if (typeof t.GetVariable != UNDEF) {
                    try {
                        var d = t.GetVariable("$version");
                        if (d) {
                            d = d.split(" ")[1].split(",");
                            ua.pv = [toInt(d[0]), toInt(d[1]), toInt(d[2])];
                        }
                    } catch(e){
                        //t.GetVariable("$version") is known to fail in Flash Player 8 on Firefox
                        //If this error is encountered, assume FP8 or lower. Time to upgrade.
                        ua.pv = [8,0,0];
                    }
                }
                else if (counter < 10) {
                    counter++;
                    setTimeout(checkGetVariable, 10);
                    return;
                }
                b.removeChild(o);
                t = null;
                matchVersions();
            }());
        }
        else {
            matchVersions();
        }
    }

    /* Perform Flash Player and SWF version matching; static publishing only
    */
    function matchVersions() {
        var rl = regObjArr.length;
        if (rl > 0) {
            for (var i = 0; i < rl; i++) { // for each registered object element
                var id = regObjArr[i].id;
                var cb = regObjArr[i].callbackFn;
                var cbObj = {success:false, id:id};
                if (ua.pv[0] > 0) {
                    var obj = getElementById(id);
                    if (obj) {
                        if (hasPlayerVersion(regObjArr[i].swfVersion) && !(ua.wk && ua.wk < 312)) { // Flash Player version >= published SWF version: Houston, we have a match!
                            setVisibility(id, true);
                            if (cb) {
                                cbObj.success = true;
                                cbObj.ref = getObjectById(id);
                                cbObj.id = id;
                                cb(cbObj);
                            }
                        }
                        else if (regObjArr[i].expressInstall && canExpressInstall()) { // show the Adobe Express Install dialog if set by the web page author and if supported
                            var att = {};
                            att.data = regObjArr[i].expressInstall;
                            att.width = obj.getAttribute("width") || "0";
                            att.height = obj.getAttribute("height") || "0";
                            if (obj.getAttribute("class")) { att.styleclass = obj.getAttribute("class"); }
                            if (obj.getAttribute("align")) { att.align = obj.getAttribute("align"); }
                            // parse HTML object param element's name-value pairs
                            var par = {};
                            var p = obj.getElementsByTagName("param");
                            var pl = p.length;
                            for (var j = 0; j < pl; j++) {
                                if (p[j].getAttribute("name").toLowerCase() != "movie") {
                                    par[p[j].getAttribute("name")] = p[j].getAttribute("value");
                                }
                            }
                            showExpressInstall(att, par, id, cb);
                        }
                        else { // Flash Player and SWF version mismatch or an older Webkit engine that ignores the HTML object element's nested param elements: display fallback content instead of SWF
                            displayFbContent(obj);
                            if (cb) { cb(cbObj); }
                        }
                    }
                }
                else {    // if no Flash Player is installed or the fp version cannot be detected we let the HTML object element do its job (either show a SWF or fallback content)
                    setVisibility(id, true);
                    if (cb) {
                        var o = getObjectById(id); // test whether there is an HTML object element or not
                        if (o && typeof o.SetVariable != UNDEF) {
                            cbObj.success = true;
                            cbObj.ref = o;
                            cbObj.id = o.id;
                        }
                        cb(cbObj);
                    }
                }
            }
        }
    }

    /* Main function
        - Will preferably execute onDomLoad, otherwise onload (as a fallback)
    */
    domLoadFnArr[0] = function (){
        if (plugin) {
            testPlayerVersion();
        }
        else {
            matchVersions();
        }
    };

    function getObjectById(objectIdStr) {

        var r = null,
            o = getElementById(objectIdStr);

        if (o && o.nodeName.toUpperCase() === "OBJECT") {

            //If targeted object is valid Flash file
            if (typeof o.SetVariable !== UNDEF){

                r = o;

            } else {

                //If SetVariable is not working on targeted object but a nested object is
                //available, assume classic nested object markup. Return nested object.

                //If SetVariable is not working on targeted object and there is no nested object,
                //return the original object anyway. This is probably new simplified markup.

                r = o.getElementsByTagName(OBJECT)[0] || o;

            }

        }

        return r;

    }

    /* Requirements for Adobe Express Install
        - only one instance can be active at a time
        - fp 6.0.65 or higher
        - Win/Mac OS only
        - no Webkit engines older than version 312
    */
    function canExpressInstall() {
        return !isExpressInstallActive && hasPlayerVersion("6.0.65") && (ua.win || ua.mac) && !(ua.wk && ua.wk < 312);
    }

    /* Show the Adobe Express Install dialog
        - Reference: http://www.adobe.com/cfusion/knowledgebase/index.cfm?id=6a253b75
    */
    function showExpressInstall(att, par, replaceElemIdStr, callbackFn) {

        var obj = getElementById(replaceElemIdStr);

        //Ensure that replaceElemIdStr is really a string and not an element
        replaceElemIdStr = getId(replaceElemIdStr);

        isExpressInstallActive = true;
        storedCallbackFn = callbackFn || null;
        storedCallbackObj = {success:false, id:replaceElemIdStr};

        if (obj) {
            if (obj.nodeName.toUpperCase() == "OBJECT") { // static publishing
                storedFbContent = abstractFbContent(obj);
                storedFbContentId = null;
            }
            else { // dynamic publishing
                storedFbContent = obj;
                storedFbContentId = replaceElemIdStr;
            }
            att.id = EXPRESS_INSTALL_ID;
            if (typeof att.width == UNDEF || (!/%$/.test(att.width) && toInt(att.width) < 310)) { att.width = "310"; }
            if (typeof att.height == UNDEF || (!/%$/.test(att.height) && toInt(att.height) < 137)) { att.height = "137"; }
            doc.title = doc.title.slice(0, 47) + " - Flash Player Installation";
            var pt = ua.ie ? "ActiveX" : "PlugIn",
                fv = "MMredirectURL=" + encodeURIComponent(win.location.toString().replace(/&/g,"%26")) + "&MMplayerType=" + pt + "&MMdoctitle=" + doc.title;
            if (typeof par.flashvars != UNDEF) {
                par.flashvars += "&" + fv;
            }
            else {
                par.flashvars = fv;
            }
            // IE only: when a SWF is loading (AND: not available in cache) wait for the readyState of the object element to become 4 before removing it,
            // because you cannot properly cancel a loading SWF file without breaking browser load references, also obj.onreadystatechange doesn't work
            if (ua.ie && obj.readyState != 4) {
                var newObj = createElement("div");
                replaceElemIdStr += "SWFObjectNew";
                newObj.setAttribute("id", replaceElemIdStr);
                obj.parentNode.insertBefore(newObj, obj); // insert placeholder div that will be replaced by the object element that loads expressinstall.swf
                obj.style.display = "none";
                removeSWF(obj); //removeSWF accepts elements now
            }
            createSWF(att, par, replaceElemIdStr);
        }
    }

    /* Functions to abstract and display fallback content
    */
    function displayFbContent(obj) {
        if (ua.ie && obj.readyState != 4) {
            // IE only: when a SWF is loading (AND: not available in cache) wait for the readyState of the object element to become 4 before removing it,
            // because you cannot properly cancel a loading SWF file without breaking browser load references, also obj.onreadystatechange doesn't work
            obj.style.display = "none";
            var el = createElement("div");
            obj.parentNode.insertBefore(el, obj); // insert placeholder div that will be replaced by the fallback content
            el.parentNode.replaceChild(abstractFbContent(obj), el);
            removeSWF(obj); //removeSWF accepts elements now
        }
        else {
            obj.parentNode.replaceChild(abstractFbContent(obj), obj);
        }
    }

    function abstractFbContent(obj) {
        var ac = createElement("div");
        if (ua.win && ua.ie) {
            ac.innerHTML = obj.innerHTML;
        }
        else {
            var nestedObj = obj.getElementsByTagName(OBJECT)[0];
            if (nestedObj) {
                var c = nestedObj.childNodes;
                if (c) {
                    var cl = c.length;
                    for (var i = 0; i < cl; i++) {
                        if (!(c[i].nodeType == 1 && c[i].nodeName == "PARAM") && !(c[i].nodeType == 8)) {
                            ac.appendChild(c[i].cloneNode(true));
                        }
                    }
                }
            }
        }
        return ac;
    }


    function createIeObject(url, param_str){
        var div = createElement("div");
        div.innerHTML = "<object classid='clsid:D27CDB6E-AE6D-11cf-96B8-444553540000'><param name='movie' value='" +url + "'>" + param_str + "</object>";
        return div.firstChild;
    }

    /* Cross-browser dynamic SWF creation
    */
    function createSWF(attObj, parObj, id) {

        var r, el = getElementById(id);

        id = getId(id); // ensure id is truly an ID and not an element

        if (ua.wk && ua.wk < 312) { return r; }

        if (el) {

            var o = (ua.ie) ? createElement("div") : createElement(OBJECT),
                attr,
                attr_lower,
                param;

            if (typeof attObj.id == UNDEF) { // if no 'id' is defined for the object element, it will inherit the 'id' from the fallback content
                attObj.id = id;
            }

            //Add params
            for (param in parObj) {
                //filter out prototype additions from other potential libraries and IE specific param element
                if (parObj.hasOwnProperty(param) && param.toLowerCase() !== "movie") {
                    createObjParam(o, param, parObj[param]);
                }
            }

            //Create IE object, complete with param nodes
            if(ua.ie){ o = createIeObject(attObj.data, o.innerHTML); }

            //Add attributes to object
            for (attr in attObj) {
                if (attObj.hasOwnProperty(attr)) { // filter out prototype additions from other potential libraries

                    attr_lower = attr.toLowerCase();

                    // 'class' is an ECMA4 reserved keyword
                    if (attr_lower === "styleclass") {
                        o.setAttribute("class", attObj[attr]);
                    } else if (attr_lower !== "classid" && attr_lower !== "data") {
                        o.setAttribute(attr, attObj[attr]);
                    }

                }
            }

            if (ua.ie) {

                objIdArr[objIdArr.length] = attObj.id; // stored to fix object 'leaks' on unload (dynamic publishing only)

            } else {

                o.setAttribute("type", FLASH_MIME_TYPE);
                o.setAttribute("data", attObj.data);

            }

            el.parentNode.replaceChild(o, el);
            r = o;

        }
        return r;
    }


    function createObjParam(el, pName, pValue) {
        var p = createElement("param");
        p.setAttribute("name", pName);
        p.setAttribute("value", pValue);
        el.appendChild(p);
    }

    /* Cross-browser SWF removal
        - Especially needed to safely and completely remove a SWF in Internet Explorer
    */
    function removeSWF(id) {
        var obj = getElementById(id);
        if (obj && obj.nodeName.toUpperCase() == "OBJECT") {
            if (ua.ie) {
                obj.style.display = "none";
                (function removeSWFInIE(){
                    if (obj.readyState == 4) {
						//This step prevents memory leaks in Internet Explorer
			            for (var i in obj) {
			                if (typeof obj[i] == "function") {
			                    obj[i] = null;
			                }
			            }
			            obj.parentNode.removeChild(obj);
                    } else {
                        setTimeout(removeSWFInIE, 10);
                    }
                }());
            }
            else {
                obj.parentNode.removeChild(obj);
            }
        }
    }

    function isElement(id){
        return (id && id.nodeType && id.nodeType === 1);
    }

    function getId(thing){
        return (isElement(thing)) ? thing.id : thing;
    }

    /* Functions to optimize JavaScript compression
    */
    function getElementById(id) {

        //Allow users to pass an element OR an element's ID
        if(isElement(id)){ return id; }

        var el = null;
        try {
            el = doc.getElementById(id);
        }
        catch (e) {}
        return el;
    }

    function createElement(el) {
        return doc.createElement(el);
    }

    //To aid compression; replaces 14 instances of pareseInt with radix
    function toInt(str){
        return parseInt(str, 10);
    }

    /* Updated attachEvent function for Internet Explorer
        - Stores attachEvent information in an Array, so on unload the detachEvent functions can be called to avoid memory leaks
    */
    function addListener(target, eventType, fn) {
        target.attachEvent(eventType, fn);
        listenersArr[listenersArr.length] = [target, eventType, fn];
    }

    /* Flash Player and SWF content version matching
    */
    function hasPlayerVersion(rv) {
        rv += ""; //Coerce number to string, if needed.
        var pv = ua.pv, v = rv.split(".");
        v[0] = toInt(v[0]);
        v[1] = toInt(v[1]) || 0; // supports short notation, e.g. "9" instead of "9.0.0"
        v[2] = toInt(v[2]) || 0;
        return (pv[0] > v[0] || (pv[0] == v[0] && pv[1] > v[1]) || (pv[0] == v[0] && pv[1] == v[1] && pv[2] >= v[2])) ? true : false;
    }

    /* Cross-browser dynamic CSS creation
        - Based on Bobby van der Sluis' solution: http://www.bobbyvandersluis.com/articles/dynamicCSS.php
    */
    function createCSS(sel, decl, media, newStyle) {
        var h = doc.getElementsByTagName("head")[0];
        if (!h) { return; } // to also support badly authored HTML pages that lack a head element
        var m = (typeof media == "string") ? media : "screen";
        if (newStyle) {
            dynamicStylesheet = null;
            dynamicStylesheetMedia = null;
        }
        if (!dynamicStylesheet || dynamicStylesheetMedia != m) {
            // create dynamic stylesheet + get a global reference to it
            var s = createElement("style");
            s.setAttribute("type", "text/css");
            s.setAttribute("media", m);
            dynamicStylesheet = h.appendChild(s);
            if (ua.ie && typeof doc.styleSheets != UNDEF && doc.styleSheets.length > 0) {
                dynamicStylesheet = doc.styleSheets[doc.styleSheets.length - 1];
            }
            dynamicStylesheetMedia = m;
        }
        // add style rule
        if(dynamicStylesheet){
            if (typeof dynamicStylesheet.addRule != UNDEF) {
                dynamicStylesheet.addRule(sel, decl);
            } else if (typeof doc.createTextNode != UNDEF) {
                dynamicStylesheet.appendChild(doc.createTextNode(sel + " {" + decl + "}"));
            }
        }
    }

    function setVisibility(id, isVisible) {
        if (!autoHideShow) { return; }
        var v = isVisible ? "visible" : "hidden",
            el = getElementById(id);
        if (isDomLoaded && el) {
            el.style.visibility = v;
        } else if(typeof id === "string"){
            createCSS("#" + id, "visibility:" + v);
        }
    }

    /* Filter to avoid XSS attacks
    */
    function urlEncodeIfNecessary(s) {
        var regex = /[\\\"<>\.;]/;
        var hasBadChars = regex.exec(s) != null;
        return hasBadChars && typeof encodeURIComponent != UNDEF ? encodeURIComponent(s) : s;
    }

    /* Release memory to avoid memory leaks caused by closures, fix hanging audio/video threads and force open sockets/NetConnections to disconnect (Internet Explorer only)
    */
    var cleanup = function() {
        if (ua.ie) {
            window.attachEvent("onunload", function() {
                // remove listeners to avoid memory leaks
                var ll = listenersArr.length;
                for (var i = 0; i < ll; i++) {
                    listenersArr[i][0].detachEvent(listenersArr[i][1], listenersArr[i][2]);
                }
                // cleanup dynamically embedded objects to fix audio/video threads and force open sockets and NetConnections to disconnect
                var il = objIdArr.length;
                for (var j = 0; j < il; j++) {
                    removeSWF(objIdArr[j]);
                }
                // cleanup library's main closures to avoid memory leaks
                for (var k in ua) {
                    ua[k] = null;
                }
                ua = null;
                if( typeof swfobject !== "undefined" ){
	                for (var l in swfobject) {
	                    swfobject[l] = null;
	                }
	                swfobject = null;
                }
            });
        }
    }();

    return {
        /* Public API
            - Reference: http://code.google.com/p/swfobject/wiki/documentation
        */
        registerObject: function(objectIdStr, swfVersionStr, xiSwfUrlStr, callbackFn) {
            if (ua.w3 && objectIdStr && swfVersionStr) {
                var regObj = {};
                regObj.id = objectIdStr;
                regObj.swfVersion = swfVersionStr;
                regObj.expressInstall = xiSwfUrlStr;
                regObj.callbackFn = callbackFn;
                regObjArr[regObjArr.length] = regObj;
                setVisibility(objectIdStr, false);
            }
            else if (callbackFn) {
                callbackFn({success:false, id:objectIdStr});
            }
        },

        getObjectById: function(objectIdStr) {
            if (ua.w3) {
                return getObjectById(objectIdStr);
            }
        },

        embedSWF: function(swfUrlStr, replaceElemIdStr, widthStr, heightStr, swfVersionStr, xiSwfUrlStr, flashvarsObj, parObj, attObj, callbackFn) {

            var id = getId(replaceElemIdStr),
                callbackObj = {success:false, id:id};

            if (ua.w3 && !(ua.wk && ua.wk < 312) && swfUrlStr && replaceElemIdStr && widthStr && heightStr && swfVersionStr) {
                setVisibility(id, false);
                addDomLoadEvent(function() {
                    widthStr += ""; // auto-convert to string
                    heightStr += "";
                    var att = {};
                    if (attObj && typeof attObj === OBJECT) {
                        for (var i in attObj) { // copy object to avoid the use of references, because web authors often reuse attObj for multiple SWFs
                            att[i] = attObj[i];
                        }
                    }
                    att.data = swfUrlStr;
                    att.width = widthStr;
                    att.height = heightStr;
                    var par = {};
                    if (parObj && typeof parObj === OBJECT) {
                        for (var j in parObj) { // copy object to avoid the use of references, because web authors often reuse parObj for multiple SWFs
                            par[j] = parObj[j];
                        }
                    }
                    if (flashvarsObj && typeof flashvarsObj === OBJECT) {
                        for (var k in flashvarsObj) { // copy object to avoid the use of references, because web authors often reuse flashvarsObj for multiple SWFs
                            if(flashvarsObj.hasOwnProperty(k)){

                                var key = (encodeURI_enabled) ? encodeURIComponent(k) : k,
                                    value = (encodeURI_enabled) ? encodeURIComponent(flashvarsObj[k]) : flashvarsObj[k];

                                if (typeof par.flashvars != UNDEF) {
                                    par.flashvars += "&" + key + "=" + value;
                                }
                                else {
                                    par.flashvars = key + "=" + value;
                                }

                            }
                        }
                    }
                    if (hasPlayerVersion(swfVersionStr)) { // create SWF
                        var obj = createSWF(att, par, replaceElemIdStr);
                        if (att.id == id) {
                            setVisibility(id, true);
                        }
                        callbackObj.success = true;
                        callbackObj.ref = obj;
                        callbackObj.id = obj.id;
                    }
                    else if (xiSwfUrlStr && canExpressInstall()) { // show Adobe Express Install
                        att.data = xiSwfUrlStr;
                        showExpressInstall(att, par, replaceElemIdStr, callbackFn);
                        return;
                    }
                    else { // show fallback content
                        setVisibility(id, true);
                    }
                    if (callbackFn) { callbackFn(callbackObj); }
                });
            }
            else if (callbackFn) { callbackFn(callbackObj);    }
        },

        switchOffAutoHideShow: function() {
            autoHideShow = false;
        },

        enableUriEncoding: function (bool) {
            encodeURI_enabled = (typeof bool === UNDEF) ? true : bool;
        },

        ua: ua,

        getFlashPlayerVersion: function() {
            return { major:ua.pv[0], minor:ua.pv[1], release:ua.pv[2] };
        },

        hasFlashPlayerVersion: hasPlayerVersion,

        createSWF: function(attObj, parObj, replaceElemIdStr) {
            if (ua.w3) {
                return createSWF(attObj, parObj, replaceElemIdStr);
            }
            else {
                return undefined;
            }
        },

        showExpressInstall: function(att, par, replaceElemIdStr, callbackFn) {
            if (ua.w3 && canExpressInstall()) {
                showExpressInstall(att, par, replaceElemIdStr, callbackFn);
            }
        },

        removeSWF: function(objElemIdStr) {
            if (ua.w3) {
                removeSWF(objElemIdStr);
            }
        },

        createCSS: function(selStr, declStr, mediaStr, newStyleBoolean) {
            if (ua.w3) {
                createCSS(selStr, declStr, mediaStr, newStyleBoolean);
            }
        },

        addDomLoadEvent: addDomLoadEvent,

        addLoadEvent: addLoadEvent,

        getQueryParamValue: function(param) {
            var q = doc.location.search || doc.location.hash;
            if (q) {
                if (/\?/.test(q)) { q = q.split("?")[1]; } // strip question mark
                if (param == null) {
                    return urlEncodeIfNecessary(q);
                }
                var pairs = q.split("&");
                for (var i = 0; i < pairs.length; i++) {
                    if (pairs[i].substring(0, pairs[i].indexOf("=")) == param) {
                        return urlEncodeIfNecessary(pairs[i].substring((pairs[i].indexOf("=") + 1)));
                    }
                }
            }
            return "";
        },

        // For internal usage only
        expressInstallCallback: function() {
            if (isExpressInstallActive) {
                var obj = getElementById(EXPRESS_INSTALL_ID);
                if (obj && storedFbContent) {
                    obj.parentNode.replaceChild(storedFbContent, obj);
                    if (storedFbContentId) {
                        setVisibility(storedFbContentId, true);
                        if (ua.ie) { storedFbContent.style.display = "block"; }
                    }
                    if (storedCallbackFn) { storedCallbackFn(storedCallbackObj); }
                }
                isExpressInstallActive = false;
            }
        },

		version: "2.3"

    };
}));

},{}],62:[function(require,module,exports){
module.exports = function(node, value) {
  var text = (node.textContent !== undefined ?
    'textContent' : 'innerText'
  )

  if (typeof value != 'undefined') {
    node[text] = value
  }

  return node[text]
}

},{}],63:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],64:[function(require,module,exports){
"use strict";
var window = require("global/window")
var isFunction = require("is-function")
var parseHeaders = require("parse-headers")
var xtend = require("xtend")

module.exports = createXHR
createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest

forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback)
        options.method = method.toUpperCase()
        return _createXHR(options)
    }
})

function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
        iterator(array[i])
    }
}

function isEmpty(obj){
    for(var i in obj){
        if(obj.hasOwnProperty(i)) return false
    }
    return true
}

function initParams(uri, options, callback) {
    var params = uri

    if (isFunction(options)) {
        callback = options
        if (typeof uri === "string") {
            params = {uri:uri}
        }
    } else {
        params = xtend(options, {uri: uri})
    }

    params.callback = callback
    return params
}

function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback)
    return _createXHR(options)
}

function _createXHR(options) {
    if(typeof options.callback === "undefined"){
        throw new Error("callback argument missing")
    }

    var called = false
    var callback = function cbOnce(err, response, body){
        if(!called){
            called = true
            options.callback(err, response, body)
        }
    }

    function readystatechange() {
        if (xhr.readyState === 4) {
            setTimeout(loadFunc, 0)
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else {
            body = xhr.responseText || getXml(xhr)
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
        }
        evt.statusCode = 0
        return callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return
        var status
        clearTimeout(timeoutTimer)
        if(options.useXDR && xhr.status===undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200
        } else {
            status = (xhr.status === 1223 ? 204 : xhr.status)
        }
        var response = failureResponse
        var err = null

        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        return callback(err, response, response.body)
    }

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest()
        }else{
            xhr = new createXHR.XMLHttpRequest()
        }
    }

    var key
    var aborted
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer
    var failureResponse = {
        body: undefined,
        headers: {},
        statusCode: 0,
        method: method,
        url: uri,
        rawRequest: xhr
    }

    if ("json" in options && options.json !== false) {
        isJson = true
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
            body = JSON.stringify(options.json === true ? body : options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.onabort = function(){
        aborted = true;
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync, options.username, options.password)
    //has to be after open
    if(!sync) {
        xhr.withCredentials = !!options.withCredentials
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            if (aborted) return
            aborted = true//IE9 may still call readystatechange
            xhr.abort("timeout")
            var e = new Error("XMLHttpRequest timeout")
            e.code = "ETIMEDOUT"
            errorFunc(e)
        }, options.timeout )
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }

    if ("beforeSend" in options &&
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    // Microsoft Edge browser sends "undefined" when send is called with undefined value.
    // XMLHttpRequest spec says to pass null as body to indicate no body
    // See https://github.com/naugtur/xhr/issues/100.
    xhr.send(body || null)

    return xhr


}

function getXml(xhr) {
    if (xhr.responseType === "document") {
        return xhr.responseXML
    }
    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror"
    if (xhr.responseType === "" && !firefoxBugTakenEffect) {
        return xhr.responseXML
    }

    return null
}

function noop() {}

},{"global/window":56,"is-function":57,"parse-headers":60,"xtend":65}],65:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}]},{},[1]);
