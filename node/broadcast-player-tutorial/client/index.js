import StockBroadcaster from '@livelyvideo/stock-broadcaster';
import StockPlayer from '@livelyvideo/stock-live-player/lib/index.js';
import xhr from 'xhr';
import text from 'text-content';

/**
Set up the flash broadcaster.

Params:
	- html element
	- relative or absolute path to retrieve an access key, defined in server.js
	- driver options [webrtc driver will be coming soon]
			> affiliate: required, this is your company/affiliate name
			> flashWmode: sets the flashWmode attribute
			> gateway: will be used for webrtc to define path, this can be left null if not using webrtc
			> iceServers: will be used for webrtc, this can be left null if not using webrtc
			> preview: defaults to true, false if broadcast w/no preview
			> rtmpUrl: origin server, this can be left null if not using flash
			> tfSwfPath: path to thinflash swf, located in /dist for this demo, this can be left null if not using flash

Events:
	- ready - broadcaster has been set up
	- mute - audio input has been muted
	- unmute - audio input unmuted
	- start - broadcasting has begun
	- stop - broadcast has stopped
	- error - fatal error

I attached the stockBroadcaster to the window so it can be accessed from console.  It has the broadcaster on it, and the controls.

**/
const stockBroadcaster = new StockBroadcaster(document.querySelector('#broadcaster'), '/access-key', {
	affiliate: 'dev',
	tfSwfPath: '/thinDebug.swf',
	rtmpUrl: 'rtmp://uc-ls-dev.livelyvideo.tv/origin',
	drivers: ['flash']
});
stockBroadcaster.on('error', (...args) => {
	console.error('error', args);
});
stockBroadcaster.setup();
window.stockBroadcaster = stockBroadcaster;


/**
Function to load the stock player, triggered later by a click event on <a> tags generated by the "get listings" button

Params:
	- html element
	- manifest url, returned by the listings endpoint located in server.js
	- player options
		> autoplay: [true] autoplays the stream when it loads
		> bitrate: [undefined] null for adaptive when available, desired kbps otherwise
		> drivers: ["mp4", "nativeHls", "jsHls", "flash", lodef"] driver priority
		> debug: [false] enables debug logging
		> recoverErrorCount: [10] Playback error count to recover the entire driver on
		> forceDrivers:	[false]
		> muted: whether or not the driver is muted
		> pollingInterval: [10000] ms timeout to wait before polling again
		> volume: [0.75] 0-1 volume
	- controls options
		> popout: popout options
		> popout[].url: url for popout
		> popout[].width: width for popout in px
		> popout[].height: height for popout in px

Events:
	- error emitted with all errors
	- exit-fullscreen
	- enter-fullscreen
	- bitrate-switch
	- select-driver
	- manifest
	- play
	- stop
	- pause
	- stall
	- progress
	- timeupdate
	- mute
	- unmute
	- volume
	- online
	- offline
	- estimated-bw
	- user-active
	- user-idle
**/
let stockPlayer;
let currentManifest;
let drivers = ['mediaSourceMp4', 'hlsjs', 'hls', 'flashRtmp'];
function loadPlayer (manifest) {
	if (stockPlayer) {
		stockPlayer.destroy();
	}

	currentManifest = manifest;
	window.stockPlayer = stockPlayer = new StockPlayer(document.querySelector('#player'), manifest, {
		drivers: drivers,
		hlsjsPath: 'https://cdn.jsdelivr.net/hls.js/latest/hls.min.js',
		tfSwfPath: '/thinDebug.swf'
	});
}

/** Below is demo code **/

// retrieves listings from server.js
function getListings (cb) {
	xhr({
		method: 'GET',
		url: '/listings',
		json: true
	}, (err, response, body) => {
		if (err) {
			console.error(err);
			cb(err);
			return;
		}

		if (response.statusCode > 399) {
			console.error('unexpected status code', response.statusCode, body);
			cb(new Error(body));
			return;
		}

		cb(null, body);
	});
}

// create a button to load active listings and a div to contain them
const getListingsButton = document.createElement('button');
const resultsContainer = document.createElement('div');
const result = document.createElement('a');
result.setAttribute('href', '#');
text(getListingsButton, 'Load Listings');

// on click, empty div, retrieve listings, and render a tags for each listing
getListingsButton.onclick = () => {
	while (resultsContainer.children.length) {
		resultsContainer.children[0].remove();
	}

	getListings((err, body) => {
		if (err) {
			return;
		}

		for (let i = 0; i < body.results.length; i++) {
			const entry = result.cloneNode();
			text(entry, body.results[i].broadcasterId);

			// for each listing, add a click listener to load that manifest.
			entry.onclick = function (manifest) {
				return (e) => {
					e.preventDefault();
					loadPlayer(manifest);
				};
			}(body.results[i].manifest);
			resultsContainer.appendChild(entry);
		}
	});
};
getListingsButton.onclick();

document.querySelector('.listings').appendChild(getListingsButton);
document.querySelector('.listings').appendChild(resultsContainer);

// Configure player
document.querySelector('#config-drivers').onsubmit = (e) => {
	e.preventDefault();
	const input = e.target.querySelector('input');
	const tmpDrivers = input.value.split(',');
	const nextDrivers = [];

	for (let i = 0; i < tmpDrivers.length; i++) {
		switch(tmpDrivers[i]) {
			case 'flashRtmp':
				nextDrivers.push('flashRtmp');
				break;
			case 'hlsjs':
				nextDrivers.push('hlsjs');
				break;
			case 'mediaSourceMp4':
				nextDrivers.push('mediaSourceMp4');
				break;
			case 'hls':
				nextDrivers.push('hls');
				break;
		}
	}

	drivers = nextDrivers;
	loadPlayer(currentManifest);
	input.value = drivers.join(', ');
};
document.querySelector('#config-drivers input').value = drivers.join(', ');
